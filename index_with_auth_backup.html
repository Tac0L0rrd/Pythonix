<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pythonix</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Base URL for API endpoints; leave blank for same origin (relative) -->
  <meta name="api-base" content="">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  
  <!-- 
  AUDIO FILES USED:
  - eat.mp3: Food eating sound
  - powerup.mp3: Power-up sound and menu selections
  - gameover.mp3: Game over sound
  - menu.wav: Background music for start menu
  - hover.wav: Button hover effects
  - click.wav: Button click sounds
  -->
  <style>
    html, body {
      min-height: 100vh;
      margin: 0;
      font-family: 'Press Start 2P', 'Segoe UI', Arial, sans-serif;
      background: var(--bg, linear-gradient(135deg, #66b5ff 0%, #3863ff 100%));
      transition: background 0.4s;
      margin: 0;
      font-size: 1rem;
      color: #222;
      font-weight: 600;
      /* mimic current.com logo style */
      cursor: default;
    }

    /* Navbar styles */
    .navbar {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 14px;
      padding: 8px 12px;
      max-width: 1100px;
      margin: 18px auto;
      background: hsla(0,0%,100%,.05);
      border-radius: 12px;
      border: 1px solid hsla(0,0%,100%,.1);
      box-shadow: 0 10px 40px rgba(2, 6, 23, 0.55), inset 0 1px 0 rgba(255, 255, 255, 0.02);
      backdrop-filter: blur(12px) saturate(140%);
      transition: all .3s ease;
      position: sticky;
      top: 10px;
      z-index: 1000;
    }

    .navbar-brand {
      display: flex;
      align-items: center;
      gap: 12px;
      padding-right: 10px;
      border-right: 1px solid rgba(255, 255, 255, 0.03);
    }

    .navbar-brand h2 {
      margin: 0;
      color: #fff;
      font-size: 1rem;
      text-shadow: 0 6px 18px rgba(0, 0, 0, 0.45);
    }

    .navbar-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 24px;
      align-items: flex-start;
      padding: 8px 16px;
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      transition: all .3s ease 0.1s;
    }

    .navbar:hover .navbar-controls,
    .navbar:focus-within .navbar-controls,
    .navbar-controls:focus-within {
      max-height: 400px;
      opacity: 1;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 0;
    }

    .group-title {
      font-size: 11px;
      font-weight: 700;
      color: rgba(255, 255, 255, 0.7);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    }

    .control-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .stats-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-bottom: 8px;
    }

    .action-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .navbar-controls label {
      background: transparent;
      padding: 8px 12px;
      border-radius: 10px;
      color: #e0e0e0;
      font-weight: 700;
      font-size: 0.85rem;
      text-shadow: none;
    }

    .navbar-controls select,
    .navbar-controls input[type="text"] {
      background: rgba(255, 255, 255, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: #ffffff;
      padding: 6px 8px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 14px;
    }

    .navbar-controls select {
      background: rgba(40, 60, 80, 0.9);
      color: #ffffff;
      border: 1px solid rgba(255, 255, 255, 0.4);
    }

    .navbar-controls input[type="range"] {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 8px;
      height: 6px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
      width: 80px;
      margin-right: 8px;
    }

    .navbar-controls input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #ffffff;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .navbar-controls input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #ffffff;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .navbar-controls select:focus,
    .navbar-controls input[type="text"]:focus {
      outline: none;
      border-color: rgba(255, 255, 255, 0.6);
      background: rgba(50, 70, 90, 0.95);
    }

    .navbar-controls input[type="text"]:focus {
      background: rgba(255, 255, 255, 0.25);
    }

    .navbar-controls select option {
      background: #2c3e50;
      color: #ffffff;
      padding: 8px;
      font-weight: 600;
    }

    .navbar-controls select option:hover {
      background: #34495e;
    }

    .small-btn {
  background: rgba(255, 255, 255, 0.2);
  color: #ffffff;
  border-radius: 10px;
  padding: 8px 12px;
  border: 1px solid rgba(255, 255, 255, 0.3);
  cursor: pointer;
  font-weight: 700;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
  font-size: 14px;
  transition: all 0.2s ease;
}

.small-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: translateY(-1px);
}

.stat-item {
  color: #ffffff;
  font-weight: 600;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
  font-size: 13px;
  padding: 4px 8px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 6px;
  border: 1px solid rgba(255, 255, 255, 0.2);
}

#emojiPicker {
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.4);
  color: #ffffff;
  text-align: center;
  font-size: 18px;
  width: 50px;
  padding: 6px;
  border-radius: 8px;
  font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', sans-serif;
}

/* ensure emoji picker stands out */
.emoji-picker {
  background: linear-gradient(180deg, #ffffff, #f2f2f2);
  padding: 4px 8px;
  border-radius: 8px;
  font-size: 1.05rem;
  cursor: pointer;
}

/* Amazing animated themes with special effects */
.theme-day { 
  background: linear-gradient(135deg, #87CEEB 0%, #98FB98 40%, #F0E68C 100%);
  --board-bg: #f0f8ff;
  --container-bg: rgba(255, 255, 255, 0.9);
  --container-border: rgba(0, 100, 200, 0.4);
  position: relative;
}
.theme-day::before {
  content: '';
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  pointer-events: none;
  z-index: 1;
  background-image: 
    radial-gradient(60px 30px at 100px 50px, rgba(255,255,255,0.8), transparent),
    radial-gradient(80px 40px at 300px 100px, rgba(255,255,255,0.6), transparent),
    radial-gradient(50px 25px at 500px 80px, rgba(255,255,255,0.7), transparent),
    radial-gradient(70px 35px at 200px 150px, rgba(255,255,255,0.5), transparent),
    radial-gradient(90px 45px at 700px 120px, rgba(255,255,255,0.6), transparent),
    radial-gradient(55px 28px at 800px 60px, rgba(255,255,255,0.7), transparent);
  background-repeat: repeat;
  background-size: 900px 200px;
  animation: cloudDrift 30s linear infinite;
}
.theme-day::after {
  content: '';
  position: fixed;
  top: 50px; right: 50px;
  width: 100px; height: 100px;
  pointer-events: none;
  z-index: 1;
  background: radial-gradient(circle, #FFD700 30%, rgba(255,215,0,0.3) 70%, transparent);
  border-radius: 50%;
  animation: sunPulse 4s ease-in-out infinite;
  box-shadow: 0 0 50px rgba(255,215,0,0.5);
}

.theme-night { 
  background: linear-gradient(135deg, #0c0c0c 0%, #1a0033 50%, #000051 100%);
  --board-bg: #050f1e;
  --container-bg: rgba(20, 20, 50, 0.8);
  --container-border: rgba(0, 255, 255, 0.4);
  position: relative;
}
.theme-night::before {
  content: '';
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  pointer-events: none;
  z-index: 1;
  background-image: 
    radial-gradient(2px 2px at 50px 50px, #ffffff, transparent),
    radial-gradient(1px 1px at 150px 100px, rgba(255,255,255,0.8), transparent),
    radial-gradient(2px 2px at 300px 150px, #ffffff, transparent),
    radial-gradient(1px 1px at 450px 80px, rgba(255,255,255,0.9), transparent),
    radial-gradient(3px 3px at 200px 200px, #87CEEB, transparent);
  background-repeat: repeat;
  background-size: 500px 250px;
  animation: starfield 25s linear infinite;
}
.theme-night::after {
  content: '';
  position: fixed;
  top: 0; left: -10%; right: -10%; /* Extend beyond screen edges */
  height: 25vh; /* Only top quarter of screen */
  pointer-events: none;
  z-index: 1;
  background: linear-gradient(180deg, 
    rgba(0,255,150,0.3) 0%,
    rgba(150,0,255,0.4) 20%, 
    rgba(0,150,255,0.3) 40%, 
    rgba(255,20,147,0.2) 60%,
    rgba(0,255,150,0.1) 80%,
    transparent 100%),
    /* Add radial fade from sides */
    radial-gradient(ellipse 120% 100% at center top,
    rgba(255,255,255,0.1) 0%,
    transparent 70%);
  animation: aurora 30s ease-in-out infinite;
  opacity: 0.6;
}

.theme-classic { 
  background: #000000;
  --board-bg: #000000;
  --snake-color: #00ff00;
  --food-color: #00ff00;
  --powerup-color: #ffff00;
  --container-bg: #003300;
  --container-border: #00ff00;
  --text-color: #00ff00;
  position: relative;
}
.theme-classic::before {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: -1;
  background: 
    repeating-linear-gradient(90deg, 
      transparent, 
      transparent 39px, 
      rgba(0, 255, 0, 0.1) 40px),
    repeating-linear-gradient(0deg,
      transparent,
      transparent 39px,
      rgba(0, 255, 0, 0.1) 40px);
}

.theme-pacman { 
  background: #000080;
  --board-bg: #000080;
  --snake-color: #ffff00;
  --food-color: #ffffff;
  --powerup-color: #ffffff;
  --container-bg: #000040;
  --container-border: #0000ff;
  --text-color: #ffff00;
  position: relative;
}
.theme-pacman::before {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: -1;
  background: 
    repeating-linear-gradient(90deg, 
      transparent, 
      transparent 38px, 
      rgba(0, 0, 255, 0.2) 40px, 
      rgba(0, 0, 255, 0.2) 44px),
    repeating-linear-gradient(0deg,
      transparent,
      transparent 38px,
      rgba(0, 0, 255, 0.2) 40px,
      rgba(0, 0, 255, 0.2) 44px);
}
.theme-pacman::after {
  content: '';
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  pointer-events: none;
  z-index: -2;
  background-image: 
    radial-gradient(2px 2px at 60px 60px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 140px 60px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 220px 60px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 300px 60px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 380px 60px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 60px 140px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 140px 140px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 220px 140px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 300px 140px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 380px 140px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 60px 220px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 140px 220px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 220px 220px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 300px 220px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 380px 220px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 60px 300px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 140px 300px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 220px 300px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 300px 300px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 380px 300px, rgba(255, 255, 0, 0.3), transparent);
  background-repeat: repeat;
  background-size: 440px 360px;
  animation: pacmanDots 2s ease-in-out infinite;
}

.theme-gameboy { 
  background: #9bbc0f;
  --board-bg: #8bac0f;
  --snake-color: #306230;
  --food-color: #0f380f;
  --powerup-color: #1e4620;
  --container-bg: #8bac0f;
  --container-border: #306230;
  --text-color: #306230;
  position: relative;
  font-family: 'Courier New', monospace;
}
.theme-gameboy::before {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 1;
  background: 
    repeating-linear-gradient(0deg, 
      transparent, 
      transparent 1px, 
      rgba(48, 98, 48, 0.1) 2px,
      rgba(48, 98, 48, 0.1) 3px,
      transparent 4px);
  animation: gameboyScreen 0.1s linear infinite;
}
.theme-gameboy::after {
  content: 'DOT MATRIX WITH STEREO SOUND';
  position: fixed;
  bottom: 10px; 
  left: 50%;
  transform: translateX(-50%);
  color: #306230;
  font-family: 'Courier New', monospace;
  font-size: 6px;
  font-weight: bold;
  pointer-events: none;
  z-index: 2;
  opacity: 0.7;
  letter-spacing: 1px;
}

.theme-neon { 
  background: #000000;
  --board-bg: #001122;
  --snake-color: #00ffff;
  --food-color: #ff00ff;
  --powerup-color: #ffff00;
  --container-bg: #001122;
  --container-border: #00ffff;
  --text-color: #00ffff;
  position: relative;
}
.theme-neon::before {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 1;
  background: 
    repeating-linear-gradient(90deg, 
      transparent, 
      transparent 39px, 
      rgba(0, 255, 255, 0.3) 40px, 
      rgba(0, 255, 255, 0.3) 41px),
    repeating-linear-gradient(0deg,
      transparent,
      transparent 39px,
      rgba(255, 0, 255, 0.3) 40px,
      rgba(255, 0, 255, 0.3) 41px);
  animation: neonGlow 3s ease-in-out infinite;
}
.theme-neon::after {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 0;
  background: 
    radial-gradient(circle at 20% 20%, rgba(0, 255, 255, 0.05), transparent 40%),
    radial-gradient(circle at 80% 80%, rgba(255, 0, 255, 0.05), transparent 40%),
    radial-gradient(circle at 50% 50%, rgba(255, 255, 0, 0.03), transparent 50%);
  animation: neonPulse 4s ease-in-out infinite;
}

.theme-arcade { 
  background: #000000;
  --board-bg: #1a0a2e;
  --snake-color: #ff6b9d;
  --food-color: #ffd700;
  --powerup-color: #00ff88;
  --container-bg: #1a0a2e;
  --container-border: #ffd700;
  --text-color: #ffd700;
  position: relative;
  border: 3px solid #ffd700;
}
.theme-arcade::before {
  content: '';
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  pointer-events: none;
  z-index: 1;
  background: 
    radial-gradient(circle at 20% 30%, rgba(255, 107, 157, 0.1), transparent 30%),
    radial-gradient(circle at 80% 70%, rgba(0, 255, 136, 0.1), transparent 30%),
    radial-gradient(circle at 50% 20%, rgba(255, 215, 0, 0.1), transparent 25%),
    radial-gradient(circle at 30% 80%, rgba(138, 43, 226, 0.1), transparent 35%);
  animation: arcadePulse 6s ease-in-out infinite;
}
.theme-arcade::after {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 2;
  background: 
    repeating-linear-gradient(0deg, 
      transparent, 
      transparent 2px, 
      rgba(255, 215, 0, 0.05) 3px,
      transparent 4px);
  animation: arcadeScanlines 0.1s linear infinite;
}

    /* Simple, gentle animations for special effects only */
    @keyframes gentleStars {
      0%, 100% { opacity: 0.1; }
      50% { opacity: 0.3; }
    }
    @keyframes spookyFloat {
      0% { transform: translateY(100vh) translateX(0%); }
      100% { transform: translateY(-10vh) translateX(100%); }
    }
    @keyframes snowDrift {
      0% { transform: translateY(-10px) translateX(0px); }
      100% { transform: translateY(100vh) translateX(100px); }
    }
    
    /* New seamless snow animation for Christmas */
    @keyframes snowDriftSeamless {
      0% { transform: translateY(-120px) translateX(-15px); opacity: 0; }
      3% { opacity: 1; }
      97% { opacity: 1; }
      100% { transform: translateY(calc(100vh + 120px)) translateX(35px); opacity: 0; }
    }
    
    @keyframes snowDriftSeamless2 {
      0% { transform: translateY(-180px) translateX(25px); opacity: 0; }
      7% { opacity: 0.8; }
      93% { opacity: 0.8; }
      100% { transform: translateY(calc(100vh + 180px)) translateX(-30px); opacity: 0; }
    }
    
    @keyframes snowDriftSeamless3 {
      0% { transform: translateY(-90px) translateX(-35px); opacity: 0; }
      2% { opacity: 0.6; }
      98% { opacity: 0.6; }
      100% { transform: translateY(calc(100vh + 90px)) translateX(45px); opacity: 0; }
    }

    @keyframes snowDriftSeamless4 {
      0% { transform: translateY(-150px) translateX(10px); opacity: 0; }
      5% { opacity: 0.7; }
      95% { opacity: 0.7; }
      100% { transform: translateY(calc(100vh + 150px)) translateX(-20px); opacity: 0; }
    }

    @keyframes snowDriftSeamless5 {
      0% { transform: translateY(-200px) translateX(-5px); opacity: 0; }
      8% { opacity: 0.5; }
      92% { opacity: 0.5; }
      100% { transform: translateY(calc(100vh + 200px)) translateX(55px); opacity: 0; }
    }
    
    /* Improved Halloween animations */
    @keyframes halloweenFloat {
      0% { transform: translateY(100vh) translateX(-50px) rotate(0deg); opacity: 0; }
      10% { opacity: 0.15; }
      90% { opacity: 0.15; }
      100% { transform: translateY(-20vh) translateX(100vw) rotate(20deg); opacity: 0; }
    }
    
    /* Enhanced Cyberpunk animations */
    @keyframes matrixRainFlow {
      0% { transform: translateY(-100vh) translateX(-20px); opacity: 0; }
      10% { opacity: 0.8; }
      90% { opacity: 0.8; }
      100% { transform: translateY(100vh) translateX(20px); opacity: 0; }
    }
    
    /* Enhanced Easter animations */
    @keyframes springPetalFall {
      0% { transform: translateY(-50px) translateX(0) rotate(0deg); opacity: 0.8; }
      100% { transform: translateY(calc(100vh + 50px)) translateX(30px) rotate(180deg); opacity: 0.3; }
    }
    
    @keyframes springDance {
      0% { transform: translate(0, 0) rotate(0deg) scale(1); }
      25% { transform: translate(20px, -10px) rotate(5deg) scale(1.05); }
      50% { transform: translate(40px, 0) rotate(-3deg) scale(0.95); }
      75% { transform: translate(20px, 10px) rotate(8deg) scale(1.1); }
      100% { transform: translate(0, 0) rotate(0deg) scale(1); }
    }
    
    /* Enhanced St. Patrick's animations */
    @keyframes rainbowFlow {
      0% { transform: translateX(-100px) scaleY(1); opacity: 0.6; }
      50% { transform: translateX(100px) scaleY(1.2); opacity: 0.8; }
      100% { transform: translateX(-100px) scaleY(1); opacity: 0.6; }
    }
    
    @keyframes springBounce {
      0%, 100% { transform: translateY(0) scale(1); }
      50% { transform: translateY(-5px) scale(1.02); }
    }
    @keyframes luckySpin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    @keyframes fallLeaves {
      0% { transform: translateY(-10vh) rotate(0deg); }
      100% { transform: translateY(100vh) rotate(180deg); }
    }

    /* Amazing new 3D theme animations */
    @keyframes cloudDrift {
      0% { transform: translateX(-300px); }
      100% { transform: translateX(calc(100vw + 300px)); }
    }
    @keyframes sunPulse {
      0%, 100% { transform: scale(1) rotate(0deg); box-shadow: 0 0 50px rgba(255,215,0,0.5); }
      50% { transform: scale(1.1) rotate(180deg); box-shadow: 0 0 80px rgba(255,215,0,0.8); }
    }
    @keyframes starfield {
      0% { transform: translateY(0px) translateX(0px); opacity: 0.8; }
      100% { transform: translateY(-50px) translateX(50px); opacity: 1; }
    }
    @keyframes aurora {
      0% { 
        opacity: 0.4; 
        filter: blur(1px);
        transform: scaleY(1) translateY(0px);
      }
      20% { 
        opacity: 0.6; 
        filter: blur(1.5px);
        transform: scaleY(1.05) translateY(-2px);
      }
      40% { 
        opacity: 0.7; 
        filter: blur(2px);
        transform: scaleY(0.95) translateY(-1px);
      }
      60% { 
        opacity: 0.5; 
        filter: blur(1.5px);
        transform: scaleY(1.1) translateY(-3px);
      }
      80% { 
        opacity: 0.6; 
        filter: blur(1px);
        transform: scaleY(0.98) translateY(-1px);
      }
      100% { 
        opacity: 0.4; 
        filter: blur(1px);
        transform: scaleY(1) translateY(0px);
      }
    }
    @keyframes matrixRain {
      0% { transform: translateY(-100vh); opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { transform: translateY(100vh); opacity: 0; }
    }
    @keyframes cyberGlitch {
      0%, 90%, 100% { opacity: 0.05; }
      5%, 85% { opacity: 0.15; transform: skew(0.5deg); }
      10%, 80% { opacity: 0.1; transform: skew(-0.3deg); }
    }
    @keyframes retroSpin {
      0% { transform: rotate(0deg) scale(1); }
      50% { transform: rotate(180deg) scale(1.1); }
      100% { transform: rotate(360deg) scale(1); }
    }
    @keyframes filmGrain {
      0% { opacity: 0.03; }
      50% { opacity: 0.06; }
      100% { opacity: 0.03; }
    }
    @keyframes plasmaPulse {
      0%, 100% { transform: scale(1) rotate(0deg); opacity: 0.6; }
      20% { transform: scale(1.1) rotate(72deg); opacity: 0.8; }
      40% { transform: scale(0.9) rotate(144deg); opacity: 0.5; }
      60% { transform: scale(1.2) rotate(216deg); opacity: 0.9; }
      80% { transform: scale(0.95) rotate(288deg); opacity: 0.4; }
    }
    @keyframes circuitFlow {
      0% { background-position: 0 0, 0 0, 0 0, 0 0; opacity: 0.3; }
      25% { background-position: 25px 25px, -25px 25px, 25px -25px, -25px -25px; opacity: 0.6; }
      50% { background-position: 50px 50px, -50px 50px, 50px -50px, -50px -50px; opacity: 0.4; }
      75% { background-position: 75px 75px, -75px 75px, 75px -75px, -75px -75px; opacity: 0.7; }
      100% { background-position: 100px 100px, -100px 100px, 100px -100px, -100px -100px; opacity: 0.3; }
    }
    @keyframes ghostFloat {
      0% { transform: translateY(100vh) translateX(0) rotate(0deg); opacity: 0; }
      10% { opacity: 0.6; }
      90% { opacity: 0.3; }
      100% { transform: translateY(-20vh) translateX(80vw) rotate(20deg); opacity: 0; }
    }
    @keyframes spookyGlow {
      0%, 100% { opacity: 0.4; transform: scale(1); }
      25% { opacity: 0.7; transform: scale(1.1); }
      75% { opacity: 0.2; transform: scale(0.9); }
    }
    @keyframes petalFall {
      0% { transform: translateY(-20px) translateX(0) rotate(0deg); }
      100% { transform: translateY(120vh) translateX(50px) rotate(360deg); }
    }
    @keyframes butterflyFly {
      0% { transform: translate(0, 0) rotate(0deg); }
      25% { transform: translate(100px, -50px) rotate(10deg); }
      50% { transform: translate(200px, 0) rotate(-5deg); }
      75% { transform: translate(150px, 50px) rotate(15deg); }
      100% { transform: translate(0, 0) rotate(0deg); }
    }
    @keyframes rainbow {
      0% { transform: translateX(-100px) rotate(-10deg); }
      50% { transform: translateX(100px) rotate(10deg); }
      100% { transform: translateX(-100px) rotate(-10deg); }
    }
    @keyframes cloverSpin {
      0% { transform: translateY(-10px) rotate(0deg) scale(1); opacity: 0.2; }
      50% { transform: translateY(10px) rotate(180deg) scale(1.2); opacity: 0.4; }
      100% { transform: translateY(-10px) rotate(360deg) scale(1); opacity: 0.2; }
    }
    @keyframes gentleLeafFall {
      0% { transform: translateY(-20px) translateX(0) rotate(0deg); opacity: 0.7; }
      50% { transform: translateY(60vh) translateX(-20px) rotate(180deg); opacity: 0.9; }
      100% { transform: translateY(120vh) translateX(30px) rotate(360deg); opacity: 0.5; }
    }
    @keyframes gentleBounce {
      0%, 100% { transform: translateY(0) rotate(-1deg) scale(1); }
      50% { transform: translateY(-3px) rotate(1deg) scale(1.02); }
    }

    /* New gaming theme animations */
    @keyframes pacmanDots {
      0% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.3; transform: scale(0.8); }
      100% { opacity: 1; transform: scale(1); }
    }
    
    @keyframes gameboyScreen {
      0% { opacity: 1; }
      99% { opacity: 1; }
      100% { opacity: 0.98; }
    }
    
    @keyframes neonGlow {
      0%, 100% { 
        opacity: 0.8;
        filter: brightness(1) hue-rotate(0deg);
      }
      25% { 
        opacity: 1;
        filter: brightness(1.2) hue-rotate(90deg);
      }
      50% { 
        opacity: 0.6;
        filter: brightness(0.8) hue-rotate(180deg);
      }
      75% { 
        opacity: 0.9;
        filter: brightness(1.1) hue-rotate(270deg);
      }
    }
    
    @keyframes neonPulse {
      0%, 100% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.1); }
    }
    
    @keyframes arcadeSpin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes arcadeScanlines {
      0% { transform: translateY(0px); }
      100% { transform: translateY(5px); }
    }

    /* subtle improvement for canvas to match theme */
    #gameCanvas { 
      border-radius:12px; 
      border-width:3px; 
      box-shadow: 0 18px 60px rgba(0,0,0,0.3);
      position: relative;
      z-index: 2;
      display: none; /* Initially hidden */
    }
    
    /* Hide game container initially */
    .container {
      display: none !important;
    }
    
    /* Hide navbar initially (show only during gameplay) */
    .navbar {
      display: none !important;
    }
    
    /* Show game elements when game is active */
    body.game-active #gameCanvas {
      display: block !important;
    }
    
    body.game-active .container {
      display: block !important;
    }
    
    body.game-active .navbar {
      display: flex !important;
    }
    
    /* Hide intro screen when game is active */
    body.game-active .intro-screen {
      display: none !important;
    }

    html, body {
      min-height: 100vh;
      margin: 0;
      font-family: 'Press Start 2P', 'Segoe UI', Arial, sans-serif;
      background: var(--bg, linear-gradient(135deg, #66b5ff 0%, #3863ff 100%));
      transition: background 0.4s;
      margin: 0;
      font-size: 1rem;
      color: #222;
      font-weight: 600;
      /* mimic current.com logo style */
      cursor: default;
    }

    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
      box-sizing: border-box;
      padding: 20px;
    }

    .card {
      background: var(--container-bg, rgba(255, 255, 255, 0.85));
      color: var(--text-color, #222);
      border: 2px solid var(--container-border, rgba(255, 255, 255, 0.3));
      padding: 30px 40px;
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      max-width: 95vw; 
      box-sizing: border-box;
    }

    h1 {
      margin-bottom: 10px;
      color: var(--menu, #222);
      letter-spacing: 2px;
      text-shadow: 0 2px 8px #acb6e5;
      font-family: 'Press Start 2P', 'Segoe UI', Arial, sans-serif;
      font-size: 2em;
    }

    .touch-btn {
      width: 48px;
      box-shadow: 0 2px 8px #acb6e5;
      cursor: pointer;
      transform: scale(0.95);
    }

    #gameCanvas {
      background: #f7fffe;
      box-shadow: 0 8px 32px 0 rgba(44,62,80,0.2);
      border: 4px solid #6c7a89;
      display: block;
      margin: 0 auto;
      touch-action: none;
      transition: background 0.4s;
      max-width: 100%;
      height: auto;
    }

    .score-board {
      font-size: 1.5em;
      color: var(--menu, #222);
      font-weight: bold;
      letter-spacing: 1px;
      padding: 8px 24px;
      background: rgba(255,255,255,0.7);
      border-radius: 18px;
      box-shadow: 0 2px 8px #acb6e5;
      transition: color 0.4s;
    }

    .game-over {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(44,62,80,0.78);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 999;
      color: #fff;
      font-size: 2em;
      border-radius: 0;
      animation: fadeIn 0.5s;
    }

    .game-over button {
      margin-top: 24px;
      padding: 12px 32px;
      font-size: 1em;
      border: none;
      border-radius: 18px;
  background: linear-gradient(135deg, #4f8edc 0%, #27c5ff 100%);
      color: #222;
      font-weight: bold;
      box-shadow: 0 2px 8px #acb6e5;
      cursor: pointer;
      transition: background 0.2s;
    }

    .game-over button:hover {
      border-radius: 18px;
  background: linear-gradient(135deg, #4f8edc 0%, #27c5ff 100%);
      color: #222;
      font-weight: bold;
      box-shadow: 0 2px 8px #acb6e5;
      cursor: pointer;
      transition: background 0.2s;
    }

    .game-over button:hover {
  background: linear-gradient(135deg, #4f8edc 0%,#27c5ff  100%);
    }

    @keyframes fadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    @media (max-width: 700px) {
      .card {
        padding: 20px;
        border-radius: 15px;
      }
      .game-over {
        font-size: 1.2em;
        border-radius: 0;
        padding: 0;
      }
    }

    /* Intro screen overlay */
    .intro-screen {
      position: fixed !important;
      top: 0 !important; 
      left: 0 !important; 
      right: 0 !important; 
      bottom: 0 !important;
      background: linear-gradient(135deg, #001433 0%, #003366 25%, #006699 50%, #0099cc 75%, #33aaff 100%);
      display: flex !important;
      flex-direction: column !important;
      align-items: center !important;
      justify-content: center !important;
      color: #fff;
      z-index: 1000;
      overflow: hidden;
      padding: 20px;
      font-family: 'Press Start 2P', monospace;
      height: 100vh !important;
      width: 100vw !important;
    }
    
    .intro-screen::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: 
        repeating-linear-gradient(0deg, 
          transparent, 
          transparent 2px, 
          rgba(0, 150, 255, 0.1) 3px),
        radial-gradient(circle at 50% 20%, rgba(51, 170, 255, 0.3), transparent 50%),
        radial-gradient(circle at 20% 80%, rgba(0, 153, 204, 0.2), transparent 40%),
        radial-gradient(circle at 80% 60%, rgba(0, 150, 255, 0.2), transparent 35%);
      pointer-events: none;
      animation: blueGlow 8s ease-in-out infinite;
    }
    
    @keyframes blueGlow {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }
    
    .intro-container {
      max-width: 600px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 40px;
      position: relative;
      z-index: 2;
      text-align: center;
    }
    
    .intro-screen h1 {
      font-size: 3em;
      margin: 0;
      text-align: center;
      background: linear-gradient(45deg, #33aaff, #0099cc, #0080ff, #66ccff);
      background-size: 300% 300%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 
        0 0 20px #33aaff,
        0 0 40px #0099cc,
        0 0 60px #0080ff;
      letter-spacing: 4px;
      animation: blueTitle 3s ease-in-out infinite;
    }
    
    @keyframes blueTitle {
      0%, 100% { 
        background-position: 0% 50%;
        text-shadow: 
          0 0 20px #33aaff,
          0 0 40px #0099cc,
          0 0 60px #0080ff;
      }
      50% { 
        background-position: 100% 50%;
        text-shadow: 
          0 0 30px #33aaff,
          0 0 50px #0099cc,
          0 0 70px #0080ff,
          0 0 90px #66ccff;
      }
    }
    
    .intro-subtitle {
      text-align: center;
      font-size: 0.8em;
      color: #66ccff;
      margin: 0;
      font-weight: normal;
      letter-spacing: 2px;
      text-shadow: 0 0 10px #66ccff;
      animation: blueBlink 2s ease-in-out infinite;
    }
    
    @keyframes blueBlink {
      0%, 50% { 
        opacity: 1; 
        text-shadow: 0 0 10px #66ccff;
      }
      51%, 100% { 
        opacity: 0.6; 
        text-shadow: 0 0 5px #66ccff;
      }
    }
    
    .menu-options {
      display: flex;
      flex-direction: column;
      gap: 20px;
      align-items: center;
      margin: 20px 0;
    }
    
    .menu-item {
      display: flex;
      align-items: center;
      gap: 15px;
      font-size: 1.2em;
      color: #99ccff;
      cursor: pointer;
      transition: all 0.3s ease;
      padding: 10px 20px;
      letter-spacing: 2px;
      text-shadow: 0 0 5px #99ccff;
    }
    
    .menu-item:hover {
      color: #66b5ff;
      text-shadow: 0 0 15px #66b5ff;
      transform: translateX(10px);
    }
    
    .menu-item.active {
      color: #33aaff;
      text-shadow: 
        0 0 15px #33aaff,
        0 0 25px #0080ff;
      transform: scale(1.05);
    }
    
    .menu-item.active .menu-arrow {
      color: #33aaff;
      text-shadow: 
        0 0 15px #33aaff,
        0 0 25px #0080ff;
      animation: blueArrow 1.5s ease-in-out infinite;
    }
    
    .menu-arrow {
      font-size: 0.8em;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .menu-item.active .menu-arrow {
      opacity: 1;
    }
    
    @keyframes blueArrow {
      0%, 100% { 
        transform: translateX(0px);
        text-shadow: 0 0 15px #33aaff, 0 0 25px #0080ff;
      }
      50% { 
        transform: translateX(8px);
        text-shadow: 0 0 20px #33aaff, 0 0 35px #0080ff, 0 0 45px #66ccff;
      }
    }
    
    .controls-hint {
      margin-top: 40px;
    }
    
    .controls-hint p {
      font-size: 0.7em;
      color: #6699cc;
      margin: 0;
      letter-spacing: 1px;
      text-shadow: 0 0 5px #6699cc;
      opacity: 0.8;
    }
    
    /* Remove old button styles */
    .intro-buttons {
      display: none;
    }
    
    /* Instructions Overlay */
    #instructionsContent {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(135deg, #001433 0%, #003366 25%, #006699 50%, #0099cc 75%, #33aaff 100%);
      z-index: 1001;
      overflow-y: auto;
      padding: 20px;
      display: none;
    }
    
    #instructionsContent.show {
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }
    
    .instructions-close-btn {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(51, 170, 255, 0.3);
      border: 2px solid #33aaff;
      color: #33aaff;
      font-size: 1.5em;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      z-index: 1002;
      text-shadow: 0 0 10px #33aaff;
      box-shadow: 0 0 20px rgba(51, 170, 255, 0.5);
    }
    
    .instructions-close-btn:hover {
      background: rgba(51, 170, 255, 0.5);
      color: #fff;
      transform: scale(1.1);
      box-shadow: 0 0 30px rgba(51, 170, 255, 0.8);
      text-shadow: 0 0 15px #33aaff;
    }
    
    .intro-screen button {
      padding: 15px 35px;
      font-size: 1.1em;
      border: none;
      border-radius: 50px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      cursor: pointer;
      box-shadow: 
        0 8px 25px rgba(102, 126, 234, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      position: relative;
      overflow: hidden;
    }
    
    .intro-screen button::before {
      content: '';
      position: absolute;
      top: 0; left: -100%;
      width: 100%; height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }
    
    .intro-screen button:hover::before {
      left: 100%;
    }
    
    .intro-screen button:hover {
      transform: translateY(-3px);
      box-shadow: 
        0 12px 35px rgba(102, 126, 234, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }
    
    .intro-screen button:active {
      transform: translateY(-1px);
    }
    
    .intro-screen button#startBtn {
      background: linear-gradient(135deg, #4fc3f7 0%, #29b6f6 50%, #03a9f4 100%);
      box-shadow: 
        0 8px 25px rgba(79, 195, 247, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }
    
    .intro-screen button#startBtn:hover {
      box-shadow: 
        0 12px 35px rgba(79, 195, 247, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }
    
    .instructions-section {
      background: linear-gradient(135deg, rgba(51, 170, 255, 0.15), rgba(0, 153, 204, 0.1));
      border-radius: 20px;
      padding: 30px;
      margin: 20px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(51, 170, 255, 0.3);
      box-shadow: 0 8px 32px rgba(51, 170, 255, 0.2);
    }
    
    .instructions-section h2 {
      color: #66ccff;
      margin-top: 0;
      margin-bottom: 20px;
      font-size: 1.6em;
      font-weight: 600;
      text-shadow: 0 0 10px #66ccff;
    }
    
    .instructions-section h3 {
      color: #99ccff;
      margin-top: 25px;
      margin-bottom: 15px;
      font-size: 1.2em;
      font-weight: 500;
      text-shadow: 0 0 8px #99ccff;
    }
    
    .instructions-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }
    
    .instruction-item {
      background: linear-gradient(135deg, rgba(51, 170, 255, 0.1), rgba(0, 153, 204, 0.05));
      padding: 20px;
      border-radius: 15px;
      border-left: 4px solid #33aaff;
      backdrop-filter: blur(5px);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      border: 1px solid rgba(51, 170, 255, 0.2);
    }
    
    .instruction-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(51, 170, 255, 0.3);
      border-color: #33aaff;
    }
    
    .instruction-item h4 {
      color: #ffff99;
      margin: 0 0 10px 0;
      font-size: 1.1em;
      font-weight: 600;
      text-shadow: 0 0 8px #ffff99;
    }
    
    .instruction-item p {
      margin: 8px 0;
      line-height: 1.5;
      font-size: 0.95em;
      color: rgba(255, 255, 255, 0.9);
    }
    
    .controls-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin: 15px 0;
    }
    
    .control-item {
      background: linear-gradient(135deg, rgba(51, 170, 255, 0.1), rgba(0, 153, 204, 0.05));
      padding: 12px 16px;
      border-radius: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      backdrop-filter: blur(5px);
      transition: transform 0.2s ease;
      border: 1px solid rgba(51, 170, 255, 0.2);
      color: rgba(255, 255, 255, 0.9);
    }
    
    .control-item:hover {
      transform: scale(1.02);
      border-color: #33aaff;
      box-shadow: 0 4px 15px rgba(51, 170, 255, 0.2);
    }
    
    .control-key {
      background: linear-gradient(135deg, #003366, #006699);
      padding: 6px 12px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      color: #66ccff;
      box-shadow: 0 2px 8px rgba(51, 170, 255, 0.3);
      border: 1px solid #33aaff;
      text-shadow: 0 0 5px #66ccff;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .intro-screen h1 {
        font-size: 2.5em;
        margin: 20px 0 15px 0;
      }
      
      .intro-subtitle {
        font-size: 1em;
        margin-bottom: 20px;
      }
      
      .intro-buttons {
        flex-direction: column;
        align-items: center;
        gap: 15px;
      }
      
      .intro-screen button {
        width: 80%;
        max-width: 300px;
      }
      
      .instructions-grid {
        grid-template-columns: 1fr;
      }
      
      .controls-list {
        grid-template-columns: 1fr;
      }
      
      .instructions-section {
        padding: 20px;
      }
    }
    
    @media (max-width: 480px) {
      .intro-screen h1 {
        font-size: 2em;
      }
      
      .intro-screen {
        padding: 15px;
      }
      
      .instructions-section {
        padding: 15px;
      }
    }
        @media (max-width: 480px) {
          .card { padding: 15px; }
          .score-board, .score-board ~ .score-board { font-size: 1em; padding: 6px 12px; }
        }

    /* Modal / panel styles for history & achievements */
    .panel-modal {
      position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.6); z-index: 2000;
    }
    .panel-modal .panel {
      background: #fff; color:#222; padding:18px; border-radius:12px; width:90%; max-width:720px; max-height:80vh; overflow:auto;
    }
    .theme-badge { display:inline-block; padding:6px 10px; border-radius:10px; margin:6px; cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,0.12); }
    .small-btn { padding:6px 10px; border-radius:8px; cursor:pointer; border:none; background:#e6e6e6; margin-left:6px; }
    /* obstacle tile */
    .obstacle { background:#333; }

.achievements-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 15px;
  margin-top: 20px;
}

.achievement {
  display: flex;
  align-items: center;
  padding: 15px;
  border-radius: 10px;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.1);
}

.achievement.unlocked {
  background: rgba(76, 175, 80, 0.2);
  border-color: rgba(76, 175, 80, 0.3);
}

.achievement.locked {
  opacity: 0.6;
}

.achievement-icon {
  font-size: 2rem;
  margin-right: 15px;
}

.achievement-info h4 {
  margin: 0 0 5px 0;
  color: #fff;
}

.achievement-info p {
  margin: 0;
  color: #ccc;
  font-size: 0.9rem;
}

.stats-overview {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
  margin: 20px 0;
}

.stat-item {
  padding: 15px;
  background: rgba(255,255,255,0.05);
  border-radius: 8px;
  text-align: center;
  color: #fff;
}

.history-list {
  max-height: 400px;
  overflow-y: auto;
}

.history-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 15px;
  margin: 10px 0;
  background: rgba(255,255,255,0.03);
  border-radius: 8px;
  border-left: 4px solid #4CAF50;
}

.game-info {
  display: flex;
  gap: 20px;
}

.game-score {
  font-weight: bold;
  color: #4CAF50;
}

.game-foods {
  color: #2196F3;
}

.game-mode {
  color: #FF9800;
}

.game-date {
  color: #ccc;
  font-size: 0.9rem;
}

/* Style for clear games button */
.clear-btn {
  background: rgba(220, 53, 69, 0.9) !important;
  color: #ffffff !important;
  border: 1px solid rgba(220, 53, 69, 0.8) !important;
}
.clear-btn:hover {
  background: rgba(220, 53, 69, 1) !important;
  transform: translateY(-1px);
}

  </style>
</head>
<body class="theme-day">
  <!-- Intro Screen -->
  <div id="introScreen" class="intro-screen">
    <div class="intro-container">
      <h1>üêç PYTHONIX</h1>
      <p class="intro-subtitle">PRESS SPACEBAR TO START</p>
      
      <div class="menu-options">
        <div class="menu-item active" id="startOption">
          <span class="menu-arrow">‚ñ∫</span>
          <span>START GAME</span>
        </div>
        <div class="menu-item" id="instructionsOption">
          <span class="menu-arrow">‚ñ∫</span>
          <span>INSTRUCTIONS</span>
        </div>
      </div>
      
      <div class="controls-hint">
        <p>USE ‚Üë‚Üì ARROWS TO SELECT ‚Ä¢ SPACEBAR TO CONFIRM</p>
        <div id="userStatus" style="margin-top: 10px; color: #66b5ff; font-size: 0.7em;"></div>
      </div>
    </div>
  </div>
  
  <!-- Instructions Overlay -->
  <div id="instructionsContent" style="display: none;">
    <button class="instructions-close-btn" onclick="toggleInstructions()">‚úï</button>
    <div class="intro-container" style="max-width: 900px; width: 100%; padding: 40px 20px; text-align: center; margin: 0 auto; align-self: flex-start; margin-top: 40px;">
      <h1 style="text-align: center; font-size: 2.5em; margin-bottom: 40px; background: linear-gradient(45deg, #33aaff, #0099cc, #0080ff, #66ccff); background-size: 300% 300%; -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-shadow: 0 0 20px #33aaff, 0 0 40px #0099cc; letter-spacing: 3px; animation: blueTitle 3s ease-in-out infinite;">üìñ Game Instructions</h1>
        <div class="instructions-section">
          <h2>üéÆ How to Play</h2>
          <p>Control your snake to eat food and grow longer while avoiding walls and your own tail. The goal is to achieve the highest score possible!</p>
          
          <h3>Controls</h3>
          <div class="controls-list">
            <div class="control-item">
              <span>Move Up</span>
              <span class="control-key">‚Üë or W</span>
            </div>
            <div class="control-item">
              <span>Move Down</span>
              <span class="control-key">‚Üì or S</span>
            </div>
            <div class="control-item">
              <span>Move Left</span>
              <span class="control-key">‚Üê or A</span>
            </div>
            <div class="control-item">
              <span>Move Right</span>
              <span class="control-key">‚Üí or D</span>
            </div>
            <div class="control-item">
              <span>Pause/Resume</span>
              <span class="control-key">Space</span>
            </div>
          </div>
        </div>

        <div class="instructions-section">
          <h2>üé® Themes & Skins</h2>
          <p><strong>Important:</strong> For the best visual experience, match your snake skin with the corresponding theme!</p>
          
          <div class="instructions-grid">
            <div class="instruction-item">
              <h4>üü¢ Classic Snake</h4>
              <p><strong>Theme:</strong> Classic</p>
              <p><strong>Skin:</strong> Classic Snake</p>
              <p>Retro green snake with 3D effect on black grid. Perfect for nostalgic gameplay!</p>
            </div>
            
            <div class="instruction-item">
              <h4>üü° Pac-Man</h4>
              <p><strong>Theme:</strong> Pac-Man</p>
              <p><strong>Skin:</strong> Pac-Man</p>
              <p>Yellow Pac-Man with animated mouth chomping through blue maze. Eat white pellets!</p>
            </div>
            
            <div class="instruction-item">
              <h4>üü© Game Boy</h4>
              <p><strong>Theme:</strong> Game Boy</p>
              <p><strong>Skin:</strong> Game Boy</p>
              <p>LCD-style green pixels with scanlines. Authentic handheld gaming experience!</p>
            </div>
            
            <div class="instruction-item">
              <h4>üíô Neon Grid</h4>
              <p><strong>Theme:</strong> Neon Grid</p>
              <p><strong>Skin:</strong> Neon Grid</p>
              <p>Glowing cyber snake with neon effects. Futuristic grid-based gameplay!</p>
            </div>
            
            <div class="instruction-item">
              <h4>üíú Arcade</h4>
              <p><strong>Theme:</strong> Arcade</p>
              <p><strong>Skin:</strong> Arcade</p>
              <p>Colorful gradient snake with glow effects. Classic arcade cabinet style!</p>
            </div>
            
            <div class="instruction-item">
              <h4>üåà Rainbow</h4>
              <p><strong>Works with any theme!</strong></p>
              <p>Animated rainbow colors that cycle continuously. Fun for any environment!</p>
            </div>
            
            <div class="instruction-item">
              <h4>‚òÄÔ∏è Daylight Snake</h4>
              <p><strong>Perfect for Day theme!</strong></p>
              <p>Warm, sunny colors that shift like sunlight throughout the day. Golden and amber tones!</p>
            </div>
            
            <div class="instruction-item">
              <h4>‚ú® Starlight Snake</h4>
              <p><strong>Perfect for Night theme!</strong></p>
              <p>Twinkling star-like effect with cool blue and purple night colors. Mesmerizing glow!</p>
            </div>
          </div>
        </div>

        <div class="instructions-section">
          <h2>‚ö° Power-ups</h2>
          <div class="instructions-grid">
            <div class="instruction-item">
              <h4>üçé Regular Food</h4>
              <p><strong>Points:</strong> 25</p>
              <p>Grows your snake by one segment. Appearance varies by theme (dots, squares, gems, etc.)</p>
            </div>
            
            <div class="instruction-item">
              <h4>‚≠ê 2x Points Power-up</h4>
              <p><strong>Points:</strong> 50 + 2x multiplier</p>
              <p><strong>Duration:</strong> 10 seconds</p>
              <p>Doubles all points for 10 seconds. Shows as large flashing items.</p>
            </div>
            
            <div class="instruction-item">
              <h4>‚ö° Speed Boost</h4>
              <p><strong>Points:</strong> 40</p>
              <p><strong>Effect:</strong> 1.25x speed for 8 seconds</p>
              <p>Makes you move 25% faster. Great for quick navigation!</p>
            </div>
          </div>
          
          <p><strong>Spawn Rates:</strong> Regular food (84%), 2x Points (8%), Speed Boost (8%)</p>
        </div>

        <div class="instructions-section">
          <h2>üèÜ Game Modes</h2>
          <div class="instructions-grid">
            <div class="instruction-item">
              <h4>Classic Mode</h4>
              <p>Traditional snake gameplay. Eat food, grow longer, avoid walls and yourself.</p>
            </div>
            
            <div class="instruction-item">
              <h4>Time Attack</h4>
              <p>Race against the clock! Score as many points as possible before time runs out.</p>
            </div>
            
            <div class="instruction-item">
              <h4>Hard Mode</h4>
              <p>Faster starting speed and more challenging gameplay for experienced players.</p>
            </div>
          </div>
        </div>

        <div class="instructions-section">
          <h2>üí° Pro Tips</h2>
          <div class="instruction-item">
            <h4>Strategy Tips</h4>
            <p>‚Ä¢ Plan your path ahead to avoid getting trapped</p>
            <p>‚Ä¢ Use walls to your advantage for tight turns</p>
            <p>‚Ä¢ Save speed boosts for when you need quick escapes</p>
            <p>‚Ä¢ 2x point multipliers stack with regular food eating</p>
            <p>‚Ä¢ Each theme offers a unique visual experience - try them all!</p>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="navbar">
    <div class="navbar-brand">
      <h2>üêç Pythonix</h2>
    </div>
    <div class="navbar-controls">
      <!-- Player Settings Group -->
      <div class="control-group">
        <div class="group-title">Player</div>
        <div class="control-row">
          <label>Name:
            <input type="text" id="playerName" placeholder="Enter name" maxlength="20">
          </label>
        </div>
      </div>

      <!-- Snake Customization Group -->
      <div class="control-group">
        <div class="group-title">Snake Style</div>
        <div class="control-row">
          <label>Shape:
            <select id="snakeShape">
              <option value="square">Square</option>
              <option value="emoji">Emoji</option>
            </select>
          </label>
          <span id="emojiPickerContainer" style="display:none;">
            <label>Emoji:
              <input type="text" id="emojiPicker" value="üêç" maxlength="4" placeholder="üêç" title="Type or paste any emoji here!">
            </label>
          </span>
          <label>Skin:
            <select id="snakeSkin">
              <option value="classic">Classic Snake</option>
              <option value="pacman">Pac-Man</option>
              <option value="gameboy">Game Boy</option>
              <option value="neon">Neon Grid</option>
              <option value="arcade">Arcade</option>
              <option value="rainbow">Rainbow (animated)</option>
              <option value="daylight">Daylight Snake</option>
              <option value="starlight">Starlight Snake</option>
            </select>
          </label>
        </div>
      </div>

      <!-- Game Settings Group -->
      <div class="control-group">
        <div class="group-title">Game Settings</div>
        <div class="control-row">
          <label>Mode:
            <select id="gameMode">
              <option value="classic">Classic</option>
              <option value="time">Time Attack</option>
              <option value="hard">Hard Mode</option>
            </select>
          </label>
          <label>Theme:
            <select id="themeSelect">
              <option value="auto">Day/Night (Auto)</option>
              <option value="day">Day</option>
              <option value="night">Night</option>
              <option value="classic">Classic Snake</option>
              <option value="pacman">Pac-Man Arcade</option>
              <option value="gameboy">Game Boy</option>
              <option value="neon">Neon Grid</option>
              <option value="arcade">Retro Arcade</option>
            </select>
          </label>
          <label>Volume:
            <input type="range" id="volumeSlider" min="0" max="100" value="50">
            <span id="volumeValue">50%</span>
          </label>
        </div>
      </div>

      <!-- Stats and Actions Group -->
      <div class="control-group">
        <div class="group-title">Stats & Actions</div>
        <div class="stats-row">
          <span class="stat-item" id="highScoreNav">High Score: 0</span>
          <span class="stat-item" id="foodsEatenNav">Foods Eaten: 0</span>
          <span class="stat-item" id="multiplierNav" style="display:none;">x2 (0s)</span>
          <label id="timeAttackDisplay" style="display:none;">Time:
            <span id="timeLeft">--</span>s
          </label>
        </div>
        <div class="action-buttons">
          <button id="showHistory" class="small-btn">History</button>
          <button id="showAchievements" class="small-btn">Achievements</button>
          <button id="clearGames" class="small-btn clear-btn">Clear Games</button>
        </div>
      </div>
    </div>
  </div>
  <div class="container">
    <div class="card">
      <h1>Pythonix</h1>
      <div class="score-board" id="scoreBoard">Score: 0</div>
      <div style="position:relative;">
  <canvas id="gameCanvas" width="480" height="480"></canvas>
        <div id="gameOverScreen" class="game-over" style="display:none;">
          <span id="gameOverText"></span>
          <button onclick="restartGame()">Restart</button>
        </div>
      </div>
      <div style="margin-top:18px;">
        <span style="color:#444;font-size:1em;">
          Use <b>WASD</b>, <b>arrow keys</b>, <b>swipe</b>, or <b>touch controls</b> to play
        </span>
      </div>
    </div>
  </div>
  <!-- Achievements Modal -->
<div id="achievementsModal" class="modal" style="display: none;">
  <div class="modal-content">
    <span class="close" onclick="document.getElementById('achievementsModal').style.display='none'">&times;</span>
    <h2>üèÜ Achievements</h2>
    <div id="achievementsContent">Loading achievements...</div>
  </div>
</div>

<!-- Game History Modal -->
<div id="historyModal" class="modal" style="display: none;">
  <div class="modal-content">
    <span class="close" onclick="document.getElementById('historyModal').style.display='none'">&times;</span>
    <h2>üìà Game History</h2>
    <div id="historyContent">Loading history...</div>
  </div>
</div>

<!-- Add modal CSS -->
<style>
.modal {
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.8);
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal-content {
  background: linear-gradient(135deg, #1a1a2e, #16213e);
  margin: auto;
  padding: 30px;
  border-radius: 15px;
  width: 80%;
  max-width: 800px;
  max-height: 80vh;
  overflow-y: auto;
  color: #fff;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
}

.close {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
  line-height: 1;
}

.close:hover {
  color: #fff;
}

.achievements-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 15px;
  margin-top: 20px;
}

.achievement {
  display: flex;
  align-items: center;
  padding: 15px;
  border-radius: 10px;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.1);
}

.achievement.unlocked {
  background: rgba(76, 175, 80, 0.2);
  border-color: rgba(76, 175, 80, 0.3);
}

.achievement.locked {
  opacity: 0.6;
}

.achievement-icon {
  font-size: 2rem;
  margin-right: 15px;
}

.achievement-info h4 {
  margin: 0 0 5px 0;
  color: #fff;
}

.achievement-info p {
  margin: 0;
  color: #ccc;
  font-size: 0.9rem;
}

.stats-overview {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
  margin: 20px 0;
}

.stat-item {
  padding: 15px;
  background: rgba(255,255,255,0.05);
  border-radius: 8px;
  text-align: center;
  color: #fff;
}

.history-list {
  max-height: 400px;
  overflow-y: auto;
}

.history-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 15px;
  margin: 10px 0;
  background: rgba(255,255,255,0.03);
  border-radius: 8px;
  border-left: 4px solid #4CAF50;
}

.game-info {
  display: flex;
  gap: 20px;
}

.game-score {
  font-weight: bold;
  color: #4CAF50;
}

.game-foods {
  color: #2196F3;
}

.game-mode {
  color: #FF9800;
}

.game-date {
  color: #ccc;
  font-size: 0.9rem;
}
</style>

<script>
function handleMenuAction() {
  constructor() {
    this.currentUser = null;
    this.authToken = localStorage.getItem('pythonixToken');
    this.isAuthMode = false; // false = login, true = register
    this.init();
  }
  
  async init() {
    if (this.authToken) {
      try {
        const response = await fetch('/auth/profile', {
          headers: { 'Authorization': `Bearer ${this.authToken}` }
        });
        
        if (response.ok) {
          this.currentUser = await response.json();
          this.updateUserStatus();
        } else {
          localStorage.removeItem('pythonixToken');
          this.authToken = null;
        }
      } catch (error) {
        console.log('Auth check failed:', error);
      }
    }
  }
  
  updateUserStatus() {
    const userStatus = document.getElementById('userStatus');
    const accountText = document.getElementById('accountText');
    
    if (userStatus && this.currentUser) {
      userStatus.innerHTML = `Welcome, ${this.currentUser.displayName}${this.currentUser.isGuest ? ' (Guest)' : ''}`;
    } else if (userStatus) {
      userStatus.innerHTML = '';
    }
    
    if (accountText) {
      if (this.currentUser) {
        accountText.textContent = this.currentUser.isGuest ? 'UPGRADE ACCOUNT' : 'PROFILE';
      } else {
        accountText.textContent = 'LOGIN/SIGNUP';
      }
    }
  }
  
  async login(username, password) {
    try {
      console.log('Attempting login to:', window.location.origin + '/auth/login');
      const response = await fetch('/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password })
      });
      
      const data = await response.json();
      
      if (response.ok) {
        this.authToken = data.token;
        this.currentUser = data.user;
        localStorage.setItem('pythonixToken', this.authToken);
        this.updateUserStatus();
        closeAuthModal();
        showNotification('Login successful!', 'success');
        return true;
      } else {
        showNotification(data.error || 'Login failed', 'error');
        return false;
      }
    } catch (error) {
      console.error('Login error:', error);
      console.log('Current URL:', window.location.href);
      showNotification('Connection error', 'error');
      return false;
    }
  }
  
  async register(username, email, password, displayName) {
    try {
      console.log('Attempting registration to:', window.location.origin + '/auth/register');
      const response = await fetch('/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, email, password, displayName })
      });
      
      const data = await response.json();
      
      if (response.ok) {
        this.authToken = data.token;
        this.currentUser = data.user;
        localStorage.setItem('pythonixToken', this.authToken);
        this.updateUserStatus();
        closeAuthModal();
        showNotification('Account created successfully!', 'success');
        return true;
      } else {
        showNotification(data.error || 'Registration failed', 'error');
        return false;
      }
    } catch (error) {
      console.error('Registration error:', error);
      console.log('Current URL:', window.location.href);
      showNotification('Connection error', 'error');
      return false;
    }
  }
  
  async createGuest() {
    try {
      const response = await fetch('/auth/guest', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });
      
      const data = await response.json();
      
      if (response.ok) {
        this.authToken = data.token;
        this.currentUser = data.user;
        localStorage.setItem('pythonixToken', this.authToken);
        this.updateUserStatus();
        closeAuthModal();
        showNotification('Playing as guest!', 'info');
        return true;
      } else {
        showNotification('Failed to create guest account', 'error');
        return false;
      }
    } catch (error) {
      showNotification('Connection error', 'error');
      return false;
    }
  }
  
  logout() {
    this.currentUser = null;
    this.authToken = null;
    localStorage.removeItem('pythonixToken');
    this.updateUserStatus();
    showNotification('Logged out successfully', 'info');
  }
  
  getAuthHeaders() {
    return this.authToken ? { 'Authorization': `Bearer ${this.authToken}` } : {};
  }
}

// Leaderboard Management
class LeaderboardManager {
  constructor() {
    this.currentMode = 'classic';
    this.leaderboardData = {};
  }
  
  async loadLeaderboard(gameMode = 'classic') {
    try {
      const headers = authManager.getAuthHeaders();
      const response = await fetch(`/leaderboard/global?mode=${gameMode}&limit=50`, {
        headers
      });
      
      if (response.ok) {
        const data = await response.json();
        this.leaderboardData[gameMode] = data;
        this.displayLeaderboard(data);
      } else {
        showNotification('Failed to load leaderboard', 'error');
      }
    } catch (error) {
      showNotification('Connection error', 'error');
    }
  }
  
  displayLeaderboard(data) {
    const content = document.getElementById('leaderboardContent');
    const userRankInfo = document.getElementById('userRankInfo');
    
    // Show user rank if available
    if (data.userRank && authManager.currentUser) {
      document.getElementById('userRank').textContent = `#${data.userRank}`;
      userRankInfo.style.display = 'block';
    } else {
      userRankInfo.style.display = 'none';
    }
    
    if (!data.leaderboard || data.leaderboard.length === 0) {
      content.innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.7); padding: 40px;">No scores yet. Be the first!</div>';
      return;
    }
    
    content.innerHTML = data.leaderboard.map((player, index) => {
      let rankClass = '';
      if (index === 0) rankClass = 'gold';
      else if (index === 1) rankClass = 'silver';
      else if (index === 2) rankClass = 'bronze';
      
      const isCurrentUser = authManager.currentUser && player.username === authManager.currentUser.username;
      
      return `
        <div class="leaderboard-item" style="${isCurrentUser ? 'border-color: #FFD700; background: rgba(255,215,0,0.1);' : ''}">
          <div class="leaderboard-rank ${rankClass}">#${index + 1}</div>
          <div class="leaderboard-info">
            <div class="leaderboard-name">
              ${player.displayName} ${isCurrentUser ? '(You)' : ''}
              ${player.isGuest ? '<span style="color: #888; font-size: 0.8em;">(Guest)</span>' : ''}
            </div>
            <div class="leaderboard-stats">
              ${player.gamesPlayed || 0} games ‚Ä¢ ${player.totalFoodsEaten || 0} foods eaten
            </div>
          </div>
          <div class="leaderboard-score">${player.highScore.toLocaleString()}</div>
        </div>
      `;
    }).join('');
  }
  
  async submitScore(score, gameMode, gameData) {
    try {
      const headers = {
        'Content-Type': 'application/json',
        ...authManager.getAuthHeaders()
      };
      
      const response = await fetch('/scores', {
        method: 'POST',
        headers,
        body: JSON.stringify({
          score,
          gameMode,
          snakeSkin: gameData.snakeSkin || 'classic',
          theme: gameData.theme || 'auto',
          gameDuration: gameData.duration || 0,
          foodsEaten: gameData.foodsEaten || 0
        })
      });
      
      if (response.ok) {
        return true;
      } else {
        console.error('Failed to submit score');
        return false;
      }
    } catch (error) {
      console.error('Error submitting score:', error);
      return false;
    }
  }
}

// Notification System
function showNotification(message, type = 'info') {
  const notification = document.createElement('div');
  notification.className = `notification ${type}`;
  notification.innerHTML = message;
  
  // Add notification styles if not already present
  if (!document.querySelector('#notification-styles')) {
    const style = document.createElement('style');
    style.id = 'notification-styles';
    style.textContent = `
      .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 15px 20px;
        border-radius: 10px;
        color: white;
        font-weight: bold;
        z-index: 3000;
        opacity: 0;
        transform: translateX(100%);
        transition: all 0.3s ease;
      }
      .notification.success { background: linear-gradient(135deg, #4CAF50, #45a049); }
      .notification.error { background: linear-gradient(135deg, #f44336, #da190b); }
      .notification.info { background: linear-gradient(135deg, #2196F3, #0b7dda); }
      .notification.show { opacity: 1; transform: translateX(0); }
    `;
    document.head.appendChild(style);
  }
  
  document.body.appendChild(notification);
  
  setTimeout(() => notification.classList.add('show'), 100);
  setTimeout(() => {
    notification.classList.remove('show');
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

// Initialize managers
const authManager = new AuthManager();
const leaderboardManager = new LeaderboardManager();

// Authentication Modal Functions
function openAuthModal() {
  console.log('Opening auth modal');
  const modal = document.getElementById('authModal');
  if (modal) {
    modal.style.display = 'flex';
    if (authManager.currentUser && authManager.currentUser.isGuest) {
      // Show upgrade options for guest users
      toggleAuthMode(true); // Switch to register mode
    }
  } else {
    console.error('Auth modal not found');
  }
}

function closeAuthModal() {
  document.getElementById('authModal').style.display = 'none';
  resetAuthForm();
}

function toggleAuthMode(forceRegister = false) {
  authManager.isAuthMode = forceRegister || !authManager.isAuthMode;
  
  const title = document.getElementById('authTitle');
  const email = document.getElementById('authEmail');
  const displayName = document.getElementById('authDisplayName');
  const submit = document.getElementById('authSubmit');
  const switchText = document.getElementById('authSwitchText');
  const switchLink = document.getElementById('authSwitchLink');
  
  if (authManager.isAuthMode) {
    title.textContent = 'Create Account';
    email.style.display = 'block';
    displayName.style.display = 'block';
    submit.textContent = 'Sign Up';
    switchText.textContent = 'Already have an account?';
    switchLink.textContent = 'Login';
  } else {
    title.textContent = 'Login to Pythonix';
    email.style.display = 'none';
    displayName.style.display = 'none';
    submit.textContent = 'Login';
    switchText.textContent = "Don't have an account?";
    switchLink.textContent = 'Sign up';
  }
}

function resetAuthForm() {
  document.getElementById('authForm').reset();
  authManager.isAuthMode = false;
  toggleAuthMode();
}

async function playAsGuest() {
  await authManager.createGuest();
}

// Leaderboard Modal Functions
function openLeaderboardModal() {
  console.log('Opening leaderboard modal');
  const modal = document.getElementById('leaderboardModal');
  if (modal) {
    modal.style.display = 'flex';
    leaderboardManager.loadLeaderboard(leaderboardManager.currentMode);
  } else {
    console.error('Leaderboard modal not found');
  }
}

function closeLeaderboardModal() {
  document.getElementById('leaderboardModal').style.display = 'none';
}

function switchLeaderboardTab(mode) {
  // Update tab appearance
  document.querySelectorAll('.leaderboard-tab').forEach(tab => {
    tab.classList.remove('active');
  });
  event.target.classList.add('active');
  
  leaderboardManager.currentMode = mode;
  leaderboardManager.loadLeaderboard(mode);
}

// Enhanced menu navigation with new options

function updateMenuSelection() {
  menuItems.forEach((id, index) => {
    const element = document.getElementById(id);
    if (index === currentMenuIndex) {
      element.classList.add('active');
    } else {
      element.classList.remove('active');
    }
  });
}

function handleMenuAction() {
  const selectedItem = menuItems[currentMenuIndex];
  
  switch(selectedItem) {
    case 'startOption':
      startGame();
      break;
    case 'instructionsOption':
      toggleInstructions();
      break;
    case 'leaderboardOption':
      openLeaderboardModal();
      break;
    case 'accountOption':
      if (authManager.currentUser) {
        if (authManager.currentUser.isGuest) {
          openAuthModal(); // Show upgrade options
        } else {
          // Show profile or logout option
          if (confirm('Do you want to logout?')) {
            authManager.logout();
          }
        }
      } else {
        openAuthModal();
      }
      break;
  }
}

// Event Listeners
document.getElementById('authForm').addEventListener('submit', async (e) => {
  e.preventDefault();
  
  const username = document.getElementById('authUsername').value.trim();
  const email = document.getElementById('authEmail').value.trim();
  const displayName = document.getElementById('authDisplayName').value.trim();
  const password = document.getElementById('authPassword').value;
  
  if (authManager.isAuthMode) {
    await authManager.register(username, email, password, displayName);
  } else {
    await authManager.login(username, password);
  }
});

// Global game variables
let canvas, ctx, boxSize = 40, boardWidth, boardHeight;
let snake, direction, food, score = 0, foodsEaten = 0;
let gameInterval, isGameOver = false, isPaused = false;
let speed = 150, baseSpeed = 150;
let obstacles = [];
let gameMode = 'classic';
let snakeShape = 'square';
let snakeEmoji = 'üêç';
let snakeSkin = 'classic';
let multiplierActive = false;
let multiplierInterval, speedInterval, multiplierExpireTime;
let gameTimeLeft = 60, gameTimeInterval;
let multiplierTimeLeft = 0, speedTimeLeft = 0;
let gameStartTime = null;

// Sound effects
const eatSound = new Audio('eat.mp3');
eatSound.volume = 0.5;
const powerSound = new Audio('powerup.mp3');
powerSound.volume = 0.5;
const gameOverSound = new Audio('gameover.mp3');
gameOverSound.volume = 0.5;

// Menu sounds
const backgroundMusic = new Audio('menu.wav');
backgroundMusic.volume = 0.3;
backgroundMusic.loop = true;

const buttonHoverSound = new Audio('hover.wav');
buttonHoverSound.volume = 0.4;

const buttonClickSound = new Audio('click.wav');
buttonClickSound.volume = 0.5;

const menuSelectSound = new Audio('powerup.mp3'); // Reuse powerup sound for selections
menuSelectSound.volume = 0.4;

// Volume control functionality
function updateVolume(value) {
  const volume = value / 100;
  eatSound.volume = volume;
  powerSound.volume = volume;
  gameOverSound.volume = volume;
  
  // Menu sounds - slightly lower volumes for better balance
  backgroundMusic.volume = volume * 0.6; // 60% of main volume
  buttonHoverSound.volume = volume * 0.8; // 80% of main volume  
  buttonClickSound.volume = volume;
  menuSelectSound.volume = volume * 0.8; // 80% of main volume
  
  // Update game.js sounds if available
  if (window.updateGameJsVolume) {
    window.updateGameJsVolume(volume);
  }
  
  document.getElementById('volumeValue').textContent = value + '%';
  localStorage.setItem('pythonixVolume', value);
}

// Menu sound functions
function playBackgroundMusic() {
  try {
    backgroundMusic.currentTime = 0;
    backgroundMusic.play().catch(e => {
      console.log('Background music autoplay prevented:', e);
    });
  } catch (e) {
    console.log('Could not play background music:', e);
  }
}

function stopBackgroundMusic() {
  try {
    backgroundMusic.pause();
    backgroundMusic.currentTime = 0;
  } catch (e) {
    console.log('Could not stop background music:', e);
  }
}

function playButtonHover() {
  try {
    buttonHoverSound.currentTime = 0;
    buttonHoverSound.play().catch(e => console.log('Button hover sound failed:', e));
  } catch (e) {
    console.log('Could not play button hover sound:', e);
  }
}

function playButtonClick() {
  try {
    buttonClickSound.currentTime = 0;
    buttonClickSound.play().catch(e => console.log('Button click sound failed:', e));
  } catch (e) {
    console.log('Could not play button click sound:', e);
  }
}

function playMenuSelect() {
  try {
    menuSelectSound.currentTime = 0;
    menuSelectSound.play().catch(e => console.log('Menu select sound failed:', e));
  } catch (e) {
    console.log('Could not play menu select sound:', e);
  }
}

// Function to add sound effects to any button or interactive element
function addSoundEffectsToElement(element) {
  if (!element) return;
  
  // Add hover sound
  element.addEventListener('mouseenter', playButtonHover);
  
  // Add click sound to existing click handler
  const originalClick = element.onclick;
  element.onclick = function(event) {
    playButtonClick();
    if (originalClick) {
      return originalClick.call(this, event);
    }
  };
}

// Function to add sound effects to all interactive elements site-wide
function addSoundEffectsToSite() {
  // Add sounds to all buttons
  const buttons = document.querySelectorAll('button');
  buttons.forEach(addSoundEffectsToElement);
  
  // Add sounds to all selects
  const selects = document.querySelectorAll('select');
  selects.forEach(select => {
    select.addEventListener('mouseenter', playButtonHover);
    select.addEventListener('change', playButtonClick);
  });
  
  // Add sounds to all input sliders
  const sliders = document.querySelectorAll('input[type="range"]');
  sliders.forEach(slider => {
    slider.addEventListener('mouseenter', playButtonHover);
    slider.addEventListener('input', () => {
      // Play a quieter click for slider movement
      try {
        const clickCopy = buttonClickSound.cloneNode();
        clickCopy.volume = buttonClickSound.volume * 0.3; // Much quieter for sliders
        clickCopy.play().catch(e => console.log('Slider sound failed:', e));
      } catch (e) {
        console.log('Could not play slider sound:', e);
      }
    });
  });
  
  // Add sounds to clickable elements with onclick
  const clickableElements = document.querySelectorAll('[onclick]');
  clickableElements.forEach(addSoundEffectsToElement);
}

// Initialize volume from localStorage or default to 50%
const savedVolume = localStorage.getItem('pythonixVolume') || 50;
document.addEventListener('DOMContentLoaded', function() {
  const volumeSlider = document.getElementById('volumeSlider');
  volumeSlider.value = savedVolume;
  updateVolume(savedVolume);
  
  volumeSlider.addEventListener('input', function() {
    updateVolume(this.value);
  });
  
  // Add sound effects to all interactive elements site-wide
  addSoundEffectsToSite();
  
  // Only start background music on start menu (check if intro screen is visible)
  setTimeout(() => {
    const introScreen = document.getElementById('introScreen');
    if (introScreen && introScreen.style.display !== 'none') {
      playBackgroundMusic();
    }
  }, 1000); // Small delay to ensure page is fully loaded
});

// Initialize canvas and board dimensions
function resizeCanvas() {
  canvas = document.getElementById('gameCanvas');
  if (!canvas) return;
  
  ctx = canvas.getContext('2d');
  
  // Add roundRect polyfill for older browsers
  if (!ctx.roundRect) {
    ctx.roundRect = function(x, y, width, height, radius) {
      this.beginPath();
      this.moveTo(x + radius, y);
      this.lineTo(x + width - radius, y);
      this.quadraticCurveTo(x + width, y, x + width, y + radius);
      this.lineTo(x + width, y + height - radius);
      this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      this.lineTo(x + radius, y + height);
      this.quadraticCurveTo(x, y + height, x, y + height - radius);
      this.lineTo(x, y + radius);
      this.quadraticCurveTo(x, y, x + radius, y);
      this.closePath();
    };
  }
  
  // Make board square - 600x600 pixels
  canvas.width = 600;
  canvas.height = 600;
  boardWidth = canvas.width / boxSize;
  boardHeight = canvas.height / boxSize;
}

// Generate random food
function randomFood() {
  let pos;
  do {
    pos = {
      x: Math.floor(Math.random() * boardWidth),
      y: Math.floor(Math.random() * boardHeight),
      type: 'normal'
    };
  } while (snake && snake.some(s => s.x === pos.x && s.y === pos.y));
  
  // Random food types - increased powerup spawn rates
  const rand = Math.random();
  if (rand < 0.08) pos.type = 'power_double';  // 8% chance (was 5%)
  else if (rand < 0.16) pos.type = 'power_speed';  // 8% chance (was 5%)
  
  return pos;
}

// Check if direction change is valid (no 180 degree turns)
function isValidDirection(newDirection, currentDirection) {
  const opposites = {
    'UP': 'DOWN',
    'DOWN': 'UP', 
    'LEFT': 'RIGHT',
    'RIGHT': 'LEFT'
  };
  return opposites[currentDirection] !== newDirection;
}

// Add the actual working functions for achievements and history
function showAchievements() {
  console.log('Loading achievements...');
  const modal = document.getElementById('achievementsModal');
  if (modal) {
    modal.style.display = 'flex';
    loadAchievements();
  } else {
    console.error('Achievements modal not found');
  }
}

function showGameHistory() {
  console.log('Loading game history...');
  const modal = document.getElementById('historyModal');
  if (modal) {
    modal.style.display = 'flex';
    loadGameHistory();
  } else {
    console.error('History modal not found');
  }
}

function clearAllGameData() {
  const confirmed = confirm('‚ö†Ô∏è This will permanently delete ALL your game data including:\\n\\n‚Ä¢ High Score\\n‚Ä¢ Game History\\n‚Ä¢ Statistics\\n‚Ä¢ Achievement Progress\\n\\nThis action cannot be undone! Are you sure?');
  
  if (confirmed) {
    const doubleConfirm = confirm('üö® FINAL WARNING! üö®\\n\\nYou will lose EVERYTHING:\\n‚Ä¢ Your high score of ' + (localStorage.getItem('pythonixHighScore') || '0') + ' points\\n‚Ä¢ All game statistics\\n‚Ä¢ All unlocked achievements\\n\\nType YES in the next prompt to confirm deletion.');
    
    if (doubleConfirm) {
      const finalConfirm = prompt('Type "DELETE ALL DATA" to confirm (case sensitive):');
      
      if (finalConfirm === 'DELETE ALL DATA') {
        // Clear all game data
        localStorage.removeItem('pythonixHighScore');
        localStorage.removeItem('pythonixStats');
        localStorage.removeItem('pythonixGameHistory');
        localStorage.removeItem('pythonixAchievements');
        localStorage.removeItem('pythonixRuns');
        
        alert('‚úÖ All game data has been deleted. The page will refresh.');
        window.location.reload();
      } else {
        alert('‚ùå Deletion cancelled - incorrect confirmation text.');
      }
    } else {
      alert('‚ùå Deletion cancelled by user.');
    }
  }
}

function loadAchievements() {
  const achievementsContent = document.getElementById('achievementsContent');
  if (!achievementsContent) {
    console.error('Achievements content element not found');
    return;
  }
  
  // Get current stats
  const highScore = parseInt(localStorage.getItem('pythonixHighScore') || '0');
  const stats = JSON.parse(localStorage.getItem('pythonixStats') || '{"gamesPlayed": 0, "totalFoodsEaten": 0}');
  
  console.log('Current stats:', stats, 'High score:', highScore);
  
  const achievements = [
    // Beginner achievements
    { id: 'first_game', name: 'First Steps', description: 'Play your first game', unlocked: stats.gamesPlayed >= 1, icon: 'üë∂' },
    { id: 'score_50', name: 'Getting Started', description: 'Score 50 points', unlocked: highScore >= 50, icon: 'üå±' },
    { id: 'score_100', name: 'Century Club', description: 'Score 100 points', unlocked: highScore >= 100, icon: 'üíØ' },
    
    // Intermediate achievements  
    { id: 'score_250', name: 'Quarter Master', description: 'Score 250 points', unlocked: highScore >= 250, icon: 'üéØ' },
    { id: 'score_500', name: 'High Roller', description: 'Score 500 points', unlocked: highScore >= 500, icon: 'üé∞' },
    { id: 'games_5', name: 'Persistent', description: 'Play 5 games', unlocked: stats.gamesPlayed >= 5, icon: 'üî•' },
    { id: 'games_10', name: 'Dedicated', description: 'Play 10 games', unlocked: stats.gamesPlayed >= 10, icon: 'üí™' },
    { id: 'foods_100', name: 'Hungry Snake', description: 'Eat 100 total foods', unlocked: stats.totalFoodsEaten >= 100, icon: 'üçé' },
    
    // Hard achievements
    { id: 'score_1000', name: 'Millennium', description: 'Score 1,000 points', unlocked: highScore >= 1000, icon: 'üöÄ' },
    { id: 'score_2500', name: 'Elite Player', description: 'Score 2,500 points', unlocked: highScore >= 2500, icon: 'üëë' },
    { id: 'score_5000', name: 'Snake Master', description: 'Score 5,000 points', unlocked: highScore >= 5000, icon: 'üêç' },
    { id: 'games_25', name: 'Addicted', description: 'Play 25 games', unlocked: stats.gamesPlayed >= 25, icon: 'üéÆ' },
    { id: 'games_50', name: 'No Life', description: 'Play 50 games', unlocked: stats.gamesPlayed >= 50, icon: 'üòÖ' },
    { id: 'foods_500', name: 'Glutton', description: 'Eat 500 total foods', unlocked: stats.totalFoodsEaten >= 500, icon: 'üç¥' },
    
    // Expert achievements 
    { id: 'score_10000', name: 'Legend', description: 'Score 10,000 points', unlocked: highScore >= 10000, icon: '‚ö°' },
    { id: 'score_12500', name: 'Snake Virtuoso', description: 'Score 12,500 points', unlocked: highScore >= 12500, icon: 'üéØ' },
    { id: 'games_100', name: 'Obsessed', description: 'Play 100 games', unlocked: stats.gamesPlayed >= 100, icon: 'ü§Ø' },
    { id: 'foods_1000', name: 'Food Vacuum', description: 'Eat 1,000 total foods', unlocked: stats.totalFoodsEaten >= 1000, icon: 'üå™Ô∏è' },
    
    // Ultimate achievements
    { id: 'score_15000', name: 'Untouchable', description: 'Score 15,000 points', unlocked: highScore >= 15000, icon: 'üíé' },
    { id: 'score_20000', name: 'Snake God', description: 'Score 20,000 points (legendary!)', unlocked: highScore >= 20000, icon: 'üëë' },
    { id: 'games_250', name: 'Intervention Needed', description: 'Play 250 games', unlocked: stats.gamesPlayed >= 250, icon: 'üò±' },
    { id: 'foods_2500', name: 'Bottomless Pit', description: 'Eat 2,500 total foods', unlocked: stats.totalFoodsEaten >= 2500, icon: 'üï≥Ô∏è' },
    
    // Special achievements
    { id: 'high_scorer', name: 'High Scorer', description: 'Achieve a score higher than 750 points', unlocked: highScore >= 750, icon: '‚≠ê' },
    { id: 'food_chain', name: 'Food Chain', description: 'Eat 50 foods in a single game', unlocked: highScore >= 500, icon: 'üîó' },
    { id: 'marathon_player', name: 'Marathon Player', description: 'Play 15 games in a row', unlocked: stats.gamesPlayed >= 15, icon: 'üèÉ' },
    { id: 'consistent', name: 'Consistent', description: 'Score over 200 points (achievable multiple times)', unlocked: highScore >= 200, icon: 'üéØ' },
    { id: 'explorer', name: 'Explorer', description: 'Try different game modes (play any game)', unlocked: stats.gamesPlayed >= 1, icon: 'üó∫Ô∏è' },
    { id: 'veteran', name: 'Veteran', description: 'Reach a high score of 1500+ points', unlocked: highScore >= 1500, icon: 'üéñÔ∏è' }
  ];
  
  let html = '<div class="achievements-grid">';
  
  achievements.forEach(achievement => {
    html += `
      <div class="achievement ${achievement.unlocked ? 'unlocked' : 'locked'}">
        <div class="achievement-icon">${achievement.unlocked ? (achievement.icon || 'üèÜ') : 'üîí'}</div>
        <div class="achievement-info">
          <h4>${achievement.name}</h4>
          <p>${achievement.description}</p>
        </div>
      </div>
    `;
  });
  
  html += '</div>';
  achievementsContent.innerHTML = html;
}

function loadGameHistory() {
  const historyContent = document.getElementById('historyContent');
  if (!historyContent) {
    console.error('History content element not found');
    return;
  }
  
  const stats = JSON.parse(localStorage.getItem('pythonixStats') || '{"gamesPlayed": 0, "totalFoodsEaten": 0}');
  const gameHistory = JSON.parse(localStorage.getItem('pythonixGameHistory') || '[]');
  const highScore = parseInt(localStorage.getItem('pythonixHighScore') || '0');
  
  console.log('Loading history - Stats:', stats, 'History:', gameHistory, 'High score:', highScore);
  
  let html = '<div class="stats-overview">';
  html += `<div class="stat-item"><strong>Games Played:</strong> ${stats.gamesPlayed}</div>`;
  html += `<div class="stat-item"><strong>High Score:</strong> ${highScore}</div>`;
  html += `<div class="stat-item"><strong>Total Foods:</strong> ${stats.totalFoodsEaten}</div>`;
  html += `<div class="stat-item"><strong>Avg Score:</strong> ${stats.gamesPlayed > 0 ? Math.round((stats.totalScore || 0) / stats.gamesPlayed) : 0}</div>`;
  html += '</div>';
  
  html += '<h3>Recent Games</h3>';
  
  if (gameHistory.length === 0) {
    html += '<p>No games recorded yet. Play some games to see your history!</p>';
    html += '<p><em>Note: Your current high score of ' + highScore + ' shows you have played before, but detailed history wasn\'t being saved.</em></p>';
  } else {
    html += '<div class="history-list">';
    gameHistory.slice(-10).reverse().forEach(game => {
      const date = new Date(game.date).toLocaleDateString() + ' ' + new Date(game.date).toLocaleTimeString();
      html += `
        <div class="history-item">
          <div class="game-info">
            <span class="game-score">Score: ${game.score}</span>
            <span class="game-foods">Foods: ${game.foodsEaten || 0}</span>
            <span class="game-mode">${game.mode || 'Classic'}</span>
          </div>
          <div class="game-date">${date}</div>
        </div>
      `;
    });
    html += '</div>';
  }
  
  historyContent.innerHTML = html;
}

// Core game functions
function gameLoop() {
  if (isGameOver) return;
  
  // Handle pending direction change
  if (window.pendingDirection && isValidDirection(window.pendingDirection, direction)) {
    console.log('Changing direction from', direction, 'to', window.pendingDirection);
    direction = window.pendingDirection;
    window.direction = direction; // Keep window.direction in sync
    window.pendingDirection = null;
  }
  
  // Move snake head
  let head = { x: snake[0].x, y: snake[0].y };
  
  switch (direction) {
    case 'LEFT': head.x--; break;
    case 'RIGHT': head.x++; break;
    case 'UP': head.y--; break;
    case 'DOWN': head.y++; break;
  }
  
  // Handle wall wrapping
  if (head.x < 0) head.x = boardWidth - 1;
  if (head.x >= boardWidth) head.x = 0;
  if (head.y < 0) head.y = boardHeight - 1;
  if (head.y >= boardHeight) head.y = 0;
  
  if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
    endGame(); return;
  }
  
  snake.unshift(head);
  
  // Check food collision
  if (food && head.x === food.x && head.y === food.y) {
    handleFoodEaten();
  } else {
    snake.pop();
  }
  
  // Update score display continuously
  const scoreBoard = document.getElementById('scoreBoard');
  if (scoreBoard) scoreBoard.textContent = 'Score: ' + score;
  
  drawBoard();
}

function drawBoard() {
  if (!canvas || !ctx) return;
  if (!boardWidth || !boardHeight) resizeCanvas();

  // Get theme-specific colors
  const currentTheme = document.body.className;
  const rootStyles = getComputedStyle(document.body);
  
  // Background - use theme board background or default
  const bg = rootStyles.getPropertyValue('--board-bg').trim() || "#f7fffe";
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Grid - theme-specific grid colors
  let colorA, colorB, borderColor;
  
  if (currentTheme.includes('theme-classic')) {
    // Classic Snake - simple green grid
    colorA = "#001100";
    colorB = "#002200";
    borderColor = "#00ff00";
  } else if (currentTheme.includes('theme-pacman')) {
    // Pac-Man - blue maze-like grid
    colorA = "#000040";
    colorB = "#000060";
    borderColor = "#0000ff";
  } else if (currentTheme.includes('theme-gameboy')) {
    // Game Boy - LCD green tones
    colorA = "#9bbc0f";
    colorB = "#8bac0f";
    borderColor = "#306230";
  } else if (currentTheme.includes('theme-neon')) {
    // Neon - dark with cyan grid
    colorA = "#001122";
    colorB = "#002233";
    borderColor = "#00ffff";
  } else if (currentTheme.includes('theme-arcade')) {
    // Arcade - dark purple with gold borders
    colorA = "#1a0a2e";
    colorB = "#2d1b4e";
    borderColor = "#ffd700";
  } else if (currentTheme.includes('theme-day')) {
    // Day theme - bright, sunny colors with sky blue accents
    colorA = "#e6f3ff";
    colorB = "#d1e9ff";
    borderColor = "#87ceeb";
  } else if (currentTheme.includes('theme-night')) {
    // Night theme - dark with starry accents
    colorA = "#0a1428";
    colorB = "#142545";
    borderColor = "#4169e1";
  } else {
    // Default theme
    colorA = "#A8DBA8";
    colorB = "#8CCF7E";
    borderColor = "#6c7a89";
  }
  
  for (let y = 0; y < boardHeight; y++) {
    for (let x = 0; x < boardWidth; x++) {
      // Base grid pattern
      ctx.fillStyle = ((x + y) % 2 === 0) ? colorA : colorB;
      ctx.fillRect(x * boxSize, y * boxSize, boxSize, boxSize);
      
      // Theme-specific grid effects
      if (currentTheme.includes('theme-neon')) {
        // Add subtle glow to borders
        ctx.shadowColor = borderColor;
        ctx.shadowBlur = 2;
      } else if (currentTheme.includes('theme-gameboy')) {
        // Add scanline effect every few rows
        if (y % 3 === 0) {
          ctx.fillStyle = 'rgba(48, 98, 48, 0.1)';
          ctx.fillRect(x * boxSize, y * boxSize, boxSize, 1);
        }
      } else if (currentTheme.includes('theme-pacman')) {
        // Add maze-like appearance with thicker walls at edges
        if (x === 0 || x === boardWidth - 1 || y === 0 || y === boardHeight - 1) {
          ctx.fillStyle = '#000080';
          ctx.fillRect(x * boxSize, y * boxSize, boxSize, boxSize);
        }
        // Add occasional wall blocks for maze effect
        if ((x + y) % 7 === 0 && x > 1 && x < boardWidth - 2 && y > 1 && y < boardHeight - 2) {
          ctx.fillStyle = '#000080';
          ctx.fillRect(x * boxSize, y * boxSize, boxSize, boxSize);
        }
      } else if (currentTheme.includes('theme-classic')) {
        // Simple clean look - no special effects
      } else if (currentTheme.includes('theme-day')) {
        // Day theme - add subtle sunlight effect
        if ((x + y) % 8 === 0) {
          const sunlight = ctx.createRadialGradient(
            x * boxSize + boxSize/2, y * boxSize + boxSize/2, 0,
            x * boxSize + boxSize/2, y * boxSize + boxSize/2, boxSize
          );
          sunlight.addColorStop(0, 'rgba(255, 215, 0, 0.1)');
          sunlight.addColorStop(1, 'transparent');
          ctx.fillStyle = sunlight;
          ctx.fillRect(x * boxSize, y * boxSize, boxSize, boxSize);
        }
      } else if (currentTheme.includes('theme-night')) {
        // Night theme - add twinkling star effect
        if ((x * 3 + y * 5) % 13 === 0) {
          const twinkle = Math.sin(performance.now() / 1000 + x + y) * 0.5 + 0.5;
          ctx.fillStyle = `rgba(135, 206, 235, ${twinkle * 0.3})`;
          ctx.fillRect(x * boxSize + boxSize/3, y * boxSize + boxSize/3, boxSize/3, boxSize/3);
        }
      }
      
      // Draw border
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = currentTheme.includes('theme-arcade') ? 2 : 1;
      ctx.strokeRect(x * boxSize, y * boxSize, boxSize, boxSize);
      
      // Reset shadow
      ctx.shadowBlur = 0;
    }
  }

  // Draw snake
  if (Array.isArray(snake) && snake.length > 0) {
    if (snakeShape === 'emoji') {
      snake.forEach((segment, i) => {
        if (!segment) return;
        const cx = (segment.x + 0.5) * boxSize;
        const cy = (segment.y + 0.5) * boxSize;
        ctx.font = `${Math.floor(boxSize*0.9)}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#fff';
        ctx.fillText(snakeEmoji, cx, cy);
      });
    } else {
      // Get theme-based colors
      const currentTheme = document.body.className;
      const rootStyles = getComputedStyle(document.body);
      
      // Get snake color/gradient based on theme and skin
      const getSnakeColor = () => {
        const currentTheme = document.body.className;
        const rootStyles = getComputedStyle(document.body);
        
        // Theme-specific skin colors
        if (snakeSkin === 'classic') {
          return currentTheme.includes('theme-classic') ? 
            rootStyles.getPropertyValue('--snake-color').trim() || '#00ff00' : '#4CAF50';
        }
        if (snakeSkin === 'pacman') {
          return currentTheme.includes('theme-pacman') ? 
            rootStyles.getPropertyValue('--snake-color').trim() || '#ffff00' : '#ffff00';
        }
        if (snakeSkin === 'gameboy') {
          return currentTheme.includes('theme-gameboy') ? 
            rootStyles.getPropertyValue('--snake-color').trim() || '#306230' : '#306230';
        }
        if (snakeSkin === 'neon') {
          if (currentTheme.includes('theme-neon')) {
            return rootStyles.getPropertyValue('--snake-color').trim() || '#00ffff';
          } else {
            const gradient = ctx.createLinearGradient(0, 0, boxSize, boxSize);
            gradient.addColorStop(0, '#00ffff');
            gradient.addColorStop(0.5, '#ff00ff');
            gradient.addColorStop(1, '#ffff00');
            return gradient;
          }
        }
        if (snakeSkin === 'arcade') {
          if (currentTheme.includes('theme-arcade')) {
            return rootStyles.getPropertyValue('--snake-color').trim() || '#ff0080';
          } else {
            const gradient = ctx.createLinearGradient(0, 0, boxSize, boxSize);
            gradient.addColorStop(0, '#ff0080');
            gradient.addColorStop(0.5, '#8000ff');
            gradient.addColorStop(1, '#ff8000');
            return gradient;
          }
        }
        if (snakeSkin === 'rainbow') return `hsl(${Math.floor((performance.now()/50)%360)}, 90%, 55%)`;
        if (snakeSkin === 'daylight') {
          // Sunny, warm colors with smooth golden transitions
          const time = performance.now() / 600; // Slower, smoother animation
          const dayPhase = Math.sin(time / 3) * 0.5 + 0.5; // Gentle oscillation 0-1
          
          // Warm color range: golden yellow to warm orange
          const hue = 35 + Math.sin(time / 2) * 20; // 15-55 degrees (yellow to orange)
          const saturation = 75 + Math.sin(time / 1.5) * 15; // 60-90% saturation
          const lightness = 55 + Math.sin(time / 2.5) * 15; // 40-70% lightness
          
          return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
        if (snakeSkin === 'starlight') {
          // Slower, smoother twinkling star-like effect with cool night colors
          const time = performance.now() / 800; // Much slower animation
          const twinkle = Math.sin(time) * 0.2 + 0.8; // Smaller variation, brighter base
          const hue = 220 + Math.sin(time / 2) * 20; // Slower hue shift, blue to purple range
          const lightness = 60 + Math.sin(time * 1.5) * 15; // Gentle lightness variation
          return `hsla(${hue}, 85%, ${lightness}%, ${0.9 + twinkle * 0.1})`;
        }
        // Default fallback
        return currentTheme.includes('theme-') ? 
          rootStyles.getPropertyValue('--snake-color').trim() || '#4CAF50' : '#4CAF50';
      };

      const snakeColor = getSnakeColor();
      ctx.fillStyle = snakeColor;
      
      snake.forEach((segment, i) => {
        if (!segment) return;
        const x = segment.x * boxSize;
        const y = segment.y * boxSize;
        
        // Theme-specific shapes based on skin selection
        if ((currentTheme.includes('theme-pacman') && snakeSkin === 'pacman') || 
            (snakeSkin === 'pacman' && !currentTheme.includes('theme-'))) {
          const cx = x + boxSize/2;
          const cy = y + boxSize/2;
          
          if (i === 0) {
            // Head - Draw Pac-Man with animated mouth opening
            const radius = boxSize * 0.45;
            let mouthAngle = 0; // Default facing right
            
            if (direction === 'UP') mouthAngle = -Math.PI / 2;
            else if (direction === 'DOWN') mouthAngle = Math.PI / 2;
            else if (direction === 'LEFT') mouthAngle = Math.PI;
            else mouthAngle = 0; // RIGHT
            
            // Animate mouth opening and closing
            const time = performance.now();
            const mouthCycle = Math.sin(time / 200); // Controls speed of mouth animation
            const mouthSize = Math.max(0.1, (mouthCycle + 1) / 2) * (Math.PI / 3); // Mouth opens between 10% and 60 degrees
            
            // Draw Pac-Man head with animated mouth
            ctx.beginPath();
            ctx.arc(cx, cy, radius, mouthAngle + mouthSize, mouthAngle + 2 * Math.PI - mouthSize);
            ctx.lineTo(cx, cy);
            ctx.closePath();
            ctx.fill();
          } else {
            // Body segments - Draw smaller solid circles (eaten pellets)
            ctx.beginPath();
            ctx.arc(cx, cy, boxSize * 0.35, 0, 2 * Math.PI);
            ctx.fill();
          }
        } else if ((currentTheme.includes('theme-gameboy') && snakeSkin === 'gameboy') || 
                   (snakeSkin === 'gameboy' && !currentTheme.includes('theme-'))) {
          // Draw Game Boy style with LCD pixel effect and subtle border
          const pixelSize = boxSize - 3;
          ctx.fillRect(x + 1.5, y + 1.5, pixelSize, pixelSize);
          
          // Add subtle highlight for LCD effect
          ctx.fillStyle = 'rgba(155, 188, 15, 0.3)';
          ctx.fillRect(x + 1.5, y + 1.5, pixelSize, 2);
          ctx.fillRect(x + 1.5, y + 1.5, 2, pixelSize);
          
          // Reset color for next segment
          ctx.fillStyle = snakeColor;
        } else if ((currentTheme.includes('theme-neon') && snakeSkin === 'neon') || 
                   (snakeSkin === 'neon' && !currentTheme.includes('theme-'))) {
          // Draw with glow effect
          ctx.shadowColor = snakeColor;
          ctx.shadowBlur = 10;
          ctx.fillRect(x, y, boxSize, boxSize);
          ctx.shadowBlur = 0;
        } else if ((currentTheme.includes('theme-arcade') && snakeSkin === 'arcade') || 
                   (snakeSkin === 'arcade' && !currentTheme.includes('theme-'))) {
          // Draw arcade style with gradient effect and glow
          const gradient = ctx.createLinearGradient(x, y, x + boxSize, y + boxSize);
          gradient.addColorStop(0, snakeColor);
          gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
          gradient.addColorStop(1, snakeColor);
          
          ctx.fillStyle = gradient;
          ctx.shadowColor = snakeColor;
          ctx.shadowBlur = 5;
          
          ctx.beginPath();
          ctx.roundRect(x + 1, y + 1, boxSize - 2, boxSize - 2, 4);
          ctx.fill();
          
          // Reset shadow and color
          ctx.shadowBlur = 0;
          ctx.fillStyle = snakeColor;
        } else if ((currentTheme.includes('theme-classic') && snakeSkin === 'classic') || 
                   (snakeSkin === 'classic' && !currentTheme.includes('theme-'))) {
          // Draw classic retro style with subtle 3D effect
          ctx.fillRect(x, y, boxSize, boxSize);
          
          // Add retro 3D highlight effect
          ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
          ctx.fillRect(x, y, boxSize - 1, 1); // Top highlight
          ctx.fillRect(x, y, 1, boxSize - 1); // Left highlight
          
          // Add shadow
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillRect(x + boxSize - 1, y + 1, 1, boxSize - 1); // Right shadow
          ctx.fillRect(x + 1, y + boxSize - 1, boxSize - 1, 1); // Bottom shadow
          
          // Reset color for next segment
          ctx.fillStyle = snakeColor;
        } else if (snakeSkin === 'daylight') {
          // Daylight skin with golden sunray effects
          const time = performance.now() / 1000;
          
          // Draw base segment with subtle glow
          ctx.shadowColor = snakeColor;
          ctx.shadowBlur = 3;
          ctx.fillRect(x, y, boxSize, boxSize);
          ctx.shadowBlur = 0;
          
          // Add floating golden particles/sunbeams
          const numParticles = 2 + Math.floor(Math.random() * 3); // 2-4 particles per segment
          
          for (let particle = 0; particle < numParticles; particle++) {
            const particleTime = time + (i * 0.3) + (particle * 0.5);
            const glow = Math.sin(particleTime * 1.5 + particle) * 0.3 + 0.7; // 0.4 to 1
            
            if (glow > 0.5) { // Only show when bright enough
              const particleX = x + (boxSize * 0.15) + (particle * boxSize * 0.3) + Math.sin(particleTime + particle) * 4;
              const particleY = y + (boxSize * 0.15) + ((particle % 2) * boxSize * 0.7) + Math.cos(particleTime * 0.8 + particle) * 4;
              const particleSize = 1.5 + glow * 2;
              
              // Create golden sunbeam color
              const goldHue = 45 + Math.sin(particleTime) * 10; // Golden yellow range
              const goldAlpha = glow * 0.6;
              
              ctx.fillStyle = `hsla(${goldHue}, 85%, 70%, ${goldAlpha})`;
              
              // Draw diamond-shaped sunbeam
              ctx.save();
              ctx.translate(particleX, particleY);
              ctx.rotate(particleTime + particle);
              
              ctx.beginPath();
              ctx.moveTo(0, -particleSize);
              ctx.lineTo(particleSize * 0.6, 0);
              ctx.lineTo(0, particleSize);
              ctx.lineTo(-particleSize * 0.6, 0);
              ctx.closePath();
              ctx.fill();
              
              // Add golden glow
              ctx.shadowColor = `hsla(${goldHue}, 90%, 75%, ${goldAlpha * 0.8})`;
              ctx.shadowBlur = particleSize * 1.5;
              ctx.fill();
              
              ctx.restore();
            }
          }
          
          // Add warm highlight on top edge
          ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
          ctx.fillRect(x, y, boxSize, 2);
          
          // Reset for next segment
          ctx.fillStyle = snakeColor;
          ctx.shadowBlur = 0;
        } else if (snakeSkin === 'starlight') {
          // Starlight skin with shimmering star effects
          const time = performance.now() / 1000;
          
          // Draw base segment
          ctx.fillRect(x, y, boxSize, boxSize);
          
          // Add multiple shimmering stars on each segment
          const numStars = 3 + Math.floor(Math.random() * 3); // 3-5 stars per segment
          
          for (let star = 0; star < numStars; star++) {
            const starTime = time + (i * 0.5) + (star * 0.3); // Offset each star's timing
            const shimmer = Math.sin(starTime * 2 + star) * 0.5 + 0.5; // 0 to 1
            
            if (shimmer > 0.3) { // Only show star when bright enough
              const starX = x + (boxSize * 0.2) + (star * boxSize * 0.25) + Math.sin(starTime + star) * 3;
              const starY = y + (boxSize * 0.2) + ((star % 2) * boxSize * 0.6) + Math.cos(starTime + star) * 3;
              const starSize = 1 + shimmer * 2;
              
              // Create shimmering star color
              const starHue = 200 + Math.sin(starTime) * 30;
              const starAlpha = shimmer * 0.8;
              
              ctx.fillStyle = `hsla(${starHue}, 90%, 85%, ${starAlpha})`;
              
              // Draw 4-pointed star
              ctx.save();
              ctx.translate(starX, starY);
              ctx.beginPath();
              
              // Star shape with 4 points
              for (let point = 0; point < 4; point++) {
                const angle = (point * Math.PI) / 2;
                const outerRadius = starSize;
                const innerRadius = starSize * 0.4;
                
                if (point === 0) {
                  ctx.moveTo(0, -outerRadius);
                } else {
                  ctx.lineTo(0, -outerRadius);
                }
                
                ctx.lineTo(innerRadius * Math.sin(angle + Math.PI/4), -innerRadius * Math.cos(angle + Math.PI/4));
                ctx.rotate(Math.PI / 2);
              }
              
              ctx.closePath();
              ctx.fill();
              
              // Add star glow
              ctx.shadowColor = `hsla(${starHue}, 90%, 85%, ${starAlpha * 0.5})`;
              ctx.shadowBlur = starSize * 2;
              ctx.fill();
              
              ctx.restore();
            }
          }
          
          // Reset for next segment
          ctx.fillStyle = snakeColor;
          ctx.shadowBlur = 0;
        } else {
          // Default square for any other combination
          ctx.fillRect(x, y, boxSize, boxSize);
        }
      });
      
      // Add theme-specific eyes to head (except for Pac-Man skin)
      if (snake[0] && snakeSkin !== 'pacman') {
        const head = snake[0];
        const cx = (head.x + 0.5) * boxSize;
        const cy = (head.y + 0.5) * boxSize;
        
        // Theme-specific eye styling
        if (snakeSkin === 'gameboy') {
          // Game Boy style - simple dark pixels
          ctx.fillStyle = '#0f380f';
          const eyeSize = boxSize * 0.1;
          const eyeOffset = boxSize * 0.18;
          
          let eye1X, eye1Y, eye2X, eye2Y;
          if (direction === 'UP') {
            eye1X = cx - eyeOffset; eye1Y = cy - eyeOffset;
            eye2X = cx + eyeOffset; eye2Y = cy - eyeOffset;
          } else if (direction === 'DOWN') {
            eye1X = cx - eyeOffset; eye1Y = cy + eyeOffset;
            eye2X = cx + eyeOffset; eye2Y = cy + eyeOffset;
          } else if (direction === 'LEFT') {
            eye1X = cx - eyeOffset; eye1Y = cy - eyeOffset;
            eye2X = cx - eyeOffset; eye2Y = cy + eyeOffset;
          } else {
            eye1X = cx + eyeOffset; eye1Y = cy - eyeOffset;
            eye2X = cx + eyeOffset; eye2Y = cy + eyeOffset;
          }
          
          ctx.fillRect(eye1X - eyeSize/2, eye1Y - eyeSize/2, eyeSize, eyeSize);
          ctx.fillRect(eye2X - eyeSize/2, eye2Y - eyeSize/2, eyeSize, eyeSize);
          
        } else if (snakeSkin === 'arcade') {
          // Arcade style - glowing eyes
          ctx.fillStyle = '#fff';
          ctx.shadowColor = '#fff';
          ctx.shadowBlur = 3;
          const eyeSize = boxSize * 0.08;
          const eyeOffset = boxSize * 0.2;
          
          let eye1X, eye1Y, eye2X, eye2Y;
          if (direction === 'UP') {
            eye1X = cx - eyeOffset; eye1Y = cy - eyeOffset;
            eye2X = cx + eyeOffset; eye2Y = cy - eyeOffset;
          } else if (direction === 'DOWN') {
            eye1X = cx - eyeOffset; eye1Y = cy + eyeOffset;
            eye2X = cx + eyeOffset; eye2Y = cy + eyeOffset;
          } else if (direction === 'LEFT') {
            eye1X = cx - eyeOffset; eye1Y = cy - eyeOffset;
            eye2X = cx - eyeOffset; eye2Y = cy + eyeOffset;
          } else {
            eye1X = cx + eyeOffset; eye1Y = cy - eyeOffset;
            eye2X = cx + eyeOffset; eye2Y = cy + eyeOffset;
          }
          
          ctx.beginPath();
          ctx.arc(eye1X, eye1Y, eyeSize, 0, Math.PI * 2);
          ctx.arc(eye2X, eye2Y, eyeSize, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
          
        } else {
          // Classic and other styles - standard black eyes
          ctx.fillStyle = '#000';
          const eyeSize = boxSize * 0.12;
          const eyeOffset = boxSize * 0.22;
          
          let eye1X, eye1Y, eye2X, eye2Y;
          if (direction === 'UP') {
            eye1X = cx - eyeOffset; eye1Y = cy - eyeOffset;
            eye2X = cx + eyeOffset; eye2Y = cy - eyeOffset;
          } else if (direction === 'DOWN') {
            eye1X = cx - eyeOffset; eye1Y = cy + eyeOffset;
            eye2X = cx + eyeOffset; eye2Y = cy + eyeOffset;
          } else if (direction === 'LEFT') {
            eye1X = cx - eyeOffset; eye1Y = cy - eyeOffset;
            eye2X = cx - eyeOffset; eye2Y = cy + eyeOffset;
          } else {
            eye1X = cx + eyeOffset; eye1Y = cy - eyeOffset;
            eye2X = cx + eyeOffset; eye2Y = cy + eyeOffset;
          }
          
          ctx.beginPath();
          ctx.arc(eye1X, eye1Y, eyeSize, 0, Math.PI * 2);
          ctx.arc(eye2X, eye2Y, eyeSize, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
  }

  // Draw food
  if (food && typeof food.x === 'number' && typeof food.y === 'number') {
    const fx = (food.x + 0.5) * boxSize;
    const fy = (food.y + 0.5) * boxSize;
    const currentTheme = document.body.className;
    const rootStyles = getComputedStyle(document.body);
    
    // Get theme-specific colors or defaults
    const foodColor = rootStyles.getPropertyValue('--food-color').trim() || '#E32727';
    const powerupColor = rootStyles.getPropertyValue('--powerup-color').trim() || '#FFD24D';
    
    if (food.type === 'normal') {
      ctx.beginPath(); 
      ctx.fillStyle = foodColor;
      
      if (currentTheme.includes('theme-pacman')) {
        // Draw as small dot like Pac-Man pellets
        ctx.arc(fx, fy, boxSize * 0.15, 0, 2 * Math.PI);
        ctx.fill();
      } else if (currentTheme.includes('theme-gameboy')) {
        // Draw as small pixel block
        ctx.fillRect(fx - boxSize * 0.2, fy - boxSize * 0.2, boxSize * 0.4, boxSize * 0.4);
      } else if (currentTheme.includes('theme-classic')) {
        // Draw as simple square food
        ctx.fillRect(fx - boxSize * 0.25, fy - boxSize * 0.25, boxSize * 0.5, boxSize * 0.5);
      } else if (currentTheme.includes('theme-neon')) {
        // Draw with glow effect
        ctx.shadowColor = foodColor;
        ctx.shadowBlur = 8;
        ctx.arc(fx, fy, boxSize * 0.3, 0, 2 * Math.PI);
        ctx.fill();
        ctx.shadowBlur = 0;
      } else if (currentTheme.includes('theme-arcade')) {
        // Draw as diamond/gem shape
        ctx.beginPath();
        ctx.moveTo(fx, fy - boxSize * 0.3);
        ctx.lineTo(fx + boxSize * 0.3, fy);
        ctx.lineTo(fx, fy + boxSize * 0.3);
        ctx.lineTo(fx - boxSize * 0.3, fy);
        ctx.closePath();
        ctx.fill();
      } else {
        // Default apple
        ctx.arc(fx, fy, boxSize * 0.4, 0, 2 * Math.PI);
        ctx.fill();
        // Apple stem
        ctx.fillStyle = '#3B7A14';
        ctx.fillRect(fx + boxSize * 0.1, fy - boxSize * 0.4, boxSize * 0.15, boxSize * 0.2);
      }
    } else if (food.type === 'power_double') {
      ctx.beginPath(); 
      ctx.fillStyle = powerupColor;
      
      if (currentTheme.includes('theme-pacman')) {
        // Draw as large power pellet (flashing)
        const flash = Math.floor(performance.now() / 300) % 2;
        ctx.globalAlpha = flash ? 1.0 : 0.6;
        ctx.arc(fx, fy, boxSize * 0.45, 0, 2 * Math.PI);
        ctx.fill();
        ctx.globalAlpha = 1.0;
      } else if (currentTheme.includes('theme-gameboy')) {
        // Draw as larger pixel block with border
        ctx.fillRect(fx - boxSize * 0.35, fy - boxSize * 0.35, boxSize * 0.7, boxSize * 0.7);
        ctx.strokeStyle = '#0f380f';
        ctx.lineWidth = 2;
        ctx.strokeRect(fx - boxSize * 0.35, fy - boxSize * 0.35, boxSize * 0.7, boxSize * 0.7);
      } else if (currentTheme.includes('theme-classic')) {
        // Draw as flashing square
        const flash = Math.floor(performance.now() / 200) % 2;
        ctx.globalAlpha = flash ? 1.0 : 0.5;
        ctx.fillRect(fx - boxSize * 0.4, fy - boxSize * 0.4, boxSize * 0.8, boxSize * 0.8);
        ctx.globalAlpha = 1.0;
      } else if (currentTheme.includes('theme-neon')) {
        // Draw with intense glow
        ctx.shadowColor = powerupColor;
        ctx.shadowBlur = 15;
        ctx.arc(fx, fy, boxSize * 0.38, 0, 2 * Math.PI);
        ctx.fill();
        ctx.shadowBlur = 0;
      } else if (currentTheme.includes('theme-arcade')) {
        // Draw as star shape
        const spikes = 5;
        const outerRadius = boxSize * 0.4;
        const innerRadius = boxSize * 0.2;
        ctx.beginPath();
        for (let i = 0; i < spikes * 2; i++) {
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          const angle = (i * Math.PI) / spikes;
          const x = fx + Math.cos(angle) * radius;
          const y = fy + Math.sin(angle) * radius;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
      } else {
        // Default circle with text
        ctx.arc(fx, fy, boxSize * 0.38, 0, 2 * Math.PI); 
        ctx.fill();
        ctx.fillStyle = '#000'; 
        ctx.font = `${Math.max(10, boxSize*0.4)}px sans-serif`; 
        ctx.textAlign='center'; 
        ctx.textBaseline='middle'; 
        ctx.fillText('2x', fx, fy);
      }
    } else if (food.type === 'power_speed') {
      const speedPowerColor = rootStyles.getPropertyValue('--powerup-color').trim() || '#4FD1C5';
      ctx.beginPath(); 
      ctx.fillStyle = speedPowerColor;
      
      if (currentTheme.includes('theme-pacman')) {
        // Draw as large power pellet with different color (flashing)
        const flash = Math.floor(performance.now() / 250) % 2;
        ctx.globalAlpha = flash ? 1.0 : 0.7;
        ctx.arc(fx, fy, boxSize * 0.45, 0, 2 * Math.PI);
        ctx.fill();
        ctx.globalAlpha = 1.0;
      } else if (currentTheme.includes('theme-gameboy')) {
        // Draw as larger pixel block with animation
        const pulse = Math.sin(performance.now() / 200) * 0.1 + 1;
        const size = boxSize * 0.35 * pulse;
        ctx.fillRect(fx - size, fy - size, size * 2, size * 2);
      } else if (currentTheme.includes('theme-classic')) {
        // Draw as flashing triangle
        const flash = Math.floor(performance.now() / 150) % 2;
        ctx.globalAlpha = flash ? 1.0 : 0.6;
        ctx.beginPath();
        ctx.moveTo(fx, fy - boxSize * 0.4);
        ctx.lineTo(fx + boxSize * 0.35, fy + boxSize * 0.2);
        ctx.lineTo(fx - boxSize * 0.35, fy + boxSize * 0.2);
        ctx.closePath();
        ctx.fill();
        ctx.globalAlpha = 1.0;
      } else if (currentTheme.includes('theme-neon')) {
        // Draw with pulsing glow
        const pulse = Math.sin(performance.now() / 300) * 5 + 15;
        ctx.shadowColor = speedPowerColor;
        ctx.shadowBlur = pulse;
        ctx.arc(fx, fy, boxSize * 0.38, 0, 2 * Math.PI);
        ctx.fill();
        ctx.shadowBlur = 0;
      } else if (currentTheme.includes('theme-arcade')) {
        // Draw as hexagon
        const sides = 6;
        const radius = boxSize * 0.4;
        ctx.beginPath();
        for (let i = 0; i < sides; i++) {
          const angle = (i * 2 * Math.PI) / sides;
          const x = fx + Math.cos(angle) * radius;
          const y = fy + Math.sin(angle) * radius;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
      } else {
        // Default circle with lightning
        ctx.arc(fx, fy, boxSize * 0.38, 0, 2*Math.PI); 
        ctx.fill();
        ctx.fillStyle = '#000'; 
        ctx.font = `${Math.max(10, boxSize*0.45)}px sans-serif`; 
        ctx.textAlign='center'; 
        ctx.textBaseline='middle'; 
        ctx.fillText('‚ö°', fx, fy);
      }
    }
  }
}

function handleFoodEaten() {
  // Play appropriate sound effect
  try {
    if (food.type === 'power_double' || food.type === 'power_speed') {
      powerSound.currentTime = 0; // Reset sound to start
      powerSound.play();
    } else {
      eatSound.currentTime = 0; // Reset sound to start
      eatSound.play();
    }
  } catch (e) {
    console.log('Sound playback failed:', e);
  }
  
  let points = 25;  // Increased from 10
  if (food.type === 'power_double') {
    multiplierActive = true;
    points = 50;  // Increased from 20
    multiplierTimeLeft = 10;
    // Set 2x points for 10 seconds with timer display
    clearTimeout(multiplierInterval);
    const startTime = Date.now();
    const updateTimer = () => {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const remaining = Math.max(0, 10 - elapsed);
      updateMultiplierDisplay(remaining);
      if (remaining > 0) {
        setTimeout(updateTimer, 1000);
      }
    };
    updateTimer();
    multiplierInterval = setTimeout(() => {
      multiplierActive = false;
      updateMultiplierDisplay(0);
      console.log('2x points expired');
    }, 10000);
  } else if (food.type === 'power_speed') {
    points = 40;  // Increased from 15
    speedTimeLeft = 8;
    // Set 1.25x speed for 8 seconds with timer display (reduced from 1.5x)
    speed = Math.max(50, Math.floor(speed / 1.25)); // 1.25x speed (more manageable)
    clearInterval(gameInterval);
    gameInterval = setInterval(gameLoop, speed);
    clearTimeout(speedInterval);
    const startTime = Date.now();
    const updateTimer = () => {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const remaining = Math.max(0, 8 - elapsed);
      updateSpeedDisplay(remaining);
      if (remaining > 0) {
        setTimeout(updateTimer, 1000);
      }
    };
    updateTimer();
    speedInterval = setTimeout(() => {
      speed = baseSpeed;
      clearInterval(gameInterval);
      gameInterval = setInterval(gameLoop, speed);
      updateSpeedDisplay(0);
      console.log('1.25x speed expired');
    }, 8000);
  }
  
  if (multiplierActive) points *= 2;
  score += points;
  foodsEaten++;
  
  // Update current foods eaten in stats
  const stats = JSON.parse(localStorage.getItem('pythonixStats') || '{}');
  stats.totalFoodsEaten = (stats.totalFoodsEaten || 0) + 1;
  localStorage.setItem('pythonixStats', JSON.stringify(stats));
  updateStatsDisplay();
  
  // Time attack mode: add 1 second per food eaten
  if (gameMode === 'time') {
    gameTimeLeft += 1;
    updateTimeDisplay();
    console.log('Time attack: +1 second! New time:', gameTimeLeft);
  }
  
  // Progressive difficulty for hard mode
  if (gameMode === 'hard' && foodsEaten % 5 === 0) {
    // Every 5 foods, increase speed slightly
    speed = Math.max(50, speed - 5);
    clearInterval(gameInterval);
    gameInterval = setInterval(gameLoop, speed);
    console.log('Hard mode speed increased to:', speed);
  }
  
  // Update UI elements - fix selector
  const scoreBoard = document.getElementById('scoreBoard');
  if (scoreBoard) scoreBoard.textContent = 'Score: ' + score;
  
  food = randomFood();
}

function endGame() {
  isGameOver = true;
  clearInterval(gameInterval);
  
  // Play game over sound
  try {
    gameOverSound.currentTime = 0; // Reset sound to start
    gameOverSound.play();
  } catch (e) {
    console.log('Game over sound playback failed:', e);
  }
  
  // Submit score to leaderboard
  const gameEndTime = Date.now();
  const gameDuration = gameStartTime ? Math.floor((gameEndTime - gameStartTime) / 1000) : 0;
  
  leaderboardManager.submitScore(score, gameMode, {
    snakeSkin: snakeSkin,
    theme: document.body.className.includes('theme-') ? 
           document.body.className.match(/theme-(\w+)/)?.[1] || 'day' : 'day',
    duration: gameDuration,
    foodsEaten: foodsEaten
  });
  
  // Update high score
  const highScore = parseInt(localStorage.getItem('pythonixHighScore') || '0');
  if (score > highScore) {
    localStorage.setItem('pythonixHighScore', score);
  }
  
  // Show game over screen
  const gameOverScreen = document.getElementById('gameOverScreen');
  if (gameOverScreen) {
    const gameOverText = gameOverScreen.querySelector('h2');
    if (gameOverText) gameOverText.textContent = `Game Over! Score: ${score}`;
    gameOverScreen.style.display = 'flex';
  } else {
    // If no game over screen, return to start menu after showing score
    alert(`Game Over! Score: ${score}`);
    returnToStartScreen();
  }
}

function returnToStartScreen() {
  // Hide game elements
  document.body.classList.remove('game-active');
  
  // Show intro screen
  const introScreen = document.getElementById('introScreen');
  if (introScreen) {
    introScreen.style.display = 'flex';
  }
  
  // Reset menu selection
  currentMenuIndex = 0;
  updateMenuSelection();
  
  // Start background music when returning to start menu
  playBackgroundMusic();
}

// Make sure the navbar buttons work
document.addEventListener('DOMContentLoaded', function() {
  // Find achievements button and add click handler (preserving sound effects)
  const achievementsBtn = document.querySelector('button[onclick*="showAchievements"]') || 
                           document.querySelector('.small-btn:nth-child(1)');
  if (achievementsBtn) {
    const originalClick = achievementsBtn.onclick;
    achievementsBtn.onclick = function(event) {
      if (originalClick) originalClick.call(this, event);
      showAchievements();
    };
    console.log('Achievements button found and connected');
  }
  
  // Find history button and add click handler (preserving sound effects)
  const historyBtn = document.querySelector('button[onclick*="showGameHistory"]') ||
                     document.querySelector('.small-btn:nth-child(2)');
  if (historyBtn) {
    const originalClick = historyBtn.onclick;
    historyBtn.onclick = function(event) {
      if (originalClick) originalClick.call(this, event);
      showGameHistory();
    };
    console.log('History button found and connected');
  }
});

// Update all stats displays
function updateStatsDisplay() {
  // Update high score
  const highScore = parseInt(localStorage.getItem('pythonixHighScore') || '0');
  const highScoreNav = document.getElementById('highScoreNav');
  if (highScoreNav) highScoreNav.textContent = 'High Score: ' + highScore;
  
  // Update total foods eaten from localStorage
  const totalStats = JSON.parse(localStorage.getItem('pythonixStats') || '{}');
  const totalFoodsEaten = totalStats.totalFoodsEaten || 0;
  const foodsEatenNav = document.getElementById('foodsEatenNav');
  if (foodsEatenNav) foodsEatenNav.textContent = 'Foods Eaten: ' + totalFoodsEaten;
}

// Update multiplier timer display
function updateMultiplierDisplay(timeLeft) {
  const multiplierNav = document.getElementById('multiplierNav');
  if (multiplierNav) {
    if (multiplierActive && timeLeft > 0) {
      multiplierNav.textContent = `2x Points (${timeLeft}s)`;
      multiplierNav.style.display = 'inline';
    } else {
      multiplierNav.style.display = 'none';
    }
  }
}

// Update speed timer display
function updateSpeedDisplay(timeLeft) {
  const speedNav = document.getElementById('speedNav');
  if (!speedNav) {
    // Create speed display if it doesn't exist
    const navStats = document.querySelector('.nav-stats');
    if (navStats) {
      const speedSpan = document.createElement('span');
      speedSpan.className = 'stat-item';
      speedSpan.id = 'speedNav';
      speedSpan.style.display = 'none';
      navStats.appendChild(speedSpan);
    }
  }
  const speedDisplay = document.getElementById('speedNav');
  if (speedDisplay) {
    if (speed < baseSpeed && timeLeft > 0) {
      speedDisplay.textContent = `1.5x Speed (${timeLeft}s)`;
      speedDisplay.style.display = 'inline';
    } else {
      speedDisplay.style.display = 'none';
    }
  }
}

// Initialize game mode specific features
function initGameMode() {
  const gameModeSelect = document.getElementById('gameMode');
  const selectedMode = gameModeSelect ? gameModeSelect.value : 'classic';
  gameMode = selectedMode;
  
  // Clear any existing game mode timers
  clearInterval(gameTimeInterval);
  
  // Show/hide mode-specific controls
  const timeAttackDisplay = document.getElementById('timeAttackDisplay');
  
  if (gameMode === 'time') {
    if (timeAttackDisplay) timeAttackDisplay.style.display = 'inline';
    // Initialize time attack (60 seconds, +1 second per food)
    gameTimeLeft = 60;
    updateTimeDisplay();
    gameTimeInterval = setInterval(updateGameTimer, 1000);
  } else {
    if (timeAttackDisplay) timeAttackDisplay.style.display = 'none';
    
    // Set different starting speeds for classic vs hard mode
    if (gameMode === 'hard') {
      // Hard mode: starts faster and gets progressively harder
      baseSpeed = 120; // Faster starting speed
      speed = baseSpeed;
    } else {
      // Classic mode: normal starting speed
      baseSpeed = 150;
      speed = baseSpeed;
    }
  }
}

// Update time attack display
function updateTimeDisplay() {
  const timeLeftSpan = document.getElementById('timeLeft');
  if (timeLeftSpan && gameMode === 'time') {
    timeLeftSpan.textContent = gameTimeLeft;
  }
}

// Game timer for time attack mode
function updateGameTimer() {
  if (gameMode === 'time' && gameTimeLeft > 0) {
    gameTimeLeft--;
    updateTimeDisplay();
    if (gameTimeLeft <= 0) {
      endGame();
    }
  }
}

// Update endGame function to save game data for history/achievements
const originalEndGame = endGame;
endGame = function() {
  // Save game data
  const stats = JSON.parse(localStorage.getItem('pythonixStats') || '{"gamesPlayed": 0, "totalFoodsEaten": 0, "totalScore": 0}');
  const gameHistory = JSON.parse(localStorage.getItem('pythonixGameHistory') || '[]');
  
  // Update stats
  stats.gamesPlayed = (stats.gamesPlayed || 0) + 1;
  stats.totalFoodsEaten = (stats.totalFoodsEaten || 0) + (foodsEaten || 0);
  stats.totalScore = (stats.totalScore || 0) + (score || 0);
  
  // Save game to history
  gameHistory.push({
    score: score || 0,
    foodsEaten: foodsEaten || 0,
    mode: gameMode || 'Classic',
    date: new Date().toISOString()
  });
  
  // Keep only last 50 games
  if (gameHistory.length > 50) {
    gameHistory.splice(0, gameHistory.length - 50);
  }
  
  // Save to localStorage
  localStorage.setItem('pythonixStats', JSON.stringify(stats));
  localStorage.setItem('pythonixGameHistory', JSON.stringify(gameHistory));
  
  console.log('Game saved - Score:', score, 'Foods:', foodsEaten, 'Stats:', stats);
  
  // Call original endGame
  if (originalEndGame) originalEndGame();
};

// Add missing core game functions
function initGame() {
  console.log('Initializing game...');
  
  // Initialize canvas and board
  resizeCanvas();
  
  // Initialize game variables
  snake = [{x: Math.floor(boardWidth/2), y: Math.floor(boardHeight/2)}];
  direction = 'RIGHT';
  window.direction = 'RIGHT';
  window.pendingDirection = null;
  score = 0;
  foodsEaten = 0;
  isGameOver = false;
  isPaused = false;
  multiplierActive = false;
  speed = baseSpeed;
  
  // Clear any existing timers
  clearTimeout(multiplierInterval);
  clearTimeout(speedInterval);
  
  // Initialize food
  food = randomFood();
  
  // Update all displays
  updateStatsDisplay();
  const scoreBoard = document.getElementById('scoreBoard');
  if (scoreBoard) scoreBoard.textContent = 'Score: ' + score;
  
  // Initialize game mode specific features
  initGameMode();
  
  // Ensure keyboard handler is connected
  console.log('Game initialized - Snake at:', snake[0], 'Direction:', direction);
  
  // Start game loop
  clearInterval(gameInterval);
  gameInterval = setInterval(gameLoop, speed || 150);
  
  // Draw initial board
  drawBoard();
}

function startGame() {
  console.log('Starting game...');
  
  // Record game start time
  gameStartTime = Date.now();
  
  // Stop background music when starting game
  stopBackgroundMusic();
  
  // Hide intro screen
  const introScreen = document.getElementById('introScreen');
  if (introScreen) {
    introScreen.style.display = 'none';
  }
  
  // Show game elements by adding class to body
  document.body.classList.add('game-active');
  
  // Initialize the game
  initGame();
}

function restartGame() {
  console.log('Restarting game directly...');
  
  // Stop game over sound immediately
  try {
    gameOverSound.pause();
    gameOverSound.currentTime = 0;
  } catch (e) {
    console.log('Could not stop game over sound:', e);
  }
  
  // Hide game over screen
  const gameOverScreen = document.getElementById('gameOverScreen');
  if (gameOverScreen) {
    gameOverScreen.style.display = 'none';
  }
  
  // Restart the game directly (don't go back to start screen)
  initGame();
  
  // Make sure game elements stay visible
  document.body.classList.add('game-active');
}

// Global function to toggle instructions
function toggleInstructions() {
  const instructionsContent = document.getElementById('instructionsContent');
  if (instructionsContent) {
    if (instructionsContent.style.display === 'none' || instructionsContent.style.display === '') {
      instructionsContent.style.display = 'flex';
      instructionsContent.classList.add('show');
    } else {
      instructionsContent.style.display = 'none';
      instructionsContent.classList.remove('show');
    }
  }
}

// Menu navigation variables
let currentMenuIndex = 0;
const menuItems = ['startOption', 'instructionsOption', 'leaderboardOption', 'accountOption'];

// Update menu selection
function updateMenuSelection() {
  menuItems.forEach((id, index) => {
    const item = document.getElementById(id);
    if (item) {
      if (index === currentMenuIndex) {
        item.classList.add('active');
      } else {
        item.classList.remove('active');
      }
    }
  });
}

// Handle menu navigation
function handleMenuNavigation(event) {
  if (event.code === 'ArrowUp') {
    event.preventDefault();
    playButtonHover(); // Play hover sound on navigation
    currentMenuIndex = (currentMenuIndex - 1 + menuItems.length) % menuItems.length;
    updateMenuSelection();
  } else if (event.code === 'ArrowDown') {
    event.preventDefault();
    playButtonHover(); // Play hover sound on navigation
    currentMenuIndex = (currentMenuIndex + 1) % menuItems.length;
    updateMenuSelection();
  } else if (event.code === 'Space') {
    event.preventDefault();
    playButtonClick(); // Play click sound on selection
    handleMenuAction();
  }
}

// Connect all buttons when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM loaded, connecting menu...');
  
  // Set up menu navigation
  updateMenuSelection();
  
  // Add keyboard event listener for menu navigation
  document.addEventListener('keydown', function(event) {
    const introScreen = document.getElementById('introScreen');
    if (introScreen && introScreen.style.display !== 'none') {
      handleMenuNavigation(event);
    }
  });
  
  // Connect Start Game button (legacy support)
  const startBtn = document.getElementById('startBtn');
  if (startBtn) {
    startBtn.onclick = () => {
      playButtonClick();
      stopBackgroundMusic();
      startGame();
    };
    console.log('Start button connected');
  }
  
  // Connect menu items for mouse clicks
  const startOption = document.getElementById('startOption');
  const instructionsOption = document.getElementById('instructionsOption');
  const leaderboardOption = document.getElementById('leaderboardOption');
  const accountOption = document.getElementById('accountOption');
  
  if (startOption) {
    startOption.onclick = () => {
      playButtonClick();
      stopBackgroundMusic();
      startGame();
    };
    
    // Add hover effects
    startOption.addEventListener('mouseenter', playButtonHover);
  }
  
  if (instructionsOption) {
    instructionsOption.onclick = () => {
      playButtonClick();
      toggleInstructions();
    };
    
    // Add hover effects
    instructionsOption.addEventListener('mouseenter', playButtonHover);
  }
  
  if (leaderboardOption) {
    leaderboardOption.onclick = () => {
      console.log('Leaderboard option clicked');
      playButtonClick();
      openLeaderboardModal();
    };
    
    // Add hover effects
    leaderboardOption.addEventListener('mouseenter', playButtonHover);
  }
  
  if (accountOption) {
    accountOption.onclick = () => {
      console.log('Account option clicked');
      playButtonClick();
      if (authManager.currentUser) {
        if (authManager.currentUser.isGuest) {
          openAuthModal(); // Show upgrade options
        } else {
          // Show profile or logout option
          if (confirm('Do you want to logout?')) {
            authManager.logout();
          }
        }
      } else {
        openAuthModal();
      }
    };
    
    // Add hover effects
    accountOption.addEventListener('mouseenter', playButtonHover);
  }
  
  // Connect Instructions toggle button (legacy support)
  const toggleInstructionsBtn = document.getElementById('toggleInstructions');
  if (toggleInstructionsBtn) {
    toggleInstructionsBtn.onclick = toggleInstructions;
    console.log('Instructions toggle connected');
  }
  
  // Connect History button
  const historyBtn = document.getElementById('showHistory');
  if (historyBtn) {
    historyBtn.onclick = showGameHistory;
    console.log('History button connected');
  }
  
  // Connect Achievements button
  const achievementsBtn = document.getElementById('showAchievements');
  if (achievementsBtn) {
    achievementsBtn.onclick = showAchievements;
    console.log('Achievements button connected');
  }
  
  // Connect Clear Games button
  const clearBtn = document.getElementById('clearGames');
  if (clearBtn) {
    clearBtn.onclick = clearAllGameData;
    console.log('Clear Games button connected');
  }
  
  // Connect Theme selector
  const themeSelect = document.getElementById('themeSelect');
  if (themeSelect) {
    themeSelect.addEventListener('change', function() {
      changeTheme(this.value);
    });
    
    // Set initial theme
    const savedTheme = localStorage.getItem('pythonixTheme') || 'day';
    themeSelect.value = savedTheme;
    changeTheme(savedTheme);
    console.log('Theme selector connected');
  }
  
  // Connect Snake Skin selector
  const snakeSkinSelect = document.getElementById('snakeSkin');
  if (snakeSkinSelect) {
    snakeSkinSelect.addEventListener('change', function() {
      snakeSkin = this.value;
      localStorage.setItem('pythonixSnakeSkin', snakeSkin);
      console.log('Snake skin changed to:', snakeSkin);
    });
    
    // Set initial skin
    const savedSkin = localStorage.getItem('pythonixSnakeSkin') || 'classic';
    snakeSkinSelect.value = savedSkin;
    snakeSkin = savedSkin;
    console.log('Snake skin selector connected');
  }
  
  // Connect Snake Shape selector
  const snakeShapeSelect = document.getElementById('snakeShape');
  const emojiPickerContainer = document.getElementById('emojiPickerContainer');
  if (snakeShapeSelect) {
    snakeShapeSelect.addEventListener('change', function() {
      snakeShape = this.value;
      localStorage.setItem('pythonixSnakeShape', snakeShape);
      
      // Show/hide emoji picker based on selection
      if (snakeShape === 'emoji') {
        emojiPickerContainer.style.display = 'inline';
      } else {
        emojiPickerContainer.style.display = 'none';
      }
      
      console.log('Snake shape changed to:', snakeShape);
    });
    
    // Set initial shape
    const savedShape = localStorage.getItem('pythonixSnakeShape') || 'square';
    snakeShapeSelect.value = savedShape;
    snakeShape = savedShape;
    
    // Show emoji picker if needed
    if (snakeShape === 'emoji') {
      emojiPickerContainer.style.display = 'inline';
    }
    
    console.log('Snake shape selector connected');
  }
  
  // Connect Emoji Picker
  const emojiPicker = document.getElementById('emojiPicker');
  if (emojiPicker) {
    // Handle input changes
    emojiPicker.addEventListener('input', function() {
      const inputValue = this.value.trim();
      
      // Basic validation - allow any text but prefer emojis
      if (inputValue.length > 0) {
        snakeEmoji = inputValue;
        localStorage.setItem('pythonixSnakeEmoji', snakeEmoji);
        console.log('Snake emoji changed to:', snakeEmoji);
      }
    });
    
    // Handle paste events for better emoji support
    emojiPicker.addEventListener('paste', function(e) {
      setTimeout(() => {
        const inputValue = this.value.trim();
        if (inputValue.length > 0) {
          snakeEmoji = inputValue;
          localStorage.setItem('pythonixSnakeEmoji', snakeEmoji);
          console.log('Snake emoji pasted:', snakeEmoji);
        }
      }, 10);
    });
    
    // Set initial emoji
    const savedEmoji = localStorage.getItem('pythonixSnakeEmoji') || 'üêç';
    snakeEmoji = savedEmoji;
    emojiPicker.value = snakeEmoji;
    
    console.log('Emoji picker connected');
  }
  
  // Connect Game Mode selector
  const gameModeSelect = document.getElementById('gameMode');
  if (gameModeSelect) {
    gameModeSelect.addEventListener('change', function() {
      gameMode = this.value;
      initGameMode();
      console.log('Game mode changed to:', gameMode);
    });
  }
  
  // Connect Level controls
  const prevLevelBtn = document.getElementById('prevLevel');
  const nextLevelBtn = document.getElementById('nextLevel');
  const levelDisplay = document.getElementById('levelDisplay');
  let currentLevel = 1;
  
  if (prevLevelBtn) {
    prevLevelBtn.addEventListener('click', function() {
      if (currentLevel > 1) {
        currentLevel--;
        levelDisplay.textContent = currentLevel;
      }
    });
  }
  
  if (nextLevelBtn) {
    nextLevelBtn.addEventListener('click', function() {
      if (currentLevel < 10) {  // Max 10 levels
        currentLevel++;
        levelDisplay.textContent = currentLevel;
      }
    });
  }
  
  // Initialize stats display
  updateStatsDisplay();
  
  console.log('All buttons connected successfully');
});

// Theme changing function
function changeTheme(themeName) {
  console.log('Changing theme to:', themeName);
  
  // Remove all existing theme classes
  document.body.className = document.body.className.replace(/theme-\w+/g, '');
  
  // Handle auto theme (day/night based on time)
  if (themeName === 'auto') {
    const hour = new Date().getHours();
    themeName = (hour >= 6 && hour < 18) ? 'day' : 'night';
  }
  
  // Add new theme class
  document.body.classList.add('theme-' + themeName);
  
  // Save theme preference
  localStorage.setItem('pythonixTheme', themeName);
  
  console.log('Applied theme class: theme-' + themeName);
}

// Make sure keyboard handler is working
window.addEventListener('load', function() {
  console.log('Window loaded, setting up keyboard handler...');
  window.pendingDirection = null;
  window.direction = 'RIGHT';
  
  // Test keyboard handler
  console.log('Keyboard handler should be active. Try pressing arrow keys.');
  
  // Add extra key listener as backup
  document.addEventListener('keydown', function(e) {
    const key = e.key.toLowerCase();
    console.log('Key pressed:', key);
    
    // Handle pause/resume with spacebar
    if (key === ' ' || key === 'space') {
      e.preventDefault();
      const introScreen = document.getElementById('introScreen');
      
      // If on intro screen, handle menu navigation
      if (introScreen && introScreen.style.display !== 'none') {
        handleMenuNavigation(e);
        return;
      }
      
      // If in game, toggle pause
      if (!isGameOver) {
        isPaused = !isPaused;
        if (isPaused) {
          clearInterval(gameInterval);
          console.log('Game paused');
          // Show pause indicator
          const canvas = document.getElementById('gameCanvas');
          if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.font = '24px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
            ctx.font = '12px "Press Start 2P"';
            ctx.fillText('PRESS SPACEBAR TO RESUME', canvas.width/2, canvas.height/2 + 40);
          }
        } else {
          gameInterval = setInterval(gameLoop, speed);
          console.log('Game resumed');
          drawBoard(); // Redraw the board to clear pause overlay
        }
      }
      return;
    }
    
    if (isGameOver || isPaused) return;
    
    if (key === 'arrowleft' || key === 'a') {
      window.pendingDirection = 'LEFT';
    } else if (key === 'arrowright' || key === 'd') {
      window.pendingDirection = 'RIGHT';
    } else if (key === 'arrowup' || key === 'w') {
      window.pendingDirection = 'UP';
    } else if (key === 'arrowdown' || key === 's') {
      window.pendingDirection = 'DOWN';
    }
    
    if (['arrowup','arrowdown','arrowleft','arrowright'].includes(key)) {
      e.preventDefault();
    }
  });
});
</script>
</body>
</html>