<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pythonix</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- <script src="https://sdk.crazygames.com/crazygames-sdk-v3.js"></script> -->
  <meta name="api-base" content="">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  
  <!-- 
  AUDIO FILES USED:
  - eat.mp3: Food eating sound
  - powerup.mp3: Power-up sound and menu selections
  - gameover.mp3: Game over sound
  - menu.wav: Background music for start menu
  - hover.wav: Button hover effects
  - click.wav: Button click sounds
  -->
  <style>
    html, body {
      min-height: 100vh;
      margin: 0;
      font-family: 'Press Start 2P', 'Segoe UI', Arial, sans-serif;
      background: var(--bg, linear-gradient(135deg, #66b5ff 0%, #3863ff 100%));
      transition: background 0.4s;
      margin: 0;
      font-size: 1rem;
      color: #222;
      font-weight: 600;
      /* mimic current.com logo style */
      cursor: default;
    }

    /* Navbar styles */
    .navbar {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 14px;
      padding: 8px 12px;
      max-width: 1100px;
      margin: 18px auto;
      background: hsla(0,0%,100%,.05);
      border-radius: 12px;
      border: 1px solid hsla(0,0%,100%,.1);
      box-shadow: 0 10px 40px rgba(2, 6, 23, 0.55), inset 0 1px 0 rgba(255, 255, 255, 0.02);
      backdrop-filter: blur(12px) saturate(140%);
      transition: all .3s ease;
      position: sticky;
      top: 10px;
      z-index: 1000;
    }

    .navbar-brand {
      display: flex;
      align-items: center;
      gap: 12px;
      padding-right: 10px;
      border-right: 1px solid rgba(255, 255, 255, 0.03);
    }

    .navbar-brand h2 {
      margin: 0;
      color: #fff;
      font-size: 1rem;
      text-shadow: 0 6px 18px rgba(0, 0, 0, 0.45);
    }

    .navbar-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 24px;
      align-items: flex-start;
      padding: 8px 16px;
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      transition: all .3s ease 0.1s;
    }

    .navbar:hover .navbar-controls,
    .navbar:focus-within .navbar-controls,
    .navbar-controls:focus-within {
      max-height: 400px;
      opacity: 1;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 0;
    }

    .group-title {
      font-size: 11px;
      font-weight: 700;
      color: rgba(255, 255, 255, 0.7);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    }

    .control-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .stats-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-bottom: 8px;
    }

    .action-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .navbar-controls label {
      background: transparent;
      padding: 8px 12px;
      border-radius: 10px;
      color: #e0e0e0;
      font-weight: 700;
      font-size: 0.85rem;
      text-shadow: none;
    }

    .navbar-controls select,
    .navbar-controls input[type="text"] {
      background: rgba(255, 255, 255, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: #ffffff;
      padding: 6px 8px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 14px;
    }

    .navbar-controls select {
      background: rgba(40, 60, 80, 0.9);
      color: #ffffff;
      border: 1px solid rgba(255, 255, 255, 0.4);
    }

    .navbar-controls input[type="range"] {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 8px;
      height: 6px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
      width: 120px;
      margin-right: 8px;
    }

    .navbar-controls input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #ffffff;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .navbar-controls input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #ffffff;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    #volumeValue {
      color: #ffffff;
      font-size: 0.8rem;
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      min-width: 35px;
      display: inline-block;
    }

    .navbar-controls select:focus,
    .navbar-controls input[type="text"]:focus {
      outline: none;
      border-color: rgba(255, 255, 255, 0.6);
      background: rgba(50, 70, 90, 0.95);
    }

    .navbar-controls input[type="text"]:focus {
      background: rgba(255, 255, 255, 0.25);
    }

    .navbar-controls select option {
      background: #2c3e50;
      color: #ffffff;
      padding: 8px;
      font-weight: 600;
    }

    .navbar-controls select option:hover {
      background: #34495e;
    }

    /* ===== SHOP & CURRENCY STYLES ===== */
    .coin-display {
      font-family: 'Press Start 2P', monospace;
      color: #FFD700 !important;
      text-shadow: 0 0 10px #FFD700;
      font-size: 16px !important;
      margin: 0 15px;
      background: rgba(255, 215, 0, 0.1) !important;
      padding: 8px 15px !important;
      border-radius: 20px;
      border: 2px solid #FFD700 !important;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
      animation: coinGlow 2s ease-in-out infinite alternate;
      display: inline-block !important;
      visibility: visible !important;
      opacity: 1 !important;
      z-index: 1000 !important;
    }

    @keyframes coinGlow {
      0% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.3); }
      100% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.6); }
    }

    /* Image loading styles */
    .navbar-brand img, .menu-item img {
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
      object-fit: contain;
      max-width: 100%;
      height: auto;
      vertical-align: middle;
      display: inline-block;
    }
    
    .menu-item span:last-child {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .shop-modal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.9);
      z-index: 9999;
      overflow-y: auto;
    }

    .shop-content {
      max-width: 1200px;
      margin: 50px auto;
      padding: 30px;
      background: #000000;
      background-image: 
        linear-gradient(rgba(255, 0, 255, 0.2) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 0, 255, 0.2) 1px, transparent 1px);
      background-size: 20px 20px;
      border-radius: 8px;
      border: 2px solid #FFD700;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
    }

    .shop-header {
      text-align: center;
      margin-bottom: 30px;
    }

    .shop-title {
      font-family: 'Press Start 2P', monospace;
      font-size: 24px;
      color: #FFD700;
      text-shadow: 0 0 20px #FFD700;
      margin-bottom: 15px;
    }

    .shop-tabs {
      display: flex;
      justify-content: center;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }

    .shop-tab {
      background: rgba(0, 255, 0, 0.1);
      border: 2px solid #00FF00;
      color: #00FF00;
      padding: 10px 20px;
      margin: 5px;
      border-radius: 5px;
      font-family: 'Press Start 2P', monospace;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-shadow: 0 0 10px #00FF00;
    }

    .shop-tab.active {
      background: #FFD700;
      color: #000000;
      border-color: #FFD700;
      text-shadow: none;
    }

    .shop-tab:hover {
      background: rgba(255, 0, 255, 0.2);
      border-color: #FF00FF;
      color: #FF00FF;
      transform: translateY(-2px);
      text-shadow: 0 0 10px #FF00FF;
    }

    .shop-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .shop-item {
      background: rgba(255, 0, 255, 0.1);
      border: 2px solid #FF00FF;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      transition: all 0.3s ease;
      overflow: hidden;
      word-wrap: break-word;
    }

    .shop-item:hover {
      transform: translateY(-5px);
      box-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
      border-color: #00FF00;
    }

    .shop-item.owned {
      border-color: #00FF00;
      background: rgba(0, 255, 0, 0.1);
    }

    .shop-item.equipped {
      border-color: #FFD700;
      background: rgba(255, 215, 0, 0.1);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
    }

    .shop-item.legendary {
      border: 3px solid transparent;
      background: linear-gradient(45deg, rgba(255, 0, 255, 0.1), rgba(0, 255, 255, 0.1), rgba(255, 215, 0, 0.1));
      background-size: 400% 400%;
      animation: legendary-glow 3s ease-in-out infinite;
      position: relative;
    }

    .shop-item.legendary::before {
      content: 'ðŸ‘‘ LEGENDARY';
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(45deg, #ff00ff, #00ffff, #ffd700);
      color: black;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 10px;
      font-weight: bold;
      animation: legendary-text 2s ease-in-out infinite;
    }

    @keyframes legendary-glow {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    @keyframes legendary-text {
      0%, 100% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.1); }
    }

    .item-name {
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      color: #FFD700;
      margin-bottom: 10px;
      text-shadow: 0 0 10px #FFD700;
    }

    .item-description {
      font-size: 12px;
      color: #00FF00;
      margin-bottom: 15px;
      line-height: 1.4;
    }

    .item-price {
      font-family: 'Press Start 2P', monospace;
      font-size: 12px;
      color: #FF00FF;
      margin-bottom: 15px;
      text-shadow: 0 0 8px #FF00FF;
    }

    .shop-button {
      background: linear-gradient(45deg, #00FF00, #FFD700);
      border: 2px solid #FFD700;
      color: #000000;
      padding: 10px 20px;
      border-radius: 5px;
      font-family: 'Press Start 2P', monospace;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .shop-button:hover {
      background: linear-gradient(45deg, #FF00FF, #00FFFF);
      border-color: #FF00FF;
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(255, 0, 255, 0.6);
    }

    .shop-button:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
    }

    .shop-button.owned {
      background: #4CAF50;
    }

    .shop-button.equipped {
      background: #FFD700;
      color: #000;
    }

    .close-shop {
      position: absolute;
      top: 20px; right: 30px;
      background: #ff4444;
      border: none;
      color: white;
      font-size: 20px;
      padding: 10px 15px;
      border-radius: 50%;
      cursor: pointer;
      font-family: 'Press Start 2P', monospace;
    }

    /* Enhanced shop item styling */
    .item-header {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }

    .item-type-icon {
      font-size: 18px;
      margin-right: 8px;
    }

    /* Type-specific item styling */
    .type-skin { border-left: 4px solid #4CAF50; }
    .type-trail { border-left: 4px solid #FF9800; }
    .type-powerup { border-left: 4px solid #FFEB3B; }
    .type-utility { border-left: 4px solid #2196F3; }
    .type-badge { border-left: 4px solid #9C27B0; }
    .type-special { border-left: 4px solid #FF5722; }

    .shop-button.powerup-use {
      background: linear-gradient(45deg, #FFEB3B, #FFC107);
      color: #000;
    }

    .shop-button.powerup-use:hover {
      background: linear-gradient(45deg, #FFC107, #FF9800);
    }

    .shop-button.unequip-button {
      background: linear-gradient(45deg, #ff6b6b, #d63031);
      color: white;
      margin-top: 5px;
      font-size: 12px;
      padding: 5px 10px;
      border-radius: 15px;
    }

    .shop-button.unequip-button:hover {
      background: linear-gradient(45deg, #d63031, #b71c1c);
      transform: translateY(-2px);
    }

    /* Customization Modal Styles */
    .customize-section {
      background: rgba(102, 204, 255, 0.1);
      border: 1px solid rgba(102, 204, 255, 0.3);
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .customize-row {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      align-items: center;
    }

    .customize-row label {
      display: flex;
      flex-direction: column;
      gap: 5px;
      flex: 1;
      min-width: 200px;
      color: #fff;
      font-size: 14px;
    }

    .customize-row select,
    .customize-row input[type="text"] {
      padding: 8px 12px;
      border: 1px solid rgba(102, 204, 255, 0.5);
      border-radius: 5px;
      background: rgba(0, 0, 0, 0.3);
      color: #fff;
      font-size: 14px;
    }

    /* Special shop item effects */
    .border-glow-effect {
      box-shadow: 0 0 20px #66ccff, 0 0 40px #66ccff, 0 0 60px #66ccff;
      border: 2px solid #66ccff;
    }

    .golden-food-effect .food {
      filter: hue-rotate(45deg) saturate(2) brightness(1.5);
    }

    .particle-food-effect .food {
      animation: foodParticle 2s ease-in-out infinite;
    }

    @keyframes foodParticle {
      0%, 100% { transform: scale(1); filter: brightness(1); }
      50% { transform: scale(1.1); filter: brightness(1.3) drop-shadow(0 0 5px currentColor); }
    }

    /* ===== SNAKE SKIN EFFECTS ===== */
    .snake-skin-neon .snake-segment {
      box-shadow: 0 0 15px #00ffff, inset 0 0 15px #00ffff;
      background: linear-gradient(45deg, #00ffff, #0080ff) !important;
    }

    .snake-skin-rainbow .snake-segment {
      background: linear-gradient(45deg, #ff0000, #ff8000, #ffff00, #80ff00, #00ff00, #00ff80, #00ffff, #0080ff, #0000ff, #8000ff, #ff00ff, #ff0080) !important;
      animation: rainbowShift 2s linear infinite;
    }

    .snake-skin-metallic .snake-segment {
      background: linear-gradient(45deg, #c0c0c0, #e6e6e6, #c0c0c0) !important;
      box-shadow: inset 0 0 10px rgba(255,255,255,0.5), 0 0 10px rgba(192,192,192,0.8);
    }

    .snake-skin-synthwave .snake-segment {
      background: linear-gradient(45deg, #ff00ff, #00ffff) !important;
      box-shadow: 0 0 20px #ff00ff, inset 0 0 10px #00ffff;
      animation: synthwavePulse 1.5s ease-in-out infinite alternate;
    }

    .snake-skin-glowing .snake-segment {
      background: radial-gradient(circle, #ffffff, #66ccff) !important;
      box-shadow: 0 0 25px #66ccff, 0 0 40px #3399ff, inset 0 0 15px #ffffff;
      animation: glowPulse 1s ease-in-out infinite alternate;
    }

    @keyframes rainbowShift {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }

    @keyframes synthwavePulse {
      0% { box-shadow: 0 0 20px #ff00ff, inset 0 0 10px #00ffff; }
      100% { box-shadow: 0 0 30px #ff00ff, 0 0 20px #00ffff, inset 0 0 15px #ff00ff; }
    }

    @keyframes arcadeTitle {
      0% { 
        background-position: 0% 50%;
        text-shadow: 0 0 20px #FFD700, 0 0 40px #FF00FF;
      }
      50% { 
        background-position: 100% 50%;
        text-shadow: 0 0 30px #00FF00, 0 0 60px #FFD700;
      }
      100% { 
        background-position: 0% 50%;
        text-shadow: 0 0 20px #FFD700, 0 0 40px #FF00FF;
      }
    }

    @keyframes glowPulse {
      0% { box-shadow: 0 0 25px #66ccff, 0 0 40px #3399ff, inset 0 0 15px #ffffff; }
      100% { box-shadow: 0 0 35px #66ccff, 0 0 60px #3399ff, inset 0 0 25px #ffffff; }
    }

    .small-btn {
  background: rgba(255, 255, 255, 0.2);
  color: #ffffff;
  border-radius: 10px;
  padding: 8px 12px;
  border: 1px solid rgba(255, 255, 255, 0.3);
  cursor: pointer;
  font-weight: 700;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
  font-size: 14px;
  transition: all 0.2s ease;
}

.small-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: translateY(-1px);
}

.stat-item {
  color: #ffffff;
  font-weight: 600;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
  font-size: 13px;
  padding: 4px 8px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 6px;
  border: 1px solid rgba(255, 255, 255, 0.2);
}

#emojiPicker {
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.4);
  color: #ffffff;
  text-align: center;
  font-size: 18px;
  width: 50px;
  padding: 6px;
  border-radius: 8px;
  font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', sans-serif;
}

/* ensure emoji picker stands out */
.emoji-picker {
  background: linear-gradient(180deg, #ffffff, #f2f2f2);
  padding: 4px 8px;
  border-radius: 8px;
  font-size: 1.05rem;
  cursor: pointer;
}

/* Amazing animated themes with special effects */
.theme-day { 
  background: linear-gradient(135deg, #87CEEB 0%, #98FB98 40%, #F0E68C 100%);
  --board-bg: #f0f8ff;
  --container-bg: rgba(255, 255, 255, 0.9);
  --container-border: rgba(0, 100, 200, 0.4);
  position: relative;
}
.theme-day::before {
  content: '';
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  pointer-events: none;
  z-index: 1;
  /* Clouds removed as requested */
}
.theme-day::after {
  content: '';
  position: fixed;
  top: 50px; right: 50px;
  width: 100px; height: 100px;
  pointer-events: none;
  z-index: 1;
  background: radial-gradient(circle, #FFD700 30%, rgba(255,215,0,0.3) 70%, transparent);
  border-radius: 50%;
  animation: sunPulse 4s ease-in-out infinite;
  box-shadow: 0 0 50px rgba(255,215,0,0.5);
}

.theme-night { 
  background: linear-gradient(135deg, #0c0c0c 0%, #1a0033 50%, #000051 100%);
  --board-bg: #050f1e;
  --container-bg: rgba(20, 20, 50, 0.8);
  --container-border: rgba(0, 255, 255, 0.4);
  position: relative;
}
.theme-night::before {
  content: '';
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  pointer-events: none;
  z-index: 1;
  background-image: 
    radial-gradient(2px 2px at 50px 50px, #ffffff, transparent),
    radial-gradient(1px 1px at 150px 100px, rgba(255,255,255,0.8), transparent),
    radial-gradient(2px 2px at 300px 150px, #ffffff, transparent),
    radial-gradient(1px 1px at 450px 80px, rgba(255,255,255,0.9), transparent),
    radial-gradient(3px 3px at 200px 200px, #87CEEB, transparent);
  background-repeat: repeat;
  background-size: 500px 250px;
  animation: starfield 25s linear infinite;
}
.theme-night::after {
  content: '';
  position: fixed;
  top: 0; left: -10%; right: -10%; /* Extend beyond screen edges */
  height: 25vh; /* Only top quarter of screen */
  pointer-events: none;
  z-index: 1;
  background: linear-gradient(180deg, 
    rgba(0,255,150,0.3) 0%,
    rgba(150,0,255,0.4) 20%, 
    rgba(0,150,255,0.3) 40%, 
    rgba(255,20,147,0.2) 60%,
    rgba(0,255,150,0.1) 80%,
    transparent 100%),
    /* Add radial fade from sides */
    radial-gradient(ellipse 120% 100% at center top,
    rgba(255,255,255,0.1) 0%,
    transparent 70%);
  animation: aurora 30s ease-in-out infinite;
  opacity: 0.6;
}

.theme-sunset {
  background: linear-gradient(135deg, #FF6B35 0%, #FF8E53 25%, #FF7F50 50%, #FFB347 75%, #FFCCCB 100%);
  --board-bg: #2C1810;
  --container-bg: rgba(255, 140, 83, 0.15);
  --container-border: rgba(255, 107, 53, 0.4);
  --snake-color: #FF4500;
  --food-color: #FFD700;
  --powerup-color: #FF69B4;
  --text-color: #FFFFFF;
  position: relative;
}
.theme-sunset::before {
  content: '';
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  pointer-events: none;
  z-index: 1;
  background: 
    radial-gradient(circle at 20% 80%, rgba(255, 107, 53, 0.2), transparent 50%),
    radial-gradient(circle at 80% 20%, rgba(255, 165, 0, 0.15), transparent 60%),
    radial-gradient(circle at 60% 60%, rgba(255, 69, 0, 0.1), transparent 40%);
  animation: sunsetGlow 8s ease-in-out infinite;
}
.theme-sunset::after {
  content: '';
  position: fixed;
  top: 15%; right: 15%;
  width: 120px; height: 120px;
  pointer-events: none;
  z-index: 1;
  background: radial-gradient(circle, #FFD700 20%, rgba(255, 165, 0, 0.8) 40%, rgba(255, 69, 0, 0.4) 70%, transparent);
  border-radius: 50%;
  animation: sunsetSun 6s ease-in-out infinite;
  box-shadow: 0 0 60px rgba(255, 165, 0, 0.6);
}

.theme-ocean {
  background: linear-gradient(135deg, #006994 0%, #0080B7 25%, #4682B4 50%, #87CEEB 75%, #B0E0E6 100%);
  --board-bg: #001B3D;
  --container-bg: rgba(70, 130, 180, 0.15);
  --container-border: rgba(0, 105, 148, 0.4);
  --snake-color: #20B2AA;
  --food-color: #FF6347;
  --powerup-color: #FFD700;
  --text-color: #FFFFFF;
  position: relative;
}
.theme-ocean::before {
  content: '';
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  pointer-events: none;
  z-index: 1;
  background: 
    radial-gradient(ellipse at 30% 70%, rgba(32, 178, 170, 0.15), transparent 60%),
    radial-gradient(ellipse at 70% 30%, rgba(0, 191, 255, 0.1), transparent 50%),
    linear-gradient(0deg, rgba(0, 105, 148, 0.2) 0%, transparent 30%);
  animation: oceanWaves 12s ease-in-out infinite;
}
.theme-ocean::after {
  content: '';
  position: fixed;
  bottom: 0; left: 0; right: 0;
  height: 40px;
  pointer-events: none;
  z-index: 1;
  background: 
    repeating-linear-gradient(90deg,
      rgba(32, 178, 170, 0.3) 0px,
      rgba(0, 191, 255, 0.2) 20px,
      rgba(70, 130, 180, 0.3) 40px,
      rgba(0, 191, 255, 0.2) 60px);
  animation: oceanTide 8s ease-in-out infinite;
}

.theme-forest {
  background: linear-gradient(135deg, #0D4F3C 0%, #2D5016 25%, #228B22 50%, #32CD32 75%, #90EE90 100%);
  --board-bg: #0B2818;
  --container-bg: rgba(45, 80, 22, 0.15);
  --container-border: rgba(13, 79, 60, 0.4);
  --snake-color: #8FBC8F;
  --food-color: #FF6B6B;
  --powerup-color: #FFD700;
  --text-color: #FFFFFF;
  position: relative;
}
.theme-forest::before {
  content: '';
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  pointer-events: none;
  z-index: 1;
  background-image: 
    radial-gradient(2px 2px at 100px 80px, rgba(144, 238, 144, 0.6), transparent),
    radial-gradient(1px 1px at 200px 120px, rgba(50, 205, 50, 0.4), transparent),
    radial-gradient(3px 3px at 350px 90px, rgba(143, 188, 143, 0.5), transparent),
    radial-gradient(1px 1px at 450px 140px, rgba(34, 139, 34, 0.3), transparent),
    radial-gradient(2px 2px at 150px 200px, rgba(144, 238, 144, 0.4), transparent);
  background-repeat: repeat;
  background-size: 500px 250px;
  animation: forestShimmer 20s ease-in-out infinite;
}
.theme-forest::after {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0;
  height: 60%;
  pointer-events: none;
  z-index: 1;
  background: 
    linear-gradient(180deg, 
      rgba(13, 79, 60, 0.3) 0%,
      rgba(45, 80, 22, 0.2) 20%,
      rgba(34, 139, 34, 0.1) 40%,
      transparent 60%);
  animation: forestBreeze 15s ease-in-out infinite;
}

.theme-classic { 
  background: #000000;
  --board-bg: #000000;
  --snake-color: #00ff00;
  --food-color: #00ff00;
  --powerup-color: #ffff00;
  --container-bg: #003300;
  --container-border: #00ff00;
  --text-color: #00ff00;
  position: relative;
}
.theme-classic::before {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: -1;
  background: 
    repeating-linear-gradient(90deg, 
      transparent, 
      transparent 39px, 
      rgba(0, 255, 0, 0.1) 40px),
    repeating-linear-gradient(0deg,
      transparent,
      transparent 39px,
      rgba(0, 255, 0, 0.1) 40px);
}

.theme-pacman { 
  background: #000080;
  --board-bg: #000080;
  --snake-color: #ffff00;
  --food-color: #ffffff;
  --powerup-color: #ffffff;
  --container-bg: #000040;
  --container-border: #0000ff;
  --text-color: #ffff00;
  position: relative;
}
.theme-pacman::before {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: -1;
  background: 
    repeating-linear-gradient(90deg, 
      transparent, 
      transparent 38px, 
      rgba(0, 0, 255, 0.2) 40px, 
      rgba(0, 0, 255, 0.2) 44px),
    repeating-linear-gradient(0deg,
      transparent,
      transparent 38px,
      rgba(0, 0, 255, 0.2) 40px,
      rgba(0, 0, 255, 0.2) 44px);
}
.theme-pacman::after {
  content: '';
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  pointer-events: none;
  z-index: -2;
  background-image: 
    radial-gradient(2px 2px at 60px 60px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 140px 60px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 220px 60px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 300px 60px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 380px 60px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 60px 140px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 140px 140px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 220px 140px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 300px 140px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 380px 140px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 60px 220px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 140px 220px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 220px 220px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 300px 220px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 380px 220px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 60px 300px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 140px 300px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 220px 300px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 300px 300px, rgba(255, 255, 0, 0.3), transparent),
    radial-gradient(2px 2px at 380px 300px, rgba(255, 255, 0, 0.3), transparent);
  background-repeat: repeat;
  background-size: 440px 360px;
  animation: pacmanDots 2s ease-in-out infinite;
}

.theme-neon { 
  background: #000000;
  --board-bg: #001122;
  --snake-color: #00ffff;
  --food-color: #ff00ff;
  --powerup-color: #ffff00;
  --container-bg: #001122;
  --container-border: #00ffff;
  --text-color: #00ffff;
  position: relative;
}
.theme-neon::before {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 1;
  background: 
    repeating-linear-gradient(90deg, 
      transparent, 
      transparent 39px, 
      rgba(0, 255, 255, 0.3) 40px, 
      rgba(0, 255, 255, 0.3) 41px),
    repeating-linear-gradient(0deg,
      transparent,
      transparent 39px,
      rgba(255, 0, 255, 0.3) 40px,
      rgba(255, 0, 255, 0.3) 41px);
  animation: neonGlow 3s ease-in-out infinite;
}
.theme-neon::after {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 0;
  background: 
    radial-gradient(circle at 20% 20%, rgba(0, 255, 255, 0.05), transparent 40%),
    radial-gradient(circle at 80% 80%, rgba(255, 0, 255, 0.05), transparent 40%),
    radial-gradient(circle at 50% 50%, rgba(255, 255, 0, 0.03), transparent 50%);
  animation: neonPulse 4s ease-in-out infinite;
}

.theme-arcade { 
  background: #000000;
  --board-bg: #000000;
  --snake-color: #00FF00;
  --food-color: #FFD700;
  --powerup-color: #FF00FF;
  --container-bg: rgba(0, 0, 0, 0.8);
  --container-border: #FFD700;
  --text-color: #FFD700;
  position: relative;
}
.theme-arcade::before {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 1;
  background: 
    repeating-linear-gradient(90deg, 
      transparent 0px, 
      transparent 49px, 
      rgba(255, 0, 255, 0.3) 50px, 
      rgba(255, 0, 255, 0.3) 51px),
    repeating-linear-gradient(0deg, 
      transparent 0px, 
      transparent 49px, 
      rgba(255, 0, 255, 0.3) 50px, 
      rgba(255, 0, 255, 0.3) 51px),
    repeating-linear-gradient(45deg, 
      transparent 0px, 
      transparent 98px, 
      rgba(255, 0, 255, 0.15) 100px, 
      rgba(255, 0, 255, 0.15) 102px),
    repeating-linear-gradient(-45deg, 
      transparent 0px, 
      transparent 98px, 
      rgba(255, 0, 255, 0.15) 100px, 
      rgba(255, 0, 255, 0.15) 102px);
  animation: retroGrid 10s linear infinite;
}
.theme-arcade::after {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 2;
  background: 
    repeating-linear-gradient(0deg, 
      transparent, 
      transparent 2px, 
      rgba(255, 215, 0, 0.03) 3px,
      transparent 4px);
  animation: arcadeScanlines 0.1s linear infinite;
}

    /* Simple, gentle animations for special effects only */
    @keyframes gentleStars {
      0%, 100% { opacity: 0.1; }
      50% { opacity: 0.3; }
    }
    @keyframes spookyFloat {
      0% { transform: translateY(100vh) translateX(0%); }
      100% { transform: translateY(-10vh) translateX(100%); }
    }
    @keyframes snowDrift {
      0% { transform: translateY(-10px) translateX(0px); }
      100% { transform: translateY(100vh) translateX(100px); }
    }
    
    /* New seamless snow animation for Christmas */
    @keyframes snowDriftSeamless {
      0% { transform: translateY(-120px) translateX(-15px); opacity: 0; }
      3% { opacity: 1; }
      97% { opacity: 1; }
      100% { transform: translateY(calc(100vh + 120px)) translateX(35px); opacity: 0; }
    }
    
    @keyframes snowDriftSeamless2 {
      0% { transform: translateY(-180px) translateX(25px); opacity: 0; }
      7% { opacity: 0.8; }
      93% { opacity: 0.8; }
      100% { transform: translateY(calc(100vh + 180px)) translateX(-30px); opacity: 0; }
    }
    
    @keyframes snowDriftSeamless3 {
      0% { transform: translateY(-90px) translateX(-35px); opacity: 0; }
      2% { opacity: 0.6; }
      98% { opacity: 0.6; }
      100% { transform: translateY(calc(100vh + 90px)) translateX(45px); opacity: 0; }
    }

    @keyframes snowDriftSeamless4 {
      0% { transform: translateY(-150px) translateX(10px); opacity: 0; }
      5% { opacity: 0.7; }
      95% { opacity: 0.7; }
      100% { transform: translateY(calc(100vh + 150px)) translateX(-20px); opacity: 0; }
    }

    @keyframes snowDriftSeamless5 {
      0% { transform: translateY(-200px) translateX(-5px); opacity: 0; }
      8% { opacity: 0.5; }
      92% { opacity: 0.5; }
      100% { transform: translateY(calc(100vh + 200px)) translateX(55px); opacity: 0; }
    }
    
    /* Improved Halloween animations */
    @keyframes halloweenFloat {
      0% { transform: translateY(100vh) translateX(-50px) rotate(0deg); opacity: 0; }
      10% { opacity: 0.15; }
      90% { opacity: 0.15; }
      100% { transform: translateY(-20vh) translateX(100vw) rotate(20deg); opacity: 0; }
    }
    
    /* Enhanced Cyberpunk animations */
    @keyframes matrixRainFlow {
      0% { transform: translateY(-100vh) translateX(-20px); opacity: 0; }
      10% { opacity: 0.8; }
      90% { opacity: 0.8; }
      100% { transform: translateY(100vh) translateX(20px); opacity: 0; }
    }
    
    /* Enhanced Easter animations */
    @keyframes springPetalFall {
      0% { transform: translateY(-50px) translateX(0) rotate(0deg); opacity: 0.8; }
      100% { transform: translateY(calc(100vh + 50px)) translateX(30px) rotate(180deg); opacity: 0.3; }
    }
    
    @keyframes springDance {
      0% { transform: translate(0, 0) rotate(0deg) scale(1); }
      25% { transform: translate(20px, -10px) rotate(5deg) scale(1.05); }
      50% { transform: translate(40px, 0) rotate(-3deg) scale(0.95); }
      75% { transform: translate(20px, 10px) rotate(8deg) scale(1.1); }
      100% { transform: translate(0, 0) rotate(0deg) scale(1); }
    }
    
    /* Enhanced St. Patrick's animations */
    @keyframes rainbowFlow {
      0% { transform: translateX(-100px) scaleY(1); opacity: 0.6; }
      50% { transform: translateX(100px) scaleY(1.2); opacity: 0.8; }
      100% { transform: translateX(-100px) scaleY(1); opacity: 0.6; }
    }
    
    @keyframes springBounce {
      0%, 100% { transform: translateY(0) scale(1); }
      50% { transform: translateY(-5px) scale(1.02); }
    }
    @keyframes luckySpin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    @keyframes fallLeaves {
      0% { transform: translateY(-10vh) rotate(0deg); }
      100% { transform: translateY(100vh) rotate(180deg); }
    }

    /* Amazing new 3D theme animations */
    @keyframes pulse {
      0%, 100% { opacity: 0.7; text-shadow: 0 0 10px #66ccff, 0 0 20px #3399ff; }
      50% { opacity: 1; text-shadow: 0 0 15px #66ccff, 0 0 30px #3399ff, 0 0 40px #0080ff; }
    }
    @keyframes sunPulse {
      0%, 100% { transform: scale(1) rotate(0deg); box-shadow: 0 0 50px rgba(255,215,0,0.5); }
      50% { transform: scale(1.1) rotate(180deg); box-shadow: 0 0 80px rgba(255,215,0,0.8); }
    }
    @keyframes starfield {
      0% { transform: translateY(0px) translateX(0px); opacity: 0.8; }
      100% { transform: translateY(-50px) translateX(50px); opacity: 1; }
    }
    @keyframes aurora {
      0% { 
        opacity: 0.4; 
        filter: blur(1px);
        transform: scaleY(1) translateY(0px);
      }
      20% { 
        opacity: 0.6; 
        filter: blur(1.5px);
        transform: scaleY(1.05) translateY(-2px);
      }
      40% { 
        opacity: 0.7; 
        filter: blur(2px);
        transform: scaleY(0.95) translateY(-1px);
      }
      60% { 
        opacity: 0.5; 
        filter: blur(1.5px);
        transform: scaleY(1.1) translateY(-3px);
      }
      80% { 
        opacity: 0.6; 
        filter: blur(1px);
        transform: scaleY(0.98) translateY(-1px);
      }
      100% { 
        opacity: 0.4; 
        filter: blur(1px);
        transform: scaleY(1) translateY(0px);
      }
    }
    @keyframes matrixRain {
      0% { transform: translateY(-100vh); opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { transform: translateY(100vh); opacity: 0; }
    }
    @keyframes cyberGlitch {
      0%, 90%, 100% { opacity: 0.05; }
      5%, 85% { opacity: 0.15; transform: skew(0.5deg); }
      10%, 80% { opacity: 0.1; transform: skew(-0.3deg); }
    }
    @keyframes retroSpin {
      0% { transform: rotate(0deg) scale(1); }
      50% { transform: rotate(180deg) scale(1.1); }
      100% { transform: rotate(360deg) scale(1); }
    }
    @keyframes filmGrain {
      0% { opacity: 0.03; }
      50% { opacity: 0.06; }
      100% { opacity: 0.03; }
    }
    @keyframes plasmaPulse {
      0%, 100% { transform: scale(1) rotate(0deg); opacity: 0.6; }
      20% { transform: scale(1.1) rotate(72deg); opacity: 0.8; }
      40% { transform: scale(0.9) rotate(144deg); opacity: 0.5; }
      60% { transform: scale(1.2) rotate(216deg); opacity: 0.9; }
      80% { transform: scale(0.95) rotate(288deg); opacity: 0.4; }
    }
    @keyframes circuitFlow {
      0% { background-position: 0 0, 0 0, 0 0, 0 0; opacity: 0.3; }
      25% { background-position: 25px 25px, -25px 25px, 25px -25px, -25px -25px; opacity: 0.6; }
      50% { background-position: 50px 50px, -50px 50px, 50px -50px, -50px -50px; opacity: 0.4; }
      75% { background-position: 75px 75px, -75px 75px, 75px -75px, -75px -75px; opacity: 0.7; }
      100% { background-position: 100px 100px, -100px 100px, 100px -100px, -100px -100px; opacity: 0.3; }
    }
    @keyframes ghostFloat {
      0% { transform: translateY(100vh) translateX(0) rotate(0deg); opacity: 0; }
      10% { opacity: 0.6; }
      90% { opacity: 0.3; }
      100% { transform: translateY(-20vh) translateX(80vw) rotate(20deg); opacity: 0; }
    }
    @keyframes spookyGlow {
      0%, 100% { opacity: 0.4; transform: scale(1); }
      25% { opacity: 0.7; transform: scale(1.1); }
      75% { opacity: 0.2; transform: scale(0.9); }
    }
    @keyframes petalFall {
      0% { transform: translateY(-20px) translateX(0) rotate(0deg); }
      100% { transform: translateY(120vh) translateX(50px) rotate(360deg); }
    }
    @keyframes butterflyFly {
      0% { transform: translate(0, 0) rotate(0deg); }
      25% { transform: translate(100px, -50px) rotate(10deg); }
      50% { transform: translate(200px, 0) rotate(-5deg); }
      75% { transform: translate(150px, 50px) rotate(15deg); }
      100% { transform: translate(0, 0) rotate(0deg); }
    }
    @keyframes rainbow {
      0% { transform: translateX(-100px) rotate(-10deg); }
      50% { transform: translateX(100px) rotate(10deg); }
      100% { transform: translateX(-100px) rotate(-10deg); }
    }
    @keyframes cloverSpin {
      0% { transform: translateY(-10px) rotate(0deg) scale(1); opacity: 0.2; }
      50% { transform: translateY(10px) rotate(180deg) scale(1.2); opacity: 0.4; }
      100% { transform: translateY(-10px) rotate(360deg) scale(1); opacity: 0.2; }
    }
    @keyframes gentleLeafFall {
      0% { transform: translateY(-20px) translateX(0) rotate(0deg); opacity: 0.7; }
      50% { transform: translateY(60vh) translateX(-20px) rotate(180deg); opacity: 0.9; }
      100% { transform: translateY(120vh) translateX(30px) rotate(360deg); opacity: 0.5; }
    }
    @keyframes gentleBounce {
      0%, 100% { transform: translateY(0) rotate(-1deg) scale(1); }
      50% { transform: translateY(-3px) rotate(1deg) scale(1.02); }
    }

    /* New gaming theme animations */
    @keyframes pacmanDots {
      0% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.3; transform: scale(0.8); }
      100% { opacity: 1; transform: scale(1); }
    }
    
    @keyframes neonGlow {
      0%, 100% { 
        opacity: 0.8;
        filter: brightness(1) hue-rotate(0deg);
      }
      25% { 
        opacity: 1;
        filter: brightness(1.2) hue-rotate(90deg);
      }
      50% { 
        opacity: 0.6;
        filter: brightness(0.8) hue-rotate(180deg);
      }
      75% { 
        opacity: 0.9;
        filter: brightness(1.1) hue-rotate(270deg);
      }
    }
    
    @keyframes neonPulse {
      0%, 100% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.1); }
    }
    
    @keyframes arcadeSpin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes arcadeScanlines {
      0% { transform: translateY(0px); }
      100% { transform: translateY(5px); }
    }

    /* New theme animations */
    @keyframes sunsetGlow {
      0%, 100% { 
        opacity: 0.6; 
        transform: scale(1); 
        filter: brightness(1) hue-rotate(0deg);
      }
      25% { 
        opacity: 0.8; 
        transform: scale(1.05); 
        filter: brightness(1.1) hue-rotate(10deg);
      }
      50% { 
        opacity: 0.4; 
        transform: scale(0.95); 
        filter: brightness(0.9) hue-rotate(-5deg);
      }
      75% { 
        opacity: 0.7; 
        transform: scale(1.02); 
        filter: brightness(1.05) hue-rotate(5deg);
      }
    }
    
    @keyframes sunsetSun {
      0%, 100% { 
        transform: translateY(0px) scale(1); 
        opacity: 0.9;
        filter: brightness(1);
      }
      33% { 
        transform: translateY(-5px) scale(1.05); 
        opacity: 0.7;
        filter: brightness(1.2);
      }
      66% { 
        transform: translateY(2px) scale(0.98); 
        opacity: 1;
        filter: brightness(0.8);
      }
    }
    
    @keyframes oceanWaves {
      0%, 100% { 
        transform: scaleY(1) skewX(0deg); 
        opacity: 0.6; 
      }
      25% { 
        transform: scaleY(1.1) skewX(1deg); 
        opacity: 0.8; 
      }
      50% { 
        transform: scaleY(0.9) skewX(-0.5deg); 
        opacity: 0.4; 
      }
      75% { 
        transform: scaleY(1.05) skewX(0.8deg); 
        opacity: 0.7; 
      }
    }
    
    @keyframes oceanTide {
      0% { transform: translateX(0px) scaleX(1); }
      25% { transform: translateX(10px) scaleX(1.1); }
      50% { transform: translateX(-5px) scaleX(0.95); }
      75% { transform: translateX(8px) scaleX(1.05); }
      100% { transform: translateX(0px) scaleX(1); }
    }
    
    @keyframes forestShimmer {
      0%, 100% { 
        opacity: 0.6; 
        transform: scale(1) rotate(0deg); 
        filter: brightness(1);
      }
      20% { 
        opacity: 0.8; 
        transform: scale(1.02) rotate(0.5deg); 
        filter: brightness(1.1);
      }
      40% { 
        opacity: 0.4; 
        transform: scale(0.98) rotate(-0.3deg); 
        filter: brightness(0.9);
      }
      60% { 
        opacity: 0.7; 
        transform: scale(1.01) rotate(0.2deg); 
        filter: brightness(1.05);
      }
      80% { 
        opacity: 0.5; 
        transform: scale(0.99) rotate(-0.1deg); 
        filter: brightness(0.95);
      }
    }
    
    @keyframes forestBreeze {
      0%, 100% { 
        transform: translateX(0px) scaleX(1); 
        opacity: 0.3; 
      }
      33% { 
        transform: translateX(5px) scaleX(1.02); 
        opacity: 0.5; 
      }
      66% { 
        transform: translateX(-3px) scaleX(0.98); 
        opacity: 0.2; 
      }
    }
    
    /* Enhanced Death Effect Animations */
    @keyframes deathFlash {
      0% { 
        opacity: 0; 
        transform: scale(0.8); 
      }
      20% { 
        opacity: 1; 
        transform: scale(1.2); 
      }
      50% { 
        opacity: 0.8; 
        transform: scale(1); 
      }
      100% { 
        opacity: 0; 
        transform: scale(1.5); 
      }
    }
    
    @keyframes deathParticleExplosion {
      0% {
        transform: translate(0, 0) scale(1) rotate(0deg);
        opacity: 1;
      }
      20% {
        transform: translate(calc(var(--dx) * 0.3), calc(var(--dy) * 0.3)) scale(1.2) rotate(calc(var(--rotation) * 0.3));
        opacity: 1;
      }
      60% {
        transform: translate(calc(var(--dx) * 0.8), calc(var(--dy) * 0.8)) scale(0.8) rotate(calc(var(--rotation) * 0.8));
        opacity: 0.6;
      }
      100% {
        transform: translate(var(--dx), var(--dy)) scale(0.2) rotate(var(--rotation));
        opacity: 0;
      }
    }
    
    @keyframes deathDebris {
      0% {
        transform: translate(0, 0) rotate(0deg) scale(1);
        opacity: 1;
      }
      100% {
        transform: translate(var(--dx), calc(var(--dy) + 200px)) rotate(var(--spin)) scale(0);
        opacity: 0;
      }
    }
    
    @keyframes deathTextAppear {
      0% {
        transform: translate(-50%, -50%) scale(0) rotate(-10deg);
        opacity: 0;
        filter: blur(20px);
      }
      30% {
        transform: translate(-50%, -50%) scale(1.3) rotate(2deg);
        opacity: 1;
        filter: blur(5px);
      }
      60% {
        transform: translate(-50%, -50%) scale(0.9) rotate(-1deg);
        opacity: 1;
        filter: blur(0px);
      }
      80% {
        transform: translate(-50%, -50%) scale(1.1) rotate(0deg);
        opacity: 1;
        filter: blur(0px);
      }
      100% {
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
        opacity: 1;
        filter: blur(0px);
        animation: deathTextPulse 2s ease-in-out infinite;
      }
    }
    
    @keyframes deathTextPulse {
      0%, 100% {
        text-shadow: 
          0 0 10px #FF0000,
          0 0 20px #FF4444,
          0 0 30px #FF6666,
          0 0 40px #FF8888,
          4px 4px 0px #800000,
          8px 8px 0px #400000;
      }
      50% {
        text-shadow: 
          0 0 15px #FF0000,
          0 0 30px #FF4444,
          0 0 45px #FF6666,
          0 0 60px #FF8888,
          4px 4px 0px #800000,
          8px 8px 0px #400000;
      }
    }
    
    @keyframes deathShockwave {
      0% {
        width: 0px;
        height: 0px;
        margin-left: 0px;
        margin-top: 0px;
        opacity: 1;
        border-width: 3px;
      }
      50% {
        width: 300px;
        height: 300px;
        margin-left: -150px;
        margin-top: -150px;
        opacity: 0.6;
        border-width: 2px;
      }
      100% {
        width: 600px;
        height: 600px;
        margin-left: -300px;
        margin-top: -300px;
        opacity: 0;
        border-width: 1px;
      }
    }
    
    @keyframes deathScreenShake {
      0%, 100% { 
        transform: translateX(0) translateY(0) rotate(0deg); 
      }
      10% { 
        transform: translateX(-5px) translateY(-3px) rotate(-0.5deg); 
      }
      20% { 
        transform: translateX(4px) translateY(2px) rotate(0.3deg); 
      }
      30% { 
        transform: translateX(-3px) translateY(-4px) rotate(-0.2deg); 
      }
      40% { 
        transform: translateX(6px) translateY(1px) rotate(0.4deg); 
      }
      50% { 
        transform: translateX(-2px) translateY(-5px) rotate(-0.3deg); 
      }
      60% { 
        transform: translateX(3px) translateY(3px) rotate(0.2deg); 
      }
      70% { 
        transform: translateX(-4px) translateY(-1px) rotate(-0.1deg); 
      }
      80% { 
        transform: translateX(2px) translateY(-2px) rotate(0.1deg); 
      }
      90% { 
        transform: translateX(-1px) translateY(1px) rotate(-0.05deg); 
      }
    }
    
    /* Death effect active state */
    .death-effect-active {
      filter: contrast(1.3) brightness(1.2);
    }
    
    /* Special Effects CSS */
    .border-glow-effect {
      box-shadow: 
        0 0 20px rgba(0, 255, 255, 0.6),
        0 0 40px rgba(0, 255, 255, 0.4),
        0 0 60px rgba(0, 255, 255, 0.2),
        inset 0 0 20px rgba(0, 255, 255, 0.1);
      animation: borderGlowPulse 2s ease-in-out infinite;
    }
    
    /* Arena Energy Dynamic Border System */
    .arena-energy-border {
      transition: all 0.3s ease;
      position: relative;
    }
    
    /* Theme-specific Arena Energy borders */
    .theme-sunset .arena-energy-border {
      box-shadow: 
        0 0 15px rgba(255, 107, 53, 0.8),
        0 0 30px rgba(255, 140, 83, 0.6),
        0 0 45px rgba(255, 179, 71, 0.4),
        inset 0 0 15px rgba(255, 107, 53, 0.2);
      animation: arenaEnergySunset 2.5s ease-in-out infinite;
    }
    
    .theme-ocean .arena-energy-border {
      box-shadow: 
        0 0 15px rgba(32, 178, 170, 0.8),
        0 0 30px rgba(70, 130, 180, 0.6),
        0 0 45px rgba(0, 191, 255, 0.4),
        inset 0 0 15px rgba(32, 178, 170, 0.2);
      animation: arenaEnergyOcean 3s ease-in-out infinite;
    }
    
    .theme-forest .arena-energy-border {
      box-shadow: 
        0 0 15px rgba(50, 205, 50, 0.8),
        0 0 30px rgba(143, 188, 143, 0.6),
        0 0 45px rgba(144, 238, 144, 0.4),
        inset 0 0 15px rgba(34, 139, 34, 0.2);
      animation: arenaEnergyForest 2.8s ease-in-out infinite;
    }
    
    .theme-night .arena-energy-border {
      box-shadow: 
        0 0 15px rgba(65, 105, 225, 0.8),
        0 0 30px rgba(147, 112, 219, 0.6),
        0 0 45px rgba(138, 43, 226, 0.4),
        inset 0 0 15px rgba(75, 0, 130, 0.2);
      animation: arenaEnergyNight 3.2s ease-in-out infinite;
    }
    
    .theme-arcade .arena-energy-border {
      box-shadow: 
        0 0 10px rgba(0, 255, 0, 0.6),
        0 0 20px rgba(255, 0, 255, 0.4),
        0 0 30px rgba(255, 215, 0, 0.3),
        inset 0 0 10px rgba(0, 255, 0, 0.2);
      animation: arenaEnergyArcade 1.8s ease-in-out infinite;
    }
    
    /* Default/Day theme arena energy */
    .theme-day .arena-energy-border,
    .arena-energy-border:not([class*="theme-"]) {
      box-shadow: 
        0 0 15px rgba(76, 175, 80, 0.8),
        0 0 30px rgba(139, 195, 74, 0.6),
        0 0 45px rgba(205, 220, 57, 0.4),
        inset 0 0 15px rgba(76, 175, 80, 0.2);
      animation: arenaEnergyDay 2s ease-in-out infinite;
    }
    
    /* Arena Energy eating flicker effect */
    .arena-energy-eating {
      animation: arenaEnergyFlicker 0.3s ease-out !important;
    }
    
    /* Score-based arena energy intensity */
    .arena-energy-level-1 { filter: brightness(1.2) saturate(1.1); }
    .arena-energy-level-2 { filter: brightness(1.4) saturate(1.2); }
    .arena-energy-level-3 { filter: brightness(1.6) saturate(1.3); }
    .arena-energy-level-4 { filter: brightness(1.8) saturate(1.4); }
    .arena-energy-level-5 { filter: brightness(2.0) saturate(1.5); }
    
    @keyframes borderGlowPulse {
      0%, 100% {
        box-shadow: 
          0 0 20px rgba(0, 255, 255, 0.6),
          0 0 40px rgba(0, 255, 255, 0.4),
          0 0 60px rgba(0, 255, 255, 0.2),
          inset 0 0 20px rgba(0, 255, 255, 0.1);
      }
      50% {
        box-shadow: 
          0 0 30px rgba(0, 255, 255, 0.8),
          0 0 60px rgba(0, 255, 255, 0.6),
          0 0 90px rgba(0, 255, 255, 0.4),
          inset 0 0 30px rgba(0, 255, 255, 0.2);
      }
    }
    
    /* Arena Energy Animations */
    @keyframes arenaEnergySunset {
      0%, 100% { 
        box-shadow: 
          0 0 10px rgba(255, 107, 53, 0.4),
          0 0 20px rgba(255, 140, 83, 0.3),
          0 0 30px rgba(255, 179, 71, 0.2),
          inset 0 0 10px rgba(255, 107, 53, 0.1);
      }
      50% { 
        box-shadow: 
          0 0 15px rgba(255, 107, 53, 0.5),
          0 0 25px rgba(255, 140, 83, 0.4),
          0 0 35px rgba(255, 179, 71, 0.3),
          inset 0 0 15px rgba(255, 107, 53, 0.2);
      }
    }
    
    @keyframes arenaEnergyOcean {
      0%, 100% { 
        box-shadow: 
          0 0 10px rgba(32, 178, 170, 0.4),
          0 0 20px rgba(70, 130, 180, 0.3),
          0 0 30px rgba(0, 191, 255, 0.2),
          inset 0 0 10px rgba(32, 178, 170, 0.1);
      }
      33% { 
        box-shadow: 
          0 0 15px rgba(70, 130, 180, 0.5),
          0 0 25px rgba(0, 191, 255, 0.4),
          0 0 35px rgba(32, 178, 170, 0.3),
          inset 0 0 15px rgba(70, 130, 180, 0.2);
      }
      66% { 
        box-shadow: 
          0 0 18px rgba(0, 191, 255, 0.6),
          0 0 30px rgba(32, 178, 170, 0.4),
          0 0 40px rgba(70, 130, 180, 0.3),
          inset 0 0 18px rgba(0, 191, 255, 0.2);
      }
    }
    
    @keyframes arenaEnergyForest {
      0%, 100% { 
        box-shadow: 
          0 0 10px rgba(50, 205, 50, 0.4),
          0 0 20px rgba(143, 188, 143, 0.3),
          0 0 30px rgba(144, 238, 144, 0.2),
          inset 0 0 10px rgba(34, 139, 34, 0.1);
      }
      50% { 
        box-shadow: 
          0 0 15px rgba(34, 139, 34, 0.5),
          0 0 25px rgba(50, 205, 50, 0.4),
          0 0 35px rgba(143, 188, 143, 0.3),
          inset 0 0 15px rgba(50, 205, 50, 0.2);
      }
    }
    
    @keyframes arenaEnergyNight {
      0%, 100% { 
        box-shadow: 
          0 0 15px rgba(65, 105, 225, 0.8),
          0 0 30px rgba(147, 112, 219, 0.6),
          0 0 45px rgba(138, 43, 226, 0.4),
          inset 0 0 15px rgba(75, 0, 130, 0.2);
      }
      25% { 
        box-shadow: 
          0 0 18px rgba(147, 112, 219, 0.9),
          0 0 36px rgba(138, 43, 226, 0.7),
          0 0 54px rgba(75, 0, 130, 0.5),
          inset 0 0 18px rgba(147, 112, 219, 0.3);
      }
      75% { 
        box-shadow: 
          0 0 20px rgba(138, 43, 226, 1.0),
          0 0 40px rgba(75, 0, 130, 0.8),
          0 0 60px rgba(65, 105, 225, 0.6),
          inset 0 0 20px rgba(138, 43, 226, 0.3);
      }
    }
    
    @keyframes arenaEnergyDay {
      0%, 100% { 
        box-shadow: 
          0 0 10px rgba(76, 175, 80, 0.4),
          0 0 20px rgba(139, 195, 74, 0.3),
          0 0 30px rgba(205, 220, 57, 0.2),
          inset 0 0 10px rgba(76, 175, 80, 0.1);
      }
      50% { 
        box-shadow: 
          0 0 15px rgba(139, 195, 74, 0.5),
          0 0 25px rgba(205, 220, 57, 0.4),
          0 0 35px rgba(76, 175, 80, 0.3),
          inset 0 0 15px rgba(139, 195, 74, 0.2);
      }
    }

    @keyframes arenaEnergyArcade {
      0%, 100% {
        box-shadow: 
          0 0 10px rgba(0, 255, 0, 0.8),
          0 0 20px rgba(255, 0, 255, 0.6),
          0 0 30px rgba(255, 215, 0, 0.4);
      }
      25% {
        box-shadow: 
          0 0 15px rgba(255, 0, 255, 0.9),
          0 0 30px rgba(255, 215, 0, 0.7),
          0 0 45px rgba(0, 255, 0, 0.5);
      }
      50% {
        box-shadow: 
          0 0 20px rgba(255, 215, 0, 1.0),
          0 0 40px rgba(0, 255, 0, 0.8),
          0 0 60px rgba(255, 0, 255, 0.6);
      }
      75% {
        box-shadow: 
          0 0 15px rgba(0, 255, 0, 0.9),
          0 0 30px rgba(255, 0, 255, 0.7),
          0 0 45px rgba(255, 215, 0, 0.5);
      }
    }
    
    @keyframes arenaEnergyFlicker {
      0% { filter: brightness(1.5) saturate(1.5); }
      50% { filter: brightness(2.0) saturate(2.0); }
      100% { filter: brightness(1.0) saturate(1.0); }
    }
    
    /* Combo and Milestone Effect Animations */
    @keyframes comboTextAnimation {
      0% {
        transform: translateX(-50%) scale(0) rotate(-10deg);
        opacity: 0;
      }
      30% {
        transform: translateX(-50%) scale(1.2) rotate(2deg);
        opacity: 1;
      }
      70% {
        transform: translateX(-50%) scale(1) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateX(-50%) scale(0.8) rotate(0deg);
        opacity: 0;
      }
    }
    
    @keyframes comboParticleAnimation {
      0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
      }
      100% {
        transform: translate(var(--dx), var(--dy)) scale(0);
        opacity: 0;
      }
    }
    
    @keyframes milestoneTextAnimation {
      0% {
        transform: translate(-50%, -50%) scale(0) rotate(-15deg);
        opacity: 0;
        filter: blur(10px);
      }
      25% {
        transform: translate(-50%, -50%) scale(1.3) rotate(5deg);
        opacity: 1;
        filter: blur(2px);
      }
      50% {
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
        opacity: 1;
        filter: blur(0px);
      }
      75% {
        transform: translate(-50%, -50%) scale(1.1) rotate(-2deg);
        opacity: 1;
        filter: blur(0px);
      }
      100% {
        transform: translate(-50%, -50%) scale(0.7) rotate(0deg);
        opacity: 0;
        filter: blur(5px);
      }
    }
    
    @keyframes milestoneParticleAnimation {
      0% {
        transform: translate(0, 0) rotate(0deg) scale(1);
        opacity: 1;
      }
      100% {
        transform: translate(var(--dx), var(--dy)) rotate(var(--rotation)) scale(0);
        opacity: 0;
      }
    }
    
    @keyframes portalRingAnimation {
      0% {
        width: 0px;
        height: 0px;
        margin-left: 0px;
        margin-top: 0px;
        opacity: 1;
        border-width: 3px;
      }
      50% {
        width: 40px;
        height: 40px;
        margin-left: -20px;
        margin-top: -20px;
        opacity: 0.8;
        border-width: 2px;
      }
      100% {
        width: 60px;
        height: 60px;
        margin-left: -30px;
        margin-top: -30px;
        opacity: 0;
        border-width: 1px;
      }
    }
    
    @keyframes sparkleAnimation {
      0% {
        transform: scale(0) rotate(0deg);
        opacity: 1;
      }
      50% {
        transform: scale(1.5) rotate(180deg);
        opacity: 0.8;
      }
      100% {
        transform: scale(0) rotate(360deg);
        opacity: 0;
      }
    }
    
    @keyframes spawnPixelAnimation {
      0% {
        transform: scale(0);
        opacity: 1;
      }
      50% {
        transform: scale(1.5);
        opacity: 0.8;
      }
      100% {
        transform: scale(0);
        opacity: 0;
      }
    }
    
    .score-animation-effect {
      animation: scoreAnimationPulse 0.5s ease-out;
    }
    
    @keyframes scoreAnimationPulse {
      0% {
        transform: scale(1);
        text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
      }
      50% {
        transform: scale(1.2);
        text-shadow: 
          0 0 10px rgba(76, 175, 80, 0.8),
          0 0 20px rgba(76, 175, 80, 0.6),
          0 0 30px rgba(76, 175, 80, 0.4);
      }
      100% {
        transform: scale(1);
        text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
      }
    }
    
    .food-particle {
      position: fixed;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      pointer-events: none;
      z-index: 1000;
      animation: foodParticleFloat 1s ease-out forwards;
    }
    
    @keyframes foodParticleFloat {
      0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
      }
      100% {
        transform: translate(var(--dx), var(--dy)) scale(0);
        opacity: 0;
      }
    }
    
    .food-trail {
      position: fixed;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      pointer-events: none;
      z-index: 999;
      background: linear-gradient(45deg, 
        #FF0000, #FF7F00, #FFFF00, #00FF00, 
        #0000FF, #4B0082, #9400D3);
      animation: foodTrailFade 1.5s ease-out forwards;
    }
    
    @keyframes foodTrailFade {
      0% {
        transform: scale(1);
        opacity: 0.8;
      }
      50% {
        transform: scale(1.5);
        opacity: 0.6;
      }
      100% {
        transform: scale(0);
        opacity: 0;
      }
    }

    /* === SPECIAL EFFECTS CSS === */
    
    /* Border Glow Effect */
    .border-glow-effect #gameCanvas {
      box-shadow: 
        0 0 20px rgba(0, 255, 255, 0.6),
        0 0 40px rgba(0, 255, 255, 0.4),
        0 0 60px rgba(0, 255, 255, 0.2),
        inset 0 0 20px rgba(0, 255, 255, 0.1);
      animation: borderPulse 2s ease-in-out infinite;
    }
    
    @keyframes borderPulse {
      0%, 100% { 
        box-shadow: 
          0 0 20px rgba(0, 255, 255, 0.6),
          0 0 40px rgba(0, 255, 255, 0.4),
          0 0 60px rgba(0, 255, 255, 0.2),
          inset 0 0 20px rgba(0, 255, 255, 0.1);
      }
      50% { 
        box-shadow: 
          0 0 30px rgba(0, 255, 255, 0.8),
          0 0 60px rgba(0, 255, 255, 0.6),
          0 0 90px rgba(0, 255, 255, 0.4),
          inset 0 0 30px rgba(0, 255, 255, 0.2);
      }
    }
    
    /* Score Animation Effect */
    .score-animation-effect #scoreBoard {
      animation: scoreGlow 0.5s ease-out;
      transform-origin: center;
    }
    
    @keyframes scoreGlow {
      0% { 
        transform: scale(1); 
        text-shadow: 0 0 5px currentColor;
      }
      50% { 
        transform: scale(1.1); 
        text-shadow: 0 0 15px currentColor, 0 0 25px currentColor;
      }
      100% { 
        transform: scale(1); 
        text-shadow: 0 0 5px currentColor;
      }
    }
    
    /* Particle Food Effect */
    .particle-food-effect .food-particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: radial-gradient(circle, #FFD700, #FFA500);
      border-radius: 50%;
      pointer-events: none;
      z-index: 1;
      animation: particleFloat 1s ease-out forwards;
    }
    
    @keyframes particleFloat {
      0% { 
        opacity: 1; 
        transform: translate(0, 0) scale(1);
      }
      100% { 
        opacity: 0; 
        transform: translate(var(--dx, 0), var(--dy, 0)) scale(0);
      }
    }
    
    /* Rainbow Trail Effect */
    .rainbow-trail-effect .food-trail {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      pointer-events: none;
      z-index: 1;
      animation: rainbowTrail 1.5s ease-out forwards;
    }
    
    @keyframes rainbowTrail {
      0% { 
        opacity: 0.8; 
        transform: scale(1);
        background: hsl(0, 70%, 50%);
      }
      25% { 
        background: hsl(90, 70%, 50%);
      }
      50% { 
        background: hsl(180, 70%, 50%);
      }
      75% { 
        background: hsl(270, 70%, 50%);
      }
      100% { 
        opacity: 0; 
        transform: scale(0);
        background: hsl(360, 70%, 50%);
      }
    }
    
    /* Death Effect Animation */
    .death-effect-active #gameCanvas {
      animation: deathShake 0.5s ease-in-out;
    }
    
    @keyframes deathShake {
      0%, 100% { transform: translateX(0); }
      10% { transform: translateX(-10px) rotate(-1deg); }
      20% { transform: translateX(10px) rotate(1deg); }
      30% { transform: translateX(-8px) rotate(-0.8deg); }
      40% { transform: translateX(8px) rotate(0.8deg); }
      50% { transform: translateX(-6px) rotate(-0.6deg); }
      60% { transform: translateX(6px) rotate(0.6deg); }
      70% { transform: translateX(-4px) rotate(-0.4deg); }
      80% { transform: translateX(4px) rotate(0.4deg); }
      90% { transform: translateX(-2px) rotate(-0.2deg); }
    }
    
    /* Theme-specific particle colors */
    .theme-sunset .food-particle {
      background: radial-gradient(circle, #FF6B35, #FFD700);
    }
    
    .theme-ocean .food-particle {
      background: radial-gradient(circle, #20B2AA, #87CEEB);
    }
    
    .theme-forest .food-particle {
      background: radial-gradient(circle, #32CD32, #90EE90);
    }
    
    .theme-gameboy .food-particle {
      background: radial-gradient(circle, #9BBB58, #8BAC0F);
    }
    
    .theme-night .food-particle {
      background: radial-gradient(circle, #00CED1, #9370DB);
    }
    
    .theme-pacman .food-particle {
      background: radial-gradient(circle, #FFD24D, #FFA500);
    }
    
    .theme-neon .food-particle {
      background: radial-gradient(circle, #00FF88, #0088FF);
    }
    
    .theme-arcade .food-particle {
      background: radial-gradient(circle, #FF1493, #00FFFF);
    }

    /* subtle improvement for canvas to match theme */
    #gameCanvas { 
      border-radius:12px; 
      border-width:3px; 
      box-shadow: 0 18px 60px rgba(0,0,0,0.3);
      position: relative;
      z-index: 2;
      display: none; /* Initially hidden */
    }
    
    /* Hide game container initially */
    .container {
      display: none !important;
    }
    
    /* Hide navbar initially (show only during gameplay) */
    .navbar {
      display: none !important;
    }
    
    /* Show game elements when game is active */
    body.game-active #gameCanvas {
      display: block !important;
    }
    
    body.game-active .container {
      display: block !important;
    }
    
    body.game-active .navbar {
      display: flex !important;
    }
    
    /* Hide intro screen when game is active */
    body.game-active .intro-screen {
      display: none !important;
    }

    html, body {
      min-height: 100vh;
      margin: 0;
      font-family: 'Press Start 2P', 'Segoe UI', Arial, sans-serif;
      background: var(--bg, linear-gradient(135deg, #66b5ff 0%, #3863ff 100%));
      transition: background 0.4s;
      margin: 0;
      font-size: 1rem;
      color: #222;
      font-weight: 600;
      /* mimic current.com logo style */
      cursor: default;
    }

    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
      box-sizing: border-box;
      padding: 20px;
    }

    .card {
      background: var(--container-bg, rgba(255, 255, 255, 0.85));
      color: var(--text-color, #222);
      border: 2px solid var(--container-border, rgba(255, 255, 255, 0.3));
      padding: 30px 40px;
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      max-width: 95vw; 
      box-sizing: border-box;
    }

    h1 {
      margin-bottom: 10px;
      color: var(--menu, #222);
      letter-spacing: 2px;
      text-shadow: 0 2px 8px #acb6e5;
      font-family: 'Press Start 2P', 'Segoe UI', Arial, sans-serif;
      font-size: 2em;
    }

    .touch-btn {
      width: 48px;
      box-shadow: 0 2px 8px #acb6e5;
      cursor: pointer;
      transform: scale(0.95);
    }

    #gameCanvas {
      background: #f7fffe;
      box-shadow: 0 8px 32px 0 rgba(44,62,80,0.2);
      border: 4px solid #6c7a89;
      display: block;
      margin: 0 auto;
      touch-action: none;
      transition: background 0.4s;
      max-width: 100%;
      height: auto;
    }

    .score-board {
      font-size: 1.5em;
      color: var(--menu, #222);
      font-weight: bold;
      letter-spacing: 1px;
      padding: 8px 24px;
      background: rgba(255,255,255,0.7);
      border-radius: 18px;
      box-shadow: 0 2px 8px #acb6e5;
      transition: color 0.4s;
    }

    .game-over {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(44,62,80,0.78);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 999;
      color: #fff;
      font-size: 2em;
      border-radius: 0;
      animation: fadeIn 0.5s;
    }

    .game-over button {
      margin-top: 24px;
      padding: 12px 32px;
      font-size: 1em;
      border: none;
      border-radius: 18px;
  background: linear-gradient(135deg, #4f8edc 0%, #27c5ff 100%);
      color: #222;
      font-weight: bold;
      box-shadow: 0 2px 8px #acb6e5;
      cursor: pointer;
      transition: background 0.2s;
    }

    .game-over button:hover {
      background: linear-gradient(135deg, #FF2222 0%, #FF5555 50%, #FF7777 100%);
      box-shadow: 0 0 15px #FF0000, 0 2px 8px rgba(255, 0, 0, 0.5);
      text-shadow: 0 0 8px #FF0000;
      transform: translateY(-2px);
    }

    .game-over button:hover {
      background: linear-gradient(135deg, #FF2222 0%, #FF5555 50%, #FF7777 100%);
    }

    @keyframes fadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    @media (max-width: 700px) {
      .card {
        padding: 20px;
        border-radius: 15px;
      }
      .game-over {
        font-size: 1.2em;
        border-radius: 0;
        padding: 0;
      }
    }

    /* Intro screen overlay */
    .intro-screen {
      position: fixed !important;
      top: 0 !important; 
      left: 0 !important; 
      right: 0 !important; 
      bottom: 0 !important;
      background: #000000;
      display: flex !important;
      flex-direction: column !important;
      align-items: center !important;
      justify-content: center !important;
      color: #fff;
      z-index: 1000;
      overflow: hidden;
      padding: 20px;
      font-family: 'Press Start 2P', monospace;
      height: 100vh !important;
      width: 100vw !important;
    }
    
    .intro-screen::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: 
        repeating-linear-gradient(90deg, 
          transparent 0px, 
          transparent 49px, 
          rgba(255, 0, 255, 0.3) 50px, 
          rgba(255, 0, 255, 0.3) 51px),
        repeating-linear-gradient(0deg, 
          transparent 0px, 
          transparent 49px, 
          rgba(255, 0, 255, 0.3) 50px, 
          rgba(255, 0, 255, 0.3) 51px),
        repeating-linear-gradient(45deg, 
          transparent 0px, 
          transparent 98px, 
          rgba(255, 0, 255, 0.1) 100px, 
          rgba(255, 0, 255, 0.1) 102px),
        repeating-linear-gradient(-45deg, 
          transparent 0px, 
          transparent 98px, 
          rgba(255, 0, 255, 0.1) 100px, 
          rgba(255, 0, 255, 0.1) 102px);
      pointer-events: none;
      animation: retroGrid 10s linear infinite;
    }
    
    @keyframes retroGrid {
      0% { transform: translate(0, 0); }
      100% { transform: translate(50px, 50px); }
    }
    
    .intro-container {
      max-width: 800px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 30px;
      position: relative;
      z-index: 2;
      text-align: center;
    }
    
    .intro-screen h1 {
      font-size: 2.5em;
      margin: 60px 0 20px 0;
      text-align: center;
      color: #FFD700;
      letter-spacing: 3px;
      text-shadow: 
        0 0 20px #FFD700,
        0 0 40px #FFA500,
        0 0 60px #FF8C00,
        2px 2px 0px #B8860B,
        4px 4px 0px #8B7500;
      animation: arcadeGlow 2s ease-in-out infinite alternate;
    }
    
    @keyframes arcadeGlow {
      0% { 
        text-shadow: 
          0 0 20px #FFD700,
          0 0 40px #FFA500,
          0 0 60px #FF8C00,
          2px 2px 0px #B8860B,
          4px 4px 0px #8B7500;
      }
      100% { 
        text-shadow: 
          0 0 30px #FFD700,
          0 0 50px #FFA500,
          0 0 70px #FF8C00,
          0 0 90px #FFD700,
          2px 2px 0px #B8860B,
          4px 4px 0px #8B7500;
      }
    }
    
    .intro-subtitle {
      text-align: center;
      font-size: 1em;
      color: #FFD700;
      margin: 0 0 20px 0;
      font-weight: bold;
      letter-spacing: 3px;
      text-shadow: 0 0 15px #FFD700, 0 0 25px #FFA500;
      animation: arcadeBlink 1.5s ease-in-out infinite;
    }
    
    @keyframes arcadeBlink {
      0%, 50% { 
        opacity: 1; 
        text-shadow: 0 0 15px #FFD700, 0 0 25px #FFA500;
      }
      51%, 100% { 
        opacity: 0.7; 
        text-shadow: 0 0 10px #FFD700;
      }
    }
    
    .menu-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      margin: 30px 0;
      padding: 25px;
      border: 2px solid #FFD700;
      border-radius: 12px;
      background: rgba(255, 215, 0, 0.08);
      box-shadow: 0 0 25px rgba(255, 215, 0, 0.4);
    }
    
    .menu-item {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1em;
      color: #FFD700;
      cursor: pointer;
      transition: all 0.3s ease;
      padding: 12px 30px;
      letter-spacing: 2px;
      text-shadow: 0 0 10px #FFD700;
      width: 300px;
      text-align: center;
      border-radius: 8px;
      position: relative;
      margin: 0 auto;
    }
    
    .menu-item.active {
      color: #00FF00;
      background: rgba(0, 255, 0, 0.1);
      text-shadow: 
        0 0 15px #00FF00,
        0 0 25px #00FF00,
        0 0 35px #00FF00;
      transform: scale(1.05);
      border: 1px solid #00FF00;
    }
    
    .menu-item.active .menu-arrow {
      color: #00FF00;
      text-shadow: 
        0 0 15px #00FF00,
        0 0 25px #00FF00;
      animation: arcadeArrow 1s ease-in-out infinite;
    }
    
    .menu-arrow {
      font-size: 1em;
      opacity: 0;
      transition: opacity 0.3s ease;
      margin-right: 10px;
    }
    
    .menu-item.active .menu-arrow {
      opacity: 1;
    }
    
    @keyframes arcadeArrow {
      0%, 100% { 
        transform: translateX(0px);
        text-shadow: 0 0 15px #00FF00, 0 0 25px #00FF00;
      }
      50% { 
        transform: translateX(10px);
        text-shadow: 0 0 20px #00FF00, 0 0 35px #00FF00, 0 0 45px #00FF00;
      }
    }
    
    .controls-hint {
      margin-top: 30px;
      position: relative;
    }
    
    .controls-hint p {
      font-size: 0.7em;
      color: #FFD700;
      margin: 0;
      letter-spacing: 2px;
      text-shadow: 0 0 10px #FFD700, 0 0 20px #FFA500;
      opacity: 0.9;
      animation: arcadePulse 2s ease-in-out infinite;
    }
    
    @keyframes arcadePulse {
      0%, 100% { 
        opacity: 0.7;
        text-shadow: 0 0 10px #FFD700, 0 0 20px #FFA500;
      }
      50% { 
        opacity: 1;
        text-shadow: 0 0 15px #FFD700, 0 0 25px #FFA500, 0 0 35px #FF8C00;
      }
    }
    
    /* Add credits at bottom */
    .intro-screen .credits {
      position: absolute;
      bottom: 20px;
      left: 30px;
      color: #FFD700;
      font-size: 0.6em;
      letter-spacing: 2px;
      text-shadow: 0 0 10px #FFD700;
    }
    
    /* Remove old button styles */
    .intro-buttons {
      display: none;
    }
    
    /* Instructions Overlay */
    #instructionsContent {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #000000;
      background-image: 
        linear-gradient(rgba(255, 0, 255, 0.2) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 0, 255, 0.2) 1px, transparent 1px);
      background-size: 20px 20px;
      z-index: 1001;
      overflow-y: auto;
      padding: 20px;
      display: none;
    }
    
    #instructionsContent.show {
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }
    
    .instructions-close-btn {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(255, 215, 0, 0.2);
      border: 2px solid #FFD700;
      color: #FFD700;
      font-size: 1.5em;
      width: 50px;
      height: 50px;
      border-radius: 8px;
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      z-index: 1002;
      text-shadow: 0 0 10px #FFD700;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
      font-family: 'Press Start 2P', monospace;
    }
    
    .instructions-close-btn:hover {
      background: rgba(0, 255, 0, 0.3);
      border-color: #00FF00;
      color: #00FF00;
      transform: scale(1.1);
      box-shadow: 0 0 30px rgba(0, 255, 0, 0.8);
      text-shadow: 0 0 15px #00FF00;
    }
    
    .intro-screen button {
      padding: 15px 35px;
      font-size: 1.1em;
      border: none;
      border-radius: 50px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      cursor: pointer;
      box-shadow: 
        0 8px 25px rgba(102, 126, 234, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      position: relative;
      overflow: hidden;
    }
    
    .intro-screen button::before {
      content: '';
      position: absolute;
      top: 0; left: -100%;
      width: 100%; height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }
    
    .intro-screen button:hover::before {
      left: 100%;
    }
    
    .intro-screen button:hover {
      transform: translateY(-3px);
      box-shadow: 
        0 12px 35px rgba(102, 126, 234, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }
    
    .intro-screen button:active {
      transform: translateY(-1px);
    }
    
    .intro-screen button#startBtn {
      background: linear-gradient(135deg, #4fc3f7 0%, #29b6f6 50%, #03a9f4 100%);
      box-shadow: 
        0 8px 25px rgba(79, 195, 247, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }
    
    .intro-screen button#startBtn:hover {
      box-shadow: 
        0 12px 35px rgba(79, 195, 247, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }
    
    .instructions-section {
      background: rgba(255, 0, 255, 0.1);
      border-radius: 8px;
      padding: 30px;
      margin: 20px 0;
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 215, 0, 0.3);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
    }
    
    .instructions-section h2 {
      color: #FFD700;
      margin-top: 0;
      margin-bottom: 20px;
      font-size: 1.6em;
      font-weight: 600;
      text-shadow: 0 0 10px #FFD700;
      font-family: 'Press Start 2P', monospace;
    }
    
    .instructions-section h3 {
      color: #00FF00;
      margin-top: 25px;
      margin-bottom: 15px;
      font-size: 1.2em;
      font-weight: 500;
      text-shadow: 0 0 8px #00FF00;
      font-family: 'Press Start 2P', monospace;
    }
    
    .instructions-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }
    
    .instruction-item {
      background: rgba(0, 255, 0, 0.1);
      padding: 20px;
      border-radius: 8px;
      border-left: 4px solid #00FF00;
      backdrop-filter: blur(5px);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      border: 1px solid rgba(255, 0, 255, 0.2);
    }
    
    .instruction-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 25px rgba(255, 0, 255, 0.5);
      border-color: #FF00FF;
    }
    
    .instruction-item h4 {
      color: #FFD700;
      margin: 0 0 10px 0;
      font-size: 1.1em;
      font-weight: 600;
      text-shadow: 0 0 8px #FFD700;
      font-family: 'Press Start 2P', monospace;
    }
    
    .instruction-item p {
      margin: 8px 0;
      line-height: 1.5;
      font-size: 0.95em;
      color: rgba(255, 255, 255, 0.9);
    }
    
    .controls-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin: 15px 0;
    }
    
    .control-item {
      background: linear-gradient(135deg, rgba(51, 170, 255, 0.1), rgba(0, 153, 204, 0.05));
      padding: 12px 16px;
      border-radius: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      backdrop-filter: blur(5px);
      transition: transform 0.2s ease;
      border: 1px solid rgba(51, 170, 255, 0.2);
      color: rgba(255, 255, 255, 0.9);
    }
    
    .control-item:hover {
      transform: scale(1.02);
      border-color: #33aaff;
      box-shadow: 0 4px 15px rgba(51, 170, 255, 0.2);
    }
    
    .control-key {
      background: linear-gradient(135deg, #003366, #006699);
      padding: 6px 12px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      color: #66ccff;
      box-shadow: 0 2px 8px rgba(51, 170, 255, 0.3);
      border: 1px solid #33aaff;
      text-shadow: 0 0 5px #66ccff;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .intro-screen h1 {
        font-size: 2.5em;
        margin: 20px 0 15px 0;
      }
      
      .intro-subtitle {
        font-size: 1em;
        margin-bottom: 20px;
      }
      
      .intro-buttons {
        flex-direction: column;
        align-items: center;
        gap: 15px;
      }
      
      .intro-screen button {
        width: 80%;
        max-width: 300px;
      }
      
      .instructions-grid {
        grid-template-columns: 1fr;
      }
      
      .controls-list {
        grid-template-columns: 1fr;
      }
      
      .instructions-section {
        padding: 20px;
      }
    }
    
    @media (max-width: 480px) {
      .intro-screen h1 {
        font-size: 2em;
      }
      
      .intro-screen {
        padding: 15px;
      }
      
      .instructions-section {
        padding: 15px;
      }
    }
        @media (max-width: 480px) {
          .card { padding: 15px; }
          .score-board, .score-board ~ .score-board { font-size: 1em; padding: 6px 12px; }
        }

    /* Modal / panel styles for history & achievements */
    .panel-modal {
      position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.6); z-index: 2000;
    }
    .panel-modal .panel {
      background: #fff; color:#222; padding:18px; border-radius:12px; width:90%; max-width:720px; max-height:80vh; overflow:auto;
    }
    .theme-badge { display:inline-block; padding:6px 10px; border-radius:10px; margin:6px; cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,0.12); }
    .small-btn { padding:6px 10px; border-radius:8px; cursor:pointer; border:none; background:#e6e6e6; margin-left:6px; }
    /* obstacle tile */
    .obstacle { background:#333; }

.achievements-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 15px;
  margin-top: 20px;
}

.achievement {
  display: flex;
  align-items: center;
  padding: 15px;
  border-radius: 10px;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.1);
}

.achievement.unlocked {
  background: rgba(76, 175, 80, 0.2);
  border-color: rgba(76, 175, 80, 0.3);
}

.achievement.locked {
  opacity: 0.6;
}

.achievement-icon {
  font-size: 2rem;
  margin-right: 15px;
}

.achievement-info h4 {
  margin: 0 0 5px 0;
  color: #fff;
}

.achievement-info p {
  margin: 0;
  color: #ccc;
  font-size: 0.9rem;
}

.stats-overview {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
  margin: 20px 0;
}

.stat-item {
  padding: 15px;
  background: rgba(255,255,255,0.05);
  border-radius: 8px;
  text-align: center;
  color: #fff;
}

.history-list {
  max-height: 400px;
  overflow-y: auto;
}

.history-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 15px;
  margin: 10px 0;
  background: rgba(255,255,255,0.03);
  border-radius: 8px;
  border-left: 4px solid #4CAF50;
}

.game-info {
  display: flex;
  gap: 20px;
}

.game-score {
  font-weight: bold;
  color: #4CAF50;
}

.game-foods {
  color: #2196F3;
}

.game-mode {
  color: #FF9800;
}

.game-date {
  color: #ccc;
  font-size: 0.9rem;
}

/* Style for clear games button */
.clear-btn {
  background: rgba(220, 53, 69, 0.9) !important;
  color: #ffffff !important;
  border: 1px solid rgba(220, 53, 69, 0.8) !important;
}
.clear-btn:hover {
  background: rgba(220, 53, 69, 1) !important;
  transform: translateY(-1px);
}

  </style>
</head>
<body class="theme-arcade">
  <!-- Intro Screen -->
  <div id="introScreen" class="intro-screen">
    <!-- Arcade Header -->
    <div style="position: absolute; top: 30px; left: 30px; right: 30px; color: #FFD700; font-size: 0.7em; letter-spacing: 2px; text-shadow: 0 0 10px #FFD700; z-index: 3; display: grid; grid-template-columns: 1fr 2fr 1fr; grid-template-rows: repeat(2, auto); align-items: center; justify-items: center; gap: 10px;">
      <div>LENGTH</div>
      <div style="font-size: 1.2em;">HIGH SCORE</div>
      <div>GAMES</div>
      <div id="snakeLength">0003</div>
      <div id="arcadeHighScore" style="font-size: 1.5em; letter-spacing: 3px;">0000000000</div>
      <div id="totalGames">000</div>
    </div>
    
    <div class="intro-container">
      <h1>START NEW GAME</h1>
      <p class="intro-subtitle">â–º 1 PLAYER</p>
      
      <div class="menu-options">
        <div class="menu-item active" id="startOption">
          <span class="menu-arrow">â–º</span>
          <span>START GAME</span>
        </div>
        <div class="menu-item" id="shopOption">
          <span class="menu-arrow">â–º</span>
          <span><img src="coin.gif" alt="Coin" style="height:16px;width:16px;vertical-align:middle;filter:drop-shadow(0 0 4px #FFD700);" onerror="console.error('Failed to load coin.gif in shop menu'); this.style.display='none';" onload="console.log('âœ… Shop menu coin.gif loaded successfully');">SHOP</span>
        </div>
        <div class="menu-item" id="customizeOption">
          <span class="menu-arrow">â–º</span>
          <span>CUSTOMIZE</span>
        </div>
        <div class="menu-item" id="instructionsOption">
          <span class="menu-arrow">â–º</span>
          <span><img src="book.gif" alt="Book" style="height:16px;width:16px;vertical-align:middle;filter:drop-shadow(0 0 4px #00FFFF);" onerror="console.error('Failed to load book.gif in instructions menu'); this.style.display='none';" onload="console.log('âœ… Instructions menu book.gif loaded successfully');">INSTRUCTIONS</span>
        </div>
        <div class="menu-item" id="leaderboardOption">
          <span class="menu-arrow">â–º</span>
          <span>LEADERBOARD</span>
        </div>
      </div>
      
      <div class="controls-hint">
        <p>USE â†‘â†“ ARROWS TO SELECT â€¢ SPACEBAR TO CONFIRM</p>
      </div>
    </div>
    <div class="credits">CREDIT 01</div>
  </div>
      </div>
    </div>
  </div>
  
  <!-- Instructions Overlay -->
  <div id="instructionsContent" style="display: none;">
    <button class="instructions-close-btn" onclick="toggleInstructions()">âœ•</button>
    <div class="intro-container" style="max-width: 900px; width: 100%; padding: 40px 20px; text-align: center; margin: 0 auto; align-self: flex-start; margin-top: 40px;">
      <h1 style="text-align: center; font-size: 2.5em; margin-bottom: 40px; background: linear-gradient(45deg, #FFD700, #FF00FF, #00FF00, #FFD700); background-size: 300% 300%; -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-shadow: 0 0 20px #FFD700, 0 0 40px #FF00FF; letter-spacing: 3px; animation: arcadeTitle 2s ease-in-out infinite; font-family: 'Press Start 2P', monospace;">ðŸ“– GAME INSTRUCTIONS</h1>
        <div class="instructions-section">
          <h2>ðŸŽ® How to Play</h2>
          <p>Control your snake to eat food and grow longer while avoiding walls and your own tail. The goal is to achieve the highest score possible!</p>
          
          <h3>Controls</h3>
          <div class="controls-list">
            <div class="control-item">
              <span>Move Up</span>
              <span class="control-key">â†‘ or W</span>
            </div>
            <div class="control-item">
              <span>Move Down</span>
              <span class="control-key">â†“ or S</span>
            </div>
            <div class="control-item">
              <span>Move Left</span>
              <span class="control-key">â† or A</span>
            </div>
            <div class="control-item">
              <span>Move Right</span>
              <span class="control-key">â†’ or D</span>
            </div>
            <div class="control-item">
              <span>Pause/Resume</span>
              <span class="control-key">Space</span>
            </div>
          </div>
        </div>

        <div class="instructions-section">
          <h2>ðŸŽ¨ Themes & Skins</h2>
          <p><strong>Important:</strong> For the best visual experience, match your snake skin with the corresponding theme!</p>
          
          <div class="instructions-grid">
            <div class="instruction-item">
              <h4>ðŸŸ¢ Classic Snake</h4>
              <p><strong>Theme:</strong> Classic</p>
              <p><strong>Skin:</strong> Classic Snake</p>
              <p>Retro green snake with 3D effect on black grid. Perfect for nostalgic gameplay!</p>
            </div>
            
            <div class="instruction-item">
              <h4>ðŸŸ¡ Pac-Man</h4>
              <p><strong>Theme:</strong> Pac-Man</p>
              <p><strong>Skin:</strong> Pac-Man</p>
              <p>Yellow Pac-Man with animated mouth chomping through blue maze. Eat white pellets!</p>
            </div>
            
            <div class="instruction-item">
              <h4> Neon Grid</h4>
              <p><strong>Theme:</strong> Neon Grid</p>
              <p><strong>Skin:</strong> Neon Grid</p>
              <p>Glowing cyber snake with neon effects. Futuristic grid-based gameplay!</p>
            </div>
            
            <div class="instruction-item">
              <h4>ðŸ’œ Arcade</h4>
              <p><strong>Theme:</strong> Arcade</p>
              <p><strong>Skin:</strong> Arcade</p>
              <p>Colorful gradient snake with glow effects. Classic arcade cabinet style!</p>
            </div>
            
            <div class="instruction-item">
              <h4>ðŸŒˆ Rainbow</h4>
              <p><strong>Works with any theme!</strong></p>
              <p>Animated rainbow colors that cycle continuously. Fun for any environment!</p>
            </div>
            
            <div class="instruction-item">
              <h4>â˜€ï¸ Daylight Snake</h4>
              <p><strong>Perfect for Day theme!</strong></p>
              <p>Warm, sunny colors that shift like sunlight throughout the day. Golden and amber tones!</p>
            </div>
            
            <div class="instruction-item">
              <h4>âœ¨ Starlight Snake</h4>
              <p><strong>Perfect for Night theme!</strong></p>
              <p>Twinkling star-like effect with cool blue and purple night colors. Mesmerizing glow!</p>
            </div>
          </div>
        </div>

        <div class="instructions-section">
          <h2>âš¡ Power-ups</h2>
          <div class="instructions-grid">
            <div class="instruction-item">
              <h4>ðŸŽ Regular Food</h4>
              <p><strong>Points:</strong> 25</p>
              <p>Grows your snake by one segment. Appearance varies by theme (dots, squares, gems, etc.)</p>
            </div>
            
            <div class="instruction-item">
              <h4>â­ 2x Points Power-up</h4>
              <p><strong>Points:</strong> 50 + 2x multiplier</p>
              <p><strong>Duration:</strong> 10 seconds</p>
              <p>Doubles all points for 10 seconds. Shows as large flashing items.</p>
            </div>
            
            <div class="instruction-item">
              <h4>âš¡ Speed Boost</h4>
              <p><strong>Points:</strong> 40</p>
              <p><strong>Effect:</strong> 1.25x speed for 8 seconds</p>
              <p>Makes you move 25% faster. Great for quick navigation!</p>
            </div>
          </div>
          
          <p><strong>Spawn Rates:</strong> Regular food (84%), 2x Points (8%), Speed Boost (8%)</p>
        </div>

        <div class="instructions-section">
          <h2>ðŸ† Game Modes</h2>
          <div class="instructions-grid">
            <div class="instruction-item">
              <h4>Classic Mode</h4>
              <p>Traditional snake gameplay. Eat food, grow longer, avoid walls and yourself.</p>
            </div>
            
            <div class="instruction-item">
              <h4>Time Attack</h4>
              <p>Race against the clock! Score as many points as possible before time runs out.</p>
            </div>
            
            <div class="instruction-item">
              <h4>Hard Mode</h4>
              <p>Faster starting speed and more challenging gameplay for experienced players.</p>
            </div>
          </div>
        </div>

        <div class="instructions-section">
          <h2>ðŸ’¡ Pro Tips</h2>
          <div class="instruction-item">
            <h4>Strategy Tips</h4>
            <p>â€¢ Plan your path ahead to avoid getting trapped</p>
            <p>â€¢ Use walls to your advantage for tight turns</p>
            <p>â€¢ Save speed boosts for when you need quick escapes</p>
            <p>â€¢ 2x point multipliers stack with regular food eating</p>
            <p>â€¢ Each theme offers a unique visual experience - try them all!</p>
          </div>
        </div>

        <div class="instructions-section">
          <h2>ðŸª™ Ways to Earn Coins</h2>
          <p>Coins let you unlock cosmetic skins, trails, and other customizations in the Shop!</p>
          
          <div class="instructions-grid">
            <div class="instruction-item">
              <h4>ðŸŽ® Play Games</h4>
              <p><strong>Reward:</strong> +1 coin per 50 points</p>
              <p>The more you score, the more coins you earn!</p>
            </div>
            
            <div class="instruction-item">
              <h4>ðŸŽ¯ Score Milestones</h4>
              <p><strong>Rewards:</strong> +10 to +500 coins</p>
              <p>Bonus coins for reaching 100, 250, 500, 1000+ points</p>
            </div>
            
            <div class="instruction-item">
              <h4>â° Active Playtime</h4>
              <p><strong>Reward:</strong> +5 coins every 2 minutes</p>
              <p>Stay engaged and get rewarded for your time!</p>
            </div>
            
            <div class="instruction-item">
              <h4>ðŸ Complete Rounds</h4>
              <p><strong>Reward:</strong> +20 coins</p>
              <p>Finish games that last 30+ seconds</p>
            </div>
            
            <div class="instruction-item">
              <h4>ðŸ† Unlock Achievements</h4>
              <p><strong>Rewards:</strong> +25 to +500 coins</p>
              <p>One-time rewards for reaching milestones</p>
            </div>
            
            <div class="instruction-item">
              <h4>ðŸ—“ï¸ Daily Login</h4>
              <p><strong>Rewards:</strong> +50 to +300 coins</p>
              <p>Streak bonuses for consecutive days!</p>
            </div>
            
            <div class="instruction-item">
              <h4>ðŸŽ¯ Daily Challenges</h4>
              <p><strong>Rewards:</strong> +75 to +150 coins</p>
              <p>Complete 2 random challenges each day</p>
            </div>
            
            <div class="instruction-item">
              <h4>ðŸ“º Watch Ads</h4>
              <p><strong>Reward:</strong> +100 coins</p>
              <p>Maximum 5 ads per day with 5-minute cooldowns</p>
            </div>
          </div>
          
          <div class="instruction-item" style="margin-top: 20px;">
            <p style="text-align: center; color: #66ccff; font-weight: bold;">ðŸ’° Multiple ways to earn - Keep playing to unlock customizations!</p>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="navbar">
    <div class="navbar-brand">
      <img src="coin.gif" alt="Coin" style="height:28px;width:28px;margin-right:8px;vertical-align:middle;filter:drop-shadow(0 0 8px #FFD700);" onerror="console.error('Failed to load coin.gif in navbar'); this.style.display='none';" onload="console.log('âœ… Navbar coin.gif loaded successfully');">
      <h2>ðŸ Pythonix</h2>
    </div>
    <div class="navbar-controls">
      <!-- Player Settings Group -->
      <div class="control-group">
        <div class="group-title">Player</div>
        <div class="control-row">
          <label>Name:
            <input type="text" id="playerName" placeholder="Enter name" maxlength="20">
          </label>
        </div>
      </div>

      <!-- Snake Customization Group -->
      <div class="control-group">
        <div class="group-title">Settings</div>
        <div class="control-row">
          <label>Volume:
            <input type="range" id="volumeSlider" min="0" max="100" step="1" value="50">
            <span id="volumeValue">50%</span>
          </label>
        </div>
      </div>

      <!-- Quick Access Group -->
      <div class="control-group">
        <div class="group-title">Quick Access</div>
        <div class="control-row">
          <label>Mode:
            <select id="gameMode">
              <option value="classic">Classic</option>
              <option value="time">Time Attack</option>
              <option value="hard">Hard Mode</option>
            </select>
          </label>
          <button class="small-btn" onclick="showCustomization()" style="background: linear-gradient(45deg, #9C27B0, #673AB7);">ðŸŽ¨ Customize</button>
        </div>
      </div>

      <!-- Stats and Actions Group -->
      <div class="control-group">
        <div class="group-title">Stats & Actions</div>
        <div class="stats-row">
          <span class="stat-item" id="highScoreNav">High Score: 0</span>
          <span class="stat-item" id="foodsEatenNav">Foods Eaten: 0</span>
          <span class="stat-item" id="multiplierNav" style="display:none;">x2 (0s)</span>
          <label id="timeAttackDisplay" style="display:none;">Time:
            <span id="timeLeft">--</span>s
          </label>
        </div>
        <div class="action-buttons">
          <button id="backToMenu" class="small-btn" onclick="returnToStartScreen()" style="background: linear-gradient(45deg, #ff6b6b, #ee5a52);">ðŸ  Menu</button>
          <button id="showHistory" class="small-btn">History</button>
          <button id="showAchievements" class="small-btn">Achievements</button>
          <button id="clearGames" class="small-btn clear-btn">Clear Games</button>
          <div class="coin-display" id="navCoinDisplay">ðŸª™ 0</div>
        </div>
      </div>
    </div>
  </div>
  <div class="container">
    <div class="card">
      <h1>Pythonix</h1>
      <div class="score-board" id="scoreBoard">Score: 0</div>
      <div style="position:relative;">
  <canvas id="gameCanvas" width="480" height="480"></canvas>
        <div id="gameOverScreen" class="game-over" style="display:none;">
          <h2 style="font-family: 'Press Start 2P', monospace; color: #FF0000; font-size: 2.5em; margin-bottom: 20px; text-shadow: 0 0 10px #FF0000, 0 0 20px #FF4444, 0 0 30px #FF6666;">GAME OVER</h2>
          <span id="gameOverText" style="font-family: 'Press Start 2P', monospace; font-size: 1.2em; margin-bottom: 30px; color: #fff;"></span>
          <button onclick="restartGame()" style="font-family: 'Press Start 2P', monospace; margin-top: 24px; padding: 12px 32px; font-size: 1em; border: none; border-radius: 18px; background: linear-gradient(135deg, #FF0000 0%, #FF4444 50%, #FF6666 100%); color: #fff; font-weight: bold; box-shadow: 0 0 10px #FF0000, 0 2px 8px rgba(255, 0, 0, 0.3); cursor: pointer; transition: all 0.2s; text-shadow: 0 0 5px #FF0000;">RESTART</button>
        </div>
      </div>
      <div style="margin-top:18px; text-align: center;">
        <span style="color:#666;font-size:1.2em;font-style:italic;text-shadow:0 0 10px rgba(102,204,255,0.5); font-weight: bold;">
          ðŸ "Grow long, grow strong, become legendary" ðŸ
        </span>
      </div>
    </div>
  </div>
  <!-- Achievements Modal -->
<div id="achievementsModal" class="modal" style="display: none;">
  <div class="modal-content">
    <span class="close" onclick="document.getElementById('achievementsModal').style.display='none'">&times;</span>
    <h2>ðŸ† Achievements</h2>
    <div id="achievementsContent">Loading achievements...</div>
  </div>
</div>

<!-- Game History Modal -->
<div id="historyModal" class="modal" style="display: none;">
  <div class="modal-content">
    <span class="close" onclick="document.getElementById('historyModal').style.display='none'">&times;</span>
    <h2>ðŸ“ˆ Game History</h2>
    <div id="historyContent">Loading history...</div>
  </div>
</div>

<!-- Shop Modal -->
<div id="shopModal" class="shop-modal">
  <div class="shop-content">
    <button class="close-shop" onclick="closeShop()">&times;</button>
    
    <div class="shop-header">
      <h2 class="shop-title">ðŸ PYTHONIX SHOP ðŸ</h2>
      <div class="coin-display" id="shopCoinDisplay">ðŸª™ 0</div>
    </div>
    
    <div class="shop-tabs">
      <button class="shop-tab active" onclick="showShopTab('skins')">ðŸ Snake Skins</button>
      <button class="shop-tab" onclick="showShopTab('trails')">âœ¨ Trail Effects</button>
      <button class="shop-tab" onclick="showShopTab('powerup')">âš¡ Power-ups</button>
      <button class="shop-tab" onclick="showShopTab('utility')">ðŸ› ï¸ Utilities</button>
      <button class="shop-tab" onclick="showShopTab('badges')">ðŸ† Badges</button>
      <button class="shop-tab" onclick="showShopTab('special')">ðŸ’« Special</button>
    </div>
    
    <!-- Moved earning options to top as smaller buttons -->
    <div style="text-align: center; margin-bottom: 20px; border-top: 1px solid rgba(255, 215, 0, 0.3); padding-top: 15px;">
      <button class="shop-button" onclick="watchAdForCoins()" style="margin: 5px; padding: 8px 12px; font-size: 9px; background: linear-gradient(45deg, #FF6B6B, #FF8E8E);">
        ðŸ“º Watch Ad (+100)
      </button>
      <button class="shop-button" onclick="showDailyChallenges()" style="margin: 5px; padding: 8px 12px; font-size: 9px; background: linear-gradient(45deg, #4ECDC4, #45B7B8);">
        ðŸŽ¯ Daily Challenges
      </button>
    </div>
    
    <div id="shopItems" class="shop-grid">
      <!-- Items will be populated by JavaScript -->
    </div>
  </div>
  
  <!-- Removed the bottom section that was taking up space -->
</div>

<!-- Daily Challenges Modal -->
<div id="challengesModal" class="shop-modal">
  <div class="shop-content">
    <button class="close-shop" onclick="closeChallenges()">&times;</button>
    
    <div class="shop-header">
      <h2 class="shop-title">ðŸŽ¯ DAILY CHALLENGES ðŸŽ¯</h2>
      <div class="coin-display" id="challengesCoinDisplay">ðŸª™ 0</div>
    </div>
    
    <div id="challengesContent" style="max-width: 600px; margin: 0 auto;">
      <!-- Challenges will be populated by JavaScript -->
    </div>
    
    <div style="text-align: center; margin-top: 20px;">
      <button class="shop-button" onclick="closeChallenges()" style="background: linear-gradient(45deg, #666, #888);">
        Close
      </button>
    </div>
    
    <div style="text-align: center; margin-top: 15px; color: #ccc; font-size: 12px;">
      â° Challenges reset daily at midnight â€¢ Complete them for bonus coins!
    </div>
  </div>
</div>

<!-- Customization Modal -->
<div id="customizeModal" class="shop-modal">
  <div class="shop-content">
    <button class="close-shop" onclick="closeCustomization()">&times;</button>
    
    <div class="shop-header">
      <h2 class="shop-title">ðŸŽ¨ CUSTOMIZATION ðŸŽ¨</h2>
      <div class="coin-display" id="customizeCoinDisplay">ðŸª™ 0</div>
    </div>
    
    <div id="customizeContent" style="max-width: 700px; margin: 0 auto; padding: 20px;">
      
      <!-- Snake Customization -->
      <div class="customize-section">
        <h3 style="color: #66ccff; margin-bottom: 15px;">ðŸ Snake Appearance</h3>
        <div class="customize-row">
          <label>Emoji:
            <input type="text" id="emojiPicker" value="ðŸ" maxlength="4" placeholder="ðŸ" title="Type or paste any emoji here!">
          </label>
          <label>Skin:
            <select id="customizeSkin">
              <option value="classic">Classic Snake</option>
              <option value="pacman">Pac-Man</option>
              <option value="neon">Neon Grid</option>
              <option value="arcade">Arcade</option>
              <option value="rainbow">Rainbow (animated)</option>
              <option value="forest">Forest Snake</option>
              <option value="sunset">Sunset Snake</option>
              <option value="ocean">Ocean Snake</option>
              <option value="gameboy">Game Boy Snake</option>
              <option value="daylight">Daylight Snake</option>
              <option value="starlight">Starlight Snake</option>
            </select>
          </label>
        </div>
      </div>
      
      <!-- Trail Effects -->
      <div class="customize-section">
        <h3 style="color: #66ccff; margin-bottom: 15px;">âœ¨ Trail Effects</h3>
        <div class="customize-row">
          <label>Trail Effect:
            <select id="customizeTrail">
              <option value="none">No Trail</option>
            </select>
          </label>
        </div>
      </div>
      
      <!-- Player Status -->
      <div class="customize-section">
        <h3 style="color: #66ccff; margin-bottom: 15px;">ðŸ† Player Status</h3>
        <div class="customize-row">
          <label>Badge:
            <select id="customizeBadge">
              <option value="none">No Badge</option>
            </select>
          </label>
        </div>
      </div>
      
      <!-- Game Settings -->
      <div class="customize-section">
        <h3 style="color: #66ccff; margin-bottom: 15px;">âš™ï¸ Game Settings</h3>
        <div class="customize-row">
          <label>Theme:
            <select id="customizeTheme">
              <option value="auto">Day/Night (Auto)</option>
              <option value="day">Day</option>
              <option value="night">Night</option>
              <option value="sunset">Sunset</option>
              <option value="ocean">Ocean</option>
              <option value="forest">Forest</option>
              <option value="classic">Classic Snake</option>
              <option value="pacman">Pac-Man Arcade</option>
              <option value="gameboy">Game Boy</option>
              <option value="neon">Neon Grid</option>
              <option value="arcade">Retro Arcade</option>
            </select>
          </label>
        </div>
      </div>
      
    </div>
    
    <div style="text-align: center; margin-top: 20px;">
      <button class="shop-button" onclick="closeCustomization()" style="background: linear-gradient(45deg, #666, #888);">
        Close
      </button>
    </div>
    
    <div style="text-align: center; margin-top: 15px; color: #ccc; font-size: 12px;">
      ðŸ’¡ Changes are saved automatically â€¢ Visit the shop to buy more customization options!
    </div>
  </div>
</div>

<!-- Hidden controls for customization modal -->
<div style="display: none;">
  <select id="snakeSkin">
    <option value="classic">Classic Snake</option>
    <option value="pacman">Pac-Man</option>
    <option value="neon">Neon Grid</option>
    <option value="arcade">Arcade</option>
    <option value="rainbow">Rainbow (animated)</option>
    <option value="daylight">Daylight Snake</option>
    <option value="starlight">Starlight Snake</option>
  </select>
  <select id="trailEffect">
    <option value="none">No Trail</option>
  </select>
  <select id="playerBadge">
    <option value="none">No Badge</option>
  </select>
  <input type="text" id="emojiPicker" value="ðŸ" maxlength="4">
</div>

<!-- Add modal CSS -->
<style>
.modal {
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.8);
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal-content {
  background: linear-gradient(135deg, #1a1a2e, #16213e);
  margin: auto;
  padding: 30px;
  border-radius: 15px;
  width: 80%;
  max-width: 800px;
  max-height: 80vh;
  overflow-y: auto;
  color: #fff;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
}

.close {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
  line-height: 1;
}

.close:hover {
  color: #fff;
}

.achievements-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 15px;
  margin-top: 20px;
}

.achievement {
  display: flex;
  align-items: center;
  padding: 15px;
  border-radius: 10px;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.1);
}

.achievement.unlocked {
  background: rgba(76, 175, 80, 0.2);
  border-color: rgba(76, 175, 80, 0.3);
}

.achievement.locked {
  opacity: 0.6;
}

.achievement-icon {
  font-size: 2rem;
  margin-right: 15px;
}

.achievement-info h4 {
  margin: 0 0 5px 0;
  color: #fff;
}

.achievement-info p {
  margin: 0;
  color: #ccc;
  font-size: 0.9rem;
}

.stats-overview {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
  margin: 20px 0;
}

.stat-item {
  padding: 15px;
  background: rgba(255,255,255,0.05);
  border-radius: 8px;
  text-align: center;
  color: #fff;
}

.history-list {
  max-height: 400px;
  overflow-y: auto;
}

.history-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 15px;
  margin: 10px 0;
  background: rgba(255,255,255,0.03);
  border-radius: 8px;
  border-left: 4px solid #4CAF50;
}

.game-info {
  display: flex;
  gap: 20px;
}

.game-score {
  font-weight: bold;
  color: #4CAF50;
}

.game-foods {
  color: #2196F3;
}

.game-mode {
  color: #FF9800;
}

.game-date {
  color: #ccc;
  font-size: 0.9rem;
}
</style>

<script>
// ===== PYTHONIX SHOP & CURRENCY SYSTEM =====

// Currency Management
function getCoins() {
  const coins = parseInt(localStorage.getItem('pythonixCoins') || '0');
  console.log('ðŸª™ getCoins() returning:', coins);
  return coins;
}

// Initialize coins if not set
function initializeCoins() {
  if (!localStorage.getItem('pythonixCoins')) {
    console.log('ðŸª™ Initializing coins to 0');
    localStorage.setItem('pythonixCoins', '0');
  }
}

function addCoins(amount, source = 'unknown') {
  const currentCoins = getCoins();
  const newAmount = currentCoins + amount;
  localStorage.setItem('pythonixCoins', newAmount.toString());
  
  // Analytics: Track coin sources
  logCoinSource(source, amount);
  
  updateCoinDisplay();
  console.log(`Added ${amount} coins from ${source}! Total: ${newAmount}`);
  return newAmount;
}

// Analytics: Log coin source usage
function logCoinSource(source, amount) {
  const analytics = JSON.parse(localStorage.getItem('pythonixCoinAnalytics') || '{}');
  const today = new Date().toDateString();
  
  if (!analytics[today]) {
    analytics[today] = {};
  }
  
  if (!analytics[today][source]) {
    analytics[today][source] = { count: 0, total: 0 };
  }
  
  analytics[today][source].count++;
  analytics[today][source].total += amount;
  
  localStorage.setItem('pythonixCoinAnalytics', JSON.stringify(analytics));
}

function spendCoins(amount) {
  const currentCoins = getCoins();
  if (currentCoins >= amount) {
    const newAmount = currentCoins - amount;
    localStorage.setItem('pythonixCoins', newAmount.toString());
    updateCoinDisplay();
    console.log(`Spent ${amount} coins! Remaining: ${newAmount}`);
    return true;
  }
  console.log(`Insufficient coins! Need ${amount}, have ${currentCoins}`);
  return false;
}

function updateCoinDisplay() {
  const coinElements = document.querySelectorAll('.coin-display');
  const coins = getCoins();
  console.log('ðŸª™ DEBUG: Updating coin display with:', coins, 'coins');
  console.log('ðŸª™ DEBUG: Found', coinElements.length, 'coin display elements');
  
  coinElements.forEach((el, index) => {
    if (el) {
      const oldText = el.textContent;
      el.textContent = `ðŸª™ ${coins}`;
      console.log(`ðŸª™ DEBUG: Updated coin display ${index} (${el.id || 'unnamed'}): "${oldText}" â†’ "${el.textContent}"`);
    } else {
      console.log(`ðŸª™ DEBUG: Coin display ${index} is null/undefined`);
    }
  });
  
  // Force a visual refresh
  coinElements.forEach(el => {
    if (el) {
      el.style.display = 'none';
      el.offsetHeight; // Trigger reflow
      el.style.display = '';
    }
  });
}

// Shop Items Database - Comprehensive and Accurate
const SHOP_ITEMS = {
  // === SNAKE SKINS === (Visual appearance changes)
  // Free Skins (always available)
  'skin_classic': { name: 'Classic Snake', price: 0, type: 'skin', description: 'Traditional green snake', free: true },
  'skin_neon': { name: 'Neon Snake', price: 0, type: 'skin', description: 'Electric blue glow effect', free: true },
  'skin_rainbow': { name: 'Rainbow Snake', price: 0, type: 'skin', description: 'Colorful rainbow pattern', free: true },
  'skin_retro': { name: 'Retro Snake', price: 0, type: 'skin', description: 'Old-school arcade style', free: true },
  'skin_pacman': { name: 'Pac-Man Snake', price: 0, type: 'skin', description: 'Arcade classic inspired', free: true },
  'skin_arcade': { name: 'Arcade Snake', price: 0, type: 'skin', description: 'Retro arcade with neon green blocks', free: true },
  
  // Theme-matching free skins
  'skin_retro': { name: 'Retro Snake', price: 0, type: 'skin', description: 'Old-school arcade style', free: true },
  
  // === TRAIL EFFECTS === (Visual effects that follow the snake)
  'none': { name: 'No Trail', price: 0, type: 'trail', description: 'Disable trail effects', free: true },
  'trail_fire': { name: 'Fire Trail', price: 200, type: 'trail', description: 'Blazing fire particles' },
  'trail_electricity': { name: 'Electric Trail', price: 250, type: 'trail', description: 'Lightning sparks' },
  'trail_vaporwave': { name: 'Vaporwave Trail', price: 300, type: 'trail', description: 'Retro neon glow' },
  'trail_laser': { name: 'Laser Trail', price: 300, type: 'trail', description: 'Sci-fi laser beam' },
  'trail_stardust': { name: 'Stardust Trail', price: 350, type: 'trail', description: 'Glittering star particles' },
  'trail_smoke': { name: 'Smoke Trail', price: 180, type: 'trail', description: 'Wispy smoke effect' },
  'trail_ice': { name: 'Ice Trail', price: 220, type: 'trail', description: 'Frozen ice crystals' },
  
  // === POWER-UPS === (Gameplay enhancements)
  'powerup_speed_boost': { name: 'Speed Boost', price: 50, type: 'powerup', description: 'Temporary speed increase for 30 seconds (consumable)' },
  'powerup_shield': { name: 'Shield', price: 75, type: 'powerup', description: 'Protect from collisions for 1 minute (consumable)' },
  'powerup_double_points': { name: 'Double Points', price: 100, type: 'powerup', description: '2x score for 30 seconds (consumable)' },
  'powerup_magnet': { name: 'Food Magnet', price: 80, type: 'powerup', description: 'Attract nearby food for 1 minute (consumable)' },
  'powerup_slow_time': { name: 'Slow Time', price: 120, type: 'powerup', description: 'Slow game speed for 30 seconds (consumable)' },
  
  // === UTILITIES === (Permanent game enhancements)
  'utility_continue': { name: 'Continue Token', price: 150, type: 'utility', description: 'Restart from death once per game' },
  'utility_lucky_food': { name: 'Lucky Food', price: 200, type: 'utility', description: 'Higher chance of special food spawns' },
  'utility_score_boost': { name: 'Score Multiplier', price: 400, type: 'utility', description: 'Permanent +10% score bonus' },
  'utility_statistics': { name: 'Advanced Stats', price: 250, type: 'utility', description: 'Detailed gameplay analytics and performance tracking' },
  
  // === BADGE TITLES === (Cosmetic status symbols)
  'badge_none': { name: 'No Badge', price: 0, type: 'badge', description: 'Disable badge display', free: true },
  'badge_master': { name: 'Snake Master', price: 800, type: 'badge', description: 'Elite player status badge' },
  'badge_synthwave': { name: 'Synthwave Legend', price: 600, type: 'badge', description: 'Retro gaming expert badge' },
  'badge_speedster': { name: 'Speed Demon', price: 500, type: 'badge', description: 'Fast reflexes champion badge' },
  'badge_collector': { name: 'Coin Collector', price: 400, type: 'badge', description: 'Earning master badge' },
  'badge_survivor': { name: 'Survivor', price: 700, type: 'badge', description: 'Endurance champion badge' },
  'badge_perfectionist': { name: 'Perfectionist', price: 900, type: 'badge', description: 'Flawless gameplay badge' },
  
  // === SPECIAL ITEMS === (Unique cosmetics and features)
  'special_arena_energy': { name: 'Arena Energy Border', price: 0, type: 'special', description: 'Dynamic reactive border effects', free: true },
  'special_combo_visuals': { name: 'Combo Chain Effects', price: 0, type: 'special', description: 'Flashy combo and chain visuals', free: true },
  'special_portal_food': { name: 'Portal Food Spawn', price: 0, type: 'special', description: 'Food appears through portal effects', free: true },
  'special_spawn_animation': { name: 'Epic Spawn Animation', price: 0, type: 'special', description: 'Cool snake materialization effect', free: true },
  'special_milestone_celebration': { name: 'Score Milestone Celebration', price: 0, type: 'special', description: 'Celebrate major score achievements', free: true }
};

// Player Inventory Management
function getOwnedItems() {
  const owned = localStorage.getItem('pythonixOwnedItems');
  return owned ? JSON.parse(owned) : [
    'skin_classic', 'skin_neon', 'skin_rainbow', 'skin_retro', 'skin_pacman', 'skin_arcade',
    'none', 'badge_none',
    'special_arena_energy', 'special_combo_visuals', 'special_portal_food', 'special_spawn_animation', 'special_milestone_celebration'
  ];
}

function addOwnedItem(itemId) {
  const owned = getOwnedItems();
  if (!owned.includes(itemId)) {
    owned.push(itemId);
    localStorage.setItem('pythonixOwnedItems', JSON.stringify(owned));
  }
}

function hasItem(itemId) {
  return getOwnedItems().includes(itemId);
}

// Current Equipment
function getEquippedItems() {
  const equipped = localStorage.getItem('pythonixEquippedItems');
  return equipped ? JSON.parse(equipped) : {
    skin: 'skin_classic',
    trail: 'none', 
    sound: 'default',
    badge: 'none'
  };
}

// Check if player can use an item (owns it or it's free)
function canUseItem(itemId) {
  // Free items that everyone can use (both old and new naming)
  const freeItems = ['classic', 'none', 'pacman', 'neon', 'arcade', 'rainbow', 'daylight', 'starlight', 
                     'skin_classic', 'skin_neon', 'skin_rainbow', 'skin_retro', 'skin_pacman', 'skin_arcade'];
  if (freeItems.includes(itemId)) return true;
  
  // Check for backward compatibility - map old names to new names
  const skinMapping = {
    'classic': 'skin_classic',
    'neon': 'skin_neon', 
    'pacman': 'skin_pacman',
    'arcade': 'skin_arcade',
    'rainbow': 'skin_rainbow',
    'forest': 'skin_forest',
    'sunset': 'skin_sunset',
    'ocean': 'skin_ocean',
    'gameboy': 'skin_gameboy'
  };
  
  if (skinMapping[itemId] && freeItems.includes(skinMapping[itemId])) return true;
  
  // Purchased items
  return hasItem(itemId);
}

// Update dropdown availability based on owned items
function updateDropdownAvailability() {
  const ownedItems = getOwnedItems();
  const freeItems = ['classic', 'none', 'pacman', 'neon', 'arcade', 'rainbow', 'daylight', 'starlight'];
  
  // Update skin dropdown
  const skinSelect = document.getElementById('snakeSkin');
  if (skinSelect) {
    Array.from(skinSelect.options).forEach(option => {
      const itemId = option.value;
      if (freeItems.includes(itemId)) return; // Free items stay enabled
      
      if (ownedItems.includes(itemId)) {
        option.textContent = option.textContent.replace('ðŸ”’', 'âœ…').replace(/\(\d+ coins\)/, '(Owned)');
        option.disabled = false;
      } else {
        option.disabled = true;
      }
    });
  }
  
  // Update trail dropdown
  const trailSelect = document.getElementById('trailEffect');
  if (trailSelect) {
    Array.from(trailSelect.options).forEach(option => {
      const itemId = option.value;
      if (itemId === 'none') return; // None is always available
      
      if (ownedItems.includes(itemId)) {
        option.textContent = option.textContent.replace('ðŸ”’', 'âœ…').replace(/\(\d+ coins\)/, '(Owned)');
        option.disabled = false;
      } else {
        option.disabled = true;
      }
    });
  }
  
  // Update badge dropdown
  const badgeSelect = document.getElementById('playerBadge');
  if (badgeSelect) {
    Array.from(badgeSelect.options).forEach(option => {
      const itemId = option.value;
      if (itemId === 'none') return; // None is always available
      
      if (ownedItems.includes(itemId)) {
        option.textContent = option.textContent.replace('ðŸ”’', 'âœ…').replace(/\(\d+ coins\)/, '(Owned)');
        option.disabled = false;
      } else {
        option.disabled = true;
      }
    });
  }
}

function equipItem(itemId, type) {
  const equipped = getEquippedItems();
  
  // Handle backward compatibility for skins
  if (type === 'skin') {
    const skinMapping = {
      'classic': 'skin_classic',
      'neon': 'skin_neon', 
      'pacman': 'skin_pacman',
      'arcade': 'skin_arcade',
      'rainbow': 'skin_rainbow',
      'forest': 'skin_forest',
      'sunset': 'skin_sunset',
      'ocean': 'skin_ocean',
      'gameboy': 'skin_gameboy'
    };
    
    // If it's an old skin name, convert to new format for storage
    if (skinMapping[itemId]) {
      equipped[type] = skinMapping[itemId];
      snakeSkin = itemId; // Keep old format for rendering
    } else {
      equipped[type] = itemId;
      // For new shop skins, use the skin ID directly for rendering
      snakeSkin = itemId;
      console.log('Equipped shop skin:', itemId, 'â†’ Rendering as:', snakeSkin);
    }
  } else {
    equipped[type] = itemId;
  }
  
  localStorage.setItem('pythonixEquippedItems', JSON.stringify(equipped));
  
  // Also update old system variables and localStorage for backwards compatibility
  if (type === 'skin') {
    localStorage.setItem('pythonixSnakeSkin', snakeSkin);
  } else if (type === 'trail') {
    currentTrail = itemId;
    localStorage.setItem('pythonixTrailEffect', currentTrail);
  } else if (type === 'badge') {
    currentBadge = itemId;
    localStorage.setItem('pythonixPlayerBadge', currentBadge);
  }
  
  applyVisualEffects();
}

function unequipItem(type) {
  const equipped = getEquippedItems();
  let defaultItem = '';
  if (type === 'trail') {
    defaultItem = 'none';
  } else if (type === 'badge') {
    defaultItem = 'badge_none';
  } else if (type === 'skin') {
    defaultItem = 'skin_classic'; // Default skin in new format
  }

  if (defaultItem) {
    equipped[type] = defaultItem;
    localStorage.setItem('pythonixEquippedItems', JSON.stringify(equipped));
    
    // Also update old system variables
    if (type === 'skin') {
      snakeSkin = 'classic'; // Use old format for rendering
      localStorage.setItem('pythonixSnakeSkin', snakeSkin);
    } else if (type === 'trail') {
      currentTrail = 'none'; // Use 'none' for no trail
      localStorage.setItem('pythonixTrailEffect', currentTrail);
    } else if (type === 'badge') {
      currentBadge = 'none'; // Use 'none' for no badge
      localStorage.setItem('pythonixPlayerBadge', currentBadge);
    }
    
    applyVisualEffects();
    showNotification(`Unequipped ${type}! ðŸš«`);
  }
  
  // Refresh current shop tab to update display
  const activeTab = document.querySelector('.shop-tab.active');
  if (activeTab) {
    const tabType = activeTab.getAttribute('onclick').match(/'([^']+)'/)[1];
    showShopTab(tabType);
  }
}

// Daily Login Bonus
function checkDailyBonus() {
  const today = new Date().toDateString();
  const lastLogin = localStorage.getItem('pythonixLastLogin');
  
  if (lastLogin !== today) {
    localStorage.setItem('pythonixLastLogin', today);
    addCoins(25); // Reduced from 50
    showNotification('Daily Login Bonus: +25 coins! ðŸª™');
    return true;
  }
  return false;
}

// Score-based coin rewards
function awardCoinsForScore(score) {
  let coinsEarned = 0;
  
  // Base reward: 1 coin per 75 points (reduced from 50)
  const baseCoins = Math.floor(score / 75);
  coinsEarned += baseCoins;
  
  // Milestone rewards: Reduced coin amounts for reaching score thresholds
  const milestones = [
    { score: 100, coins: 5, message: "Century Club Bonus!" },      // Reduced from 10
    { score: 250, coins: 12, message: "Quarter Master Bonus!" },   // Reduced from 25
    { score: 500, coins: 25, message: "High Roller Bonus!" },      // Reduced from 50
    { score: 1000, coins: 50, message: "Millennium Bonus!" },      // Reduced from 100
    { score: 2500, coins: 125, message: "Elite Player Bonus!" },   // Reduced from 250
    { score: 5000, coins: 250, message: "Snake Master Bonus!" }    // Reduced from 500
  ];
  
  // Check for milestone rewards (only award once per game)
  const currentSession = JSON.parse(localStorage.getItem('pythonixCurrentSession') || '{"milestonesEarned": []}');
  
    milestones.forEach(milestone => {
    if (score >= milestone.score && !currentSession.milestonesEarned.includes(milestone.score)) {
      coinsEarned += milestone.coins;
      currentSession.milestonesEarned.push(milestone.score);
      playAchievementSound(); // Play achievement sound for milestones
      showNotification(`ðŸŽ¯ ${milestone.message} +${milestone.coins} coins!`);
    }
  });  localStorage.setItem('pythonixCurrentSession', JSON.stringify(currentSession));
  
  if (coinsEarned > 0) {
    addCoins(coinsEarned, 'score_milestones');
    if (baseCoins > 0) {
      showNotification(`Score Reward: +${baseCoins} coins!`, 'coin');
    }
  }
}

// Playtime-based rewards
let gameStartTime = null;
let playtimeInterval = null;

function startPlaytimeTracking() {
  gameStartTime = Date.now();
  
  // Award 3 coins every 3 minutes of active play (reduced frequency and amount)
  playtimeInterval = setInterval(() => {
    if (!isGameOver) {
      addCoins(3, 'playtime');
      showNotification("Playtime Bonus: +3 coins!", 'coin');
    }
  }, 180000); // 3 minutes (increased from 2 minutes)
}

function stopPlaytimeTracking() {
  if (playtimeInterval) {
    clearInterval(playtimeInterval);
    playtimeInterval = null;
  }
  
  // Award completion bonus for finishing a round (reduced amount)
  if (gameStartTime) {
    const playTime = Date.now() - gameStartTime;
    if (playTime > 45000) { // Must play for at least 45 seconds (increased from 30)
      addCoins(10, 'round_completion'); // Reduced from 20
      showNotification("Round Completion: +10 coins!", 'coin');
    }
    gameStartTime = null;
  }
}

// Achievement-based coin rewards
function checkAchievementRewards(score, stats) {
  const achievementRewards = [
    // Survival achievements (reduced rewards)
    { id: 'survive_60s', condition: () => gameStartTime && (Date.now() - gameStartTime) >= 60000, coins: 75, message: "Survivor! +75 coins!" },
    { id: 'survive_120s', condition: () => gameStartTime && (Date.now() - gameStartTime) >= 120000, coins: 150, message: "Endurance Master! +150 coins!" },
    
    // Score achievements (reduced rewards)
    { id: 'first_50', condition: () => score >= 50, coins: 15, message: "First Steps! +15 coins!" },
    { id: 'first_100', condition: () => score >= 100, coins: 25, message: "Getting Started! +25 coins!" },
    { id: 'first_500', condition: () => score >= 500, coins: 50, message: "Rising Star! +50 coins!" },
    
    // Food achievements (reduced rewards)
    { id: 'eat_25', condition: () => stats.totalFoodsEaten >= 25, coins: 40, message: "Hungry Snake! +40 coins!" },
    { id: 'eat_50', condition: () => stats.totalFoodsEaten >= 50, coins: 75, message: "Voracious! +75 coins!" },
    { id: 'eat_100', condition: () => stats.totalFoodsEaten >= 100, coins: 150, message: "Glutton! +150 coins!" },
    
    // Game count achievements (reduced rewards)
    { id: 'play_5', condition: () => stats.gamesPlayed >= 5, coins: 50, message: "Persistent! +50 coins!" },
    { id: 'play_10', condition: () => stats.gamesPlayed >= 10, coins: 100, message: "Dedicated! +100 coins!" },
    { id: 'play_25', condition: () => stats.gamesPlayed >= 25, coins: 250, message: "Addicted! +250 coins!" }
  ];
  
  const earnedAchievements = JSON.parse(localStorage.getItem('pythonixEarnedAchievements') || '[]');
  
  achievementRewards.forEach(achievement => {
    if (!earnedAchievements.includes(achievement.id) && achievement.condition()) {
      earnedAchievements.push(achievement.id);
      addCoins(achievement.coins, 'achievements');
      
      // Auto-unlock legendary items if specified
      if (achievement.unlockItems) {
        const ownedItems = getOwnedItems();
        achievement.unlockItems.forEach(itemId => {
          if (!ownedItems.includes(itemId)) {
            addOwnedItem(itemId);
            console.log(`Auto-unlocked legendary item: ${itemId}`);
          }
        });
      }
      
      playAchievementSound(); // Play achievement sound
      showNotification(`ðŸ† ${achievement.message}`, 'achievement');
    }
  });
  
  localStorage.setItem('pythonixEarnedAchievements', JSON.stringify(earnedAchievements));
}

// Enhanced daily login system with streaks
function checkDailyBonus() {
  const today = new Date().toDateString();
  const lastLogin = localStorage.getItem('pythonixLastLogin');
  const loginStreak = parseInt(localStorage.getItem('pythonixLoginStreak') || '0');
  
  if (lastLogin !== today) {
    localStorage.setItem('pythonixLastLogin', today);
    
    // Check if this is consecutive day
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const isConsecutive = lastLogin === yesterday.toDateString();
    
    const newStreak = isConsecutive ? loginStreak + 1 : 1;
    localStorage.setItem('pythonixLoginStreak', newStreak.toString());
    
    // Progressive daily rewards
    const streakRewards = [
      { day: 1, coins: 25, message: "Daily Login: +25 coins!" },       // Reduced from 50
      { day: 2, coins: 40, message: "Day 2 Streak: +40 coins!" },      // Reduced from 75
      { day: 3, coins: 55, message: "Day 3 Streak: +55 coins!" },      // Reduced from 100
      { day: 4, coins: 70, message: "Day 4 Streak: +70 coins!" },      // Reduced from 125
      { day: 5, coins: 85, message: "Day 5 Streak: +85 coins!" },      // Reduced from 150
      { day: 6, coins: 110, message: "Day 6 Streak: +110 coins!" },    // Reduced from 200
      { day: 7, coins: 150, message: "Week Complete: +150 coins!" }    // Reduced from 300
    ];
    
    const reward = streakRewards.find(r => r.day === Math.min(newStreak, 7)) || streakRewards[6];
    addCoins(reward.coins, 'daily_login');
    showNotification(reward.message, 'coin');
    
    return true;
  }
  return false;
}

// Daily challenges system
function initializeDailyChallenges() {
  const today = new Date().toDateString();
  const dailyChallenges = JSON.parse(localStorage.getItem('pythonixDailyChallenges') || '{}');
  
  if (dailyChallenges.date !== today) {
    // Generate new daily challenges
    const challenges = [
      { id: 'score_200', description: "Score 200 points in a single game", target: 200, type: 'score', reward: 100, completed: false },
      { id: 'play_3', description: "Play 3 games today", target: 3, type: 'games', reward: 75, completed: false },
      { id: 'eat_30', description: "Eat 30 foods in a single game", target: 30, type: 'foods', reward: 125, completed: false },
      { id: 'survive_90', description: "Survive for 90 seconds", target: 90, type: 'survival', reward: 150, completed: false }
    ];
    
    // Pick 2 random challenges for today
    const todaysChallenges = challenges.sort(() => 0.5 - Math.random()).slice(0, 2);
    
    localStorage.setItem('pythonixDailyChallenges', JSON.stringify({
      date: today,
      challenges: todaysChallenges,
      gamesPlayedToday: 0
    }));
  }
}

function checkDailyChallenges(score, foodsEaten, survivalTime) {
  const dailyData = JSON.parse(localStorage.getItem('pythonixDailyChallenges') || '{}');
  if (!dailyData.challenges) return;
  
  let updated = false;
  
  dailyData.challenges.forEach(challenge => {
    if (challenge.completed) return;
    
    let completed = false;
    switch(challenge.type) {
      case 'score':
        completed = score >= challenge.target;
        break;
      case 'games':
        dailyData.gamesPlayedToday = (dailyData.gamesPlayedToday || 0) + 1;
        completed = dailyData.gamesPlayedToday >= challenge.target;
        break;
      case 'foods':
        completed = foodsEaten >= challenge.target;
        break;
      case 'survival':
        completed = survivalTime >= challenge.target;
        break;
    }
    
    if (completed) {
      challenge.completed = true;
      addCoins(challenge.reward, 'daily_challenges');
      playAchievementSound(); // Play achievement sound for challenge completion
      showNotification(`ðŸŽ¯ Challenge Complete: ${challenge.description} (+${challenge.reward} coins!)`, 'challenge');
      updated = true;
    }
  });
  
  if (updated) {
    localStorage.setItem('pythonixDailyChallenges', JSON.stringify(dailyData));
  }
}

// CrazyGames rewarded ads integration with cooldowns and daily caps
function watchAdForCoins() {
  const today = new Date().toDateString();
  const adData = JSON.parse(localStorage.getItem('pythonixAdData') || '{"date": "", "count": 0, "lastAd": 0}');
  
  // Reset daily count if new day
  if (adData.date !== today) {
    adData.date = today;
    adData.count = 0;
  }
  
  // Check daily limit (max 5 ads per day)
  if (adData.count >= 5) {
    showNotification('Daily ad limit reached! Come back tomorrow for more.', 'ad');
    return;
  }
  
  // Check cooldown (5 minutes between ads)
  const cooldownTime = 5 * 60 * 1000; // 5 minutes in milliseconds
  const timeSinceLastAd = Date.now() - adData.lastAd;
  
  if (timeSinceLastAd < cooldownTime) {
    const remainingMinutes = Math.ceil((cooldownTime - timeSinceLastAd) / 60000);
    showNotification(`Ad cooldown: ${remainingMinutes} minute(s) remaining`, 'ad');
    return;
  }
  
  if (crazygames && crazygames.ad) {
    console.log("CrazyGames: Requesting rewarded ad...");
    
    crazygames.ad.requestAd("rewarded", () => {
      // Ad completed successfully
      const adReward = 100;
      adData.count++;
      adData.lastAd = Date.now();
      localStorage.setItem('pythonixAdData', JSON.stringify(adData));
      
      addCoins(adReward, 'ads');
      showNotification(`Ad Reward: +${adReward} coins! (${5 - adData.count} ads left today)`, 'ad');
      console.log("CrazyGames: Rewarded ad completed, coins awarded");
    }, (error) => {
      // Ad failed or was skipped
      console.log("CrazyGames: Rewarded ad failed or skipped:", error);
      showNotification("Ad not available right now. Try again later!", 'ad');
    });
  } else {
    // Fallback for local development
    showNotification("Ads not available in development mode", 'ad');
  }
}

// Free daily continue token
function checkFreeDailyContinue() {
  const today = new Date().toDateString();
  const lastFreeToken = localStorage.getItem('pythonixLastFreeToken');
  
  if (lastFreeToken !== today) {
    localStorage.setItem('pythonixLastFreeToken', today);
    // Add a free continue token to inventory
    const ownedItems = getOwnedItems();
    ownedItems.push('continue_token_free');
    localStorage.setItem('pythonixOwnedItems', JSON.stringify(ownedItems));
    showNotification("ðŸŽ Daily Free Continue Token received!");
    return true;
  }
  return false;
}

// Visual Effects Application
function applyVisualEffects() {
  const equipped = getEquippedItems();
  const ownedItems = getOwnedItems();
  
  // Convert old free skins to legacy names, keep shop skins as-is
  const reverseMapping = {
    'skin_classic': 'classic',
    'skin_neon': 'neon',
    'skin_pacman': 'pacman', 
    'skin_arcade': 'arcade',
    'skin_rainbow': 'rainbow',
    'skin_retro': 'retro'
  };
  
  // Sync with old system variables for backwards compatibility
  // Only convert free skins, shop skins keep their skin_ format
  snakeSkin = reverseMapping[equipped.skin] || equipped.skin || 'classic';
  currentTrail = equipped.trail === 'none' ? 'none' : equipped.trail || 'none';
  currentBadge = equipped.badge === 'badge_none' ? 'none' : equipped.badge || 'none';
  
  console.log('applyVisualEffects - Equipped skin:', equipped.skin, 'â†’ Rendering as:', snakeSkin);
  console.log('applyVisualEffects - Trail:', equipped.trail, 'â†’', currentTrail);
  console.log('applyVisualEffects - Badge:', equipped.badge, 'â†’', currentBadge);
  
  // Apply snake skin
  applySnakeSkin(equipped.skin);
  
  // Apply trail effect
  applyTrailEffect(equipped.trail);
  
  // Apply sound pack
  applySoundPack(equipped.sound);
  
  // Apply special effects
  applySpecialEffects(ownedItems);
  
  // Update dropdown values to match equipped items
  updateDropdownValues();
}

function applySpecialEffects(ownedItems) {
  const canvas = document.getElementById('gameCanvas');
  if (!canvas) return;
  
  // Remove existing special effect classes
  canvas.className = canvas.className.replace(/border-glow-effect|arena-energy-border|arena-energy-level-\d+/g, '');
  document.body.className = document.body.className.replace(/arena-energy-active|spawn-animation-ready/g, '');
  
  // Apply new Arena Energy system (always enabled now)
  canvas.classList.add('arena-energy-border');
  document.body.classList.add('arena-energy-active');
  
  // Initialize combo system (always enabled now)
  initializeComboSystem();
  
  // Initialize spawn animation (always enabled now)
  document.body.classList.add('spawn-animation-ready');
}

// Update dropdown values to match equipped items
function updateDropdownValues() {
  const equipped = getEquippedItems();
  
  // Convert new format back to old format for dropdowns
  const reverseMapping = {
    'skin_classic': 'classic',
    'skin_neon': 'neon',
    'skin_pacman': 'pacman', 
    'skin_arcade': 'arcade',
    'skin_rainbow': 'rainbow',
    'skin_retro': 'retro',
    'skin_forest': 'forest',
    'skin_sunset': 'sunset',
    'skin_ocean': 'ocean',
    'skin_gameboy': 'gameboy'
  };
  
  const displaySkin = reverseMapping[equipped.skin] || equipped.skin || 'classic';
  
  // Update snake skin dropdown
  const skinSelect = document.getElementById('snakeSkin');
  const customizeSkin = document.getElementById('customizeSkin');
  if (skinSelect) skinSelect.value = displaySkin;
  if (customizeSkin) customizeSkin.value = displaySkin;
  
  // Update trail dropdown
  const trailSelect = document.getElementById('trailEffect');
  const customizeTrail = document.getElementById('customizeTrail');
  if (trailSelect) trailSelect.value = equipped.trail || 'none';
  if (customizeTrail) customizeTrail.value = equipped.trail || 'none';
  
  // Update badge dropdown
  const badgeSelect = document.getElementById('playerBadge');
  const customizeBadge = document.getElementById('customizeBadge');
  if (badgeSelect) badgeSelect.value = equipped.badge || 'none';
  if (customizeBadge) customizeBadge.value = equipped.badge || 'none';
}

function applySnakeSkin(skinId) {
  // Handle both old and new format skins
  let actualSkinId = skinId;
  
  // Convert new format to old format for CSS classes
  const reverseMapping = {
    'skin_classic': 'classic',
    'skin_neon': 'neon',
    'skin_pacman': 'pacman', 
    'skin_arcade': 'arcade',
    'skin_rainbow': 'rainbow',
    'skin_retro': 'retro'
  };
  
  if (reverseMapping[skinId]) {
    actualSkinId = reverseMapping[skinId];
  }
  
  // Update global variable for rendering system
  snakeSkin = actualSkinId;
  
  // Apply CSS classes for visual effects
  document.body.className = document.body.className.replace(/snake-skin-\w+/g, '');
  if (actualSkinId && actualSkinId !== 'classic') {
    document.body.classList.add(`snake-skin-${actualSkinId}`);
  }
}

function applyTrailEffect(trailId) {
  document.body.className = document.body.className.replace(/trail-effect-\w+/g, '');
  if (trailId !== 'trail_none') {
    document.body.classList.add(`trail-effect-${trailId.replace('trail_', '')}`);
  }
}

function applySoundPack(soundId) {
  // Sound pack logic will be implemented separately
  localStorage.setItem('pythonixActiveSoundPack', soundId);
}

// Enhanced notification system with better visuals
function showNotification(message, type = 'coin') {
  // Create or update notification element
  let notification = document.getElementById('coinNotification');
  if (!notification) {
    notification = document.createElement('div');
    notification.id = 'coinNotification';
    document.body.appendChild(notification);
  }
  
  // Different styles for different notification types
  let bgColor, borderColor, icon;
  switch(type) {
    case 'coin':
      bgColor = 'linear-gradient(45deg, #FFD700, #FFA500)';
      borderColor = '#FFD700';
      icon = 'ðŸª™';
      break;
    case 'achievement':
      bgColor = 'linear-gradient(45deg, #4CAF50, #66BB6A)';
      borderColor = '#4CAF50';
      icon = 'ðŸ†';
      break;
    case 'challenge':
      bgColor = 'linear-gradient(45deg, #2196F3, #42A5F5)';
      borderColor = '#2196F3';
      icon = 'ðŸŽ¯';
      break;
    case 'ad':
      bgColor = 'linear-gradient(45deg, #FF6B6B, #FF8E8E)';
      borderColor = '#FF6B6B';
      icon = 'ðŸ“º';
      break;
    default:
      bgColor = 'linear-gradient(45deg, #FFD700, #FFA500)';
      borderColor = '#FFD700';
      icon = 'ðŸª™';
  }
  
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: ${bgColor};
    color: #000;
    padding: 15px 20px;
    border-radius: 10px;
    border: 2px solid ${borderColor};
    font-family: 'Press Start 2P', monospace;
    font-size: 12px;
    z-index: 10000;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    transform: translateX(400px);
    transition: transform 0.3s ease;
    max-width: 300px;
    text-align: center;
  `;
  
  notification.innerHTML = `${icon} ${message}`;
  notification.style.transform = 'translateX(0)';
  
  setTimeout(() => {
    notification.style.transform = 'translateX(400px)';
  }, 4000);
}

// ===== CrazyGames SDK Integration =====
// Initialize the CrazyGames SDK
const crazygames = window.CrazyGames?.SDK;

// Global game variables
let canvas, ctx, boxSize = 40, boardWidth, boardHeight;
let snake, direction, food, score = 0, foodsEaten = 0;
let gameInterval, isGameOver = false, isPaused = false;
let speed = 150, baseSpeed = 150;
let obstacles = [];
let gameMode = 'classic';
let snakeShape = 'square';
let snakeEmoji = 'ðŸ';
let snakeSkin = 'classic';
let currentTrail = 'none';
let currentBadge = 'none';
let trailParticles = [];

// Powerup system
let activePowerups = {
  speed_boost: 0,
  shield: 0,
  double_points: 0,
  magnet: 0,
  slow_time: 0
};

// Powerup inventory
function getPowerupInventory() {
  const inventory = localStorage.getItem('pythonixPowerupInventory');
  return inventory ? JSON.parse(inventory) : {};
}

function addPowerupToInventory(powerupId) {
  const inventory = getPowerupInventory();
  inventory[powerupId] = (inventory[powerupId] || 0) + 1;
  localStorage.setItem('pythonixPowerupInventory', JSON.stringify(inventory));
}

function usePowerup(powerupId) {
  console.log('Attempting to use powerup:', powerupId);
  const inventory = getPowerupInventory();
  console.log('Current inventory:', inventory);
  
  if (inventory[powerupId] && inventory[powerupId] > 0) {
    inventory[powerupId]--;
    localStorage.setItem('pythonixPowerupInventory', JSON.stringify(inventory));
    console.log('Powerup used successfully, activating:', powerupId);
    activatePowerup(powerupId);
    return true;
  }
  console.log('Powerup not available in inventory');
  return false;
}

function activatePowerup(powerupId) {
  console.log('Activating powerup:', powerupId);
  switch(powerupId) {
    case 'powerup_speed_boost':
      activePowerups.speed_boost = 1800; // 30 seconds at 60fps
      console.log('Speed boost activated, duration:', activePowerups.speed_boost);
      // Apply speed boost immediately
      clearInterval(gameInterval);
      gameInterval = setInterval(gameLoop, Math.max(50, speed * 0.7));
      showNotification('Speed Boost Activated! âš¡ (30 sec)', 'success');
      break;
    case 'powerup_shield':
      activePowerups.shield = 3600; // 1 minute at 60fps
      console.log('Shield activated');
      showNotification('Shield Activated! ðŸ›¡ï¸ (1 min)', 'success');
      break;
    case 'powerup_double_points':
      activePowerups.double_points = 1800; // 30 seconds
      console.log('Double points activated, duration:', activePowerups.double_points);
      showNotification('Double Points Activated! ðŸ’° (30 sec)', 'success');
      break;
    case 'powerup_magnet':
      activePowerups.magnet = 3600; // 1 minute at 60fps
      console.log('Magnet activated, duration:', activePowerups.magnet);
      showNotification('Food Magnet Activated! ðŸ§² (1 min)', 'success');
      break;
    case 'powerup_slow_time':
      activePowerups.slow_time = 1800; // 30 seconds at 60fps
      console.log('Slow time activated, duration:', activePowerups.slow_time);
      // Apply slow time immediately
      clearInterval(gameInterval);
      gameInterval = setInterval(gameLoop, speed * 1.5);
      showNotification('Slow Time Activated! â° (30 sec)', 'success');
      break;
    default:
      console.log('Unknown powerup:', powerupId);
  }
  console.log('Active powerups state:', activePowerups);
}
let multiplierActive = false;
let multiplierInterval, speedInterval, multiplierExpireTime;
let gameTimeLeft = 60, gameTimeInterval;
let multiplierTimeLeft = 0, speedTimeLeft = 0;

// Sound effects
const eatSound = new Audio('eat.mp3');
eatSound.volume = 0.5;
const powerSound = new Audio('powerup.mp3');
powerSound.volume = 0.5;
const gameOverSound = new Audio('gameover.mp3');
gameOverSound.volume = 0.5;
const achievementSound = new Audio('powerup.mp3'); // Use powerup sound for achievements
achievementSound.volume = 0.6;

// ===== CrazyGames SDK Functions =====

// Loading Events
function startLoading() {
  if (crazygames) {
    crazygames.game.loadingStart();
    console.log("CrazyGames: Loading started");
  }
}

function finishLoading() {
  if (crazygames) {
    crazygames.game.loadingStop();
    console.log("CrazyGames: Loading finished");
  }
}

// Ads
function showAdBeforeRestart() {
  if (crazygames) {
    console.log("CrazyGames: Requesting ad...");
    crazygames.ad.requestAd("midgame", () => {
      console.log("CrazyGames: Ad finished. Game can continue...");
      // Don't auto-restart, let user decide
    });
  }
}

// Get user info (optional)
function getUserInfo() {
  if (crazygames) {
    crazygames.user.getUser().then((user) => {
      console.log("CrazyGames: Player info:", user);
      // user.locale, user.platform, etc.
    }).catch(err => {
      console.log("CrazyGames: Could not get user info:", err);
    });
  }
}

// Menu sounds
const backgroundMusic = new Audio('menu.mp3');
backgroundMusic.volume = 0.3;
backgroundMusic.loop = true;

const buttonHoverSound = new Audio('hover.wav');
buttonHoverSound.volume = 0.4;

const buttonClickSound = new Audio('click.wav');
buttonClickSound.volume = 0.5;

const menuSelectSound = new Audio('powerup.mp3'); // Reuse powerup sound for selections
menuSelectSound.volume = 0.4;

// Achievement sound function
function playAchievementSound() {
  try {
    achievementSound.currentTime = 0; // Reset to start
    achievementSound.play();
  } catch (e) {
    console.log('Achievement sound playback failed:', e);
  }
}

// Volume control functionality
function updateVolume(value) {
  // Force the value to be exactly what the slider says - no rounding, no edge cases, no BS
  const exactValue = parseInt(value);
  const volume = exactValue / 100;
  
  eatSound.volume = volume;
  powerSound.volume = volume;
  gameOverSound.volume = volume;
  achievementSound.volume = volume * 1.2;
  
  backgroundMusic.volume = volume * 0.6;
  buttonHoverSound.volume = volume * 0.8;
  buttonClickSound.volume = volume;
  menuSelectSound.volume = volume * 0.8;
  
  if (window.updateGameJsVolume) {
    window.updateGameJsVolume(volume);
  }
  
  // Show exactly what the slider value is
  const volumeValue = document.getElementById('volumeValue');
  if (volumeValue) {
    volumeValue.textContent = exactValue + '%';
  }
  
  localStorage.setItem('pythonixVolume', exactValue);
}

// Menu sound functions
function playBackgroundMusic() {
  try {
    backgroundMusic.currentTime = 0;
    backgroundMusic.play().catch(e => {
      console.log('Background music autoplay prevented - will start on first user interaction:', e);
    });
  } catch (e) {
    console.log('Could not play background music:', e);
  }
}

function stopBackgroundMusic() {
  try {
    backgroundMusic.pause();
    backgroundMusic.currentTime = 0;
  } catch (e) {
    console.log('Could not stop background music:', e);
  }
}

// Start background music on first user interaction (handles autoplay restrictions)
let musicStarted = false;
function startMusicOnInteraction() {
  if (!musicStarted) {
    // Check if we're on the start menu (intro screen visible)
    const introScreen = document.getElementById('introScreen');
    const gameScreen = document.getElementById('gameScreen');
    const isOnStartMenu = introScreen && introScreen.style.display !== 'none' && 
                         (!gameScreen || gameScreen.style.display === 'none');
    
    if (isOnStartMenu) {
      playBackgroundMusic();
      musicStarted = true;
      console.log('Background music started after user interaction on start menu');
    }
  }
}

// Add event listeners for user interaction to start music
document.addEventListener('click', startMusicOnInteraction);
document.addEventListener('keydown', startMusicOnInteraction);

// === TRAIL PARTICLE SYSTEM ===
function createTrailParticle(x, y, trailType) {
  if (trailType === 'none') return;
  
  const particle = {
    x: x + boxSize/2,
    y: y + boxSize/2,
    life: 1.0,
    maxLife: 1.0,
    type: trailType
  };
  
  // Trail-specific properties
  switch(trailType) {
    case 'trail_fire':
      particle.color = `hsl(${Math.random() * 60}, 100%, 50%)`;
      particle.size = Math.random() * 6 + 4;
      particle.velocityX = (Math.random() - 0.5) * 2;
      particle.velocityY = (Math.random() - 0.5) * 2;
      particle.maxLife = 0.8;
      break;
    case 'trail_electricity':
      particle.color = `hsl(${190 + Math.random() * 40}, 100%, 70%)`;
      particle.size = Math.random() * 4 + 2;
      particle.velocityX = (Math.random() - 0.5) * 4;
      particle.velocityY = (Math.random() - 0.5) * 4;
      particle.maxLife = 0.6;
      break;
    case 'trail_vaporwave':
      particle.color = `hsl(${280 + Math.random() * 60}, 80%, 60%)`;
      particle.size = Math.random() * 8 + 6;
      particle.velocityX = (Math.random() - 0.5) * 1;
      particle.velocityY = (Math.random() - 0.5) * 1;
      particle.maxLife = 1.2;
      break;
    case 'trail_laser':
      particle.color = `hsl(${120 + Math.random() * 60}, 100%, 50%)`;
      particle.size = Math.random() * 3 + 3;
      particle.velocityX = (Math.random() - 0.5) * 1;
      particle.velocityY = (Math.random() - 0.5) * 1;
      particle.maxLife = 0.9;
      break;
    case 'trail_stardust':
      particle.color = `hsl(${Math.random() * 360}, 100%, 80%)`;
      particle.size = Math.random() * 3 + 2;
      particle.velocityX = (Math.random() - 0.5) * 2;
      particle.velocityY = (Math.random() - 0.5) * 2;
      particle.maxLife = 1.5;
      break;
    case 'trail_smoke':
      particle.color = `hsla(0, 0%, ${30 + Math.random() * 40}%, 0.7)`;
      particle.size = Math.random() * 10 + 8;
      particle.velocityX = (Math.random() - 0.5) * 0.5;
      particle.velocityY = (Math.random() - 0.5) * 0.5;
      particle.maxLife = 2.0;
      break;
    case 'trail_ice':
      particle.color = `hsl(${180 + Math.random() * 40}, 70%, 80%)`;
      particle.size = Math.random() * 5 + 3;
      particle.velocityX = (Math.random() - 0.5) * 1;
      particle.velocityY = (Math.random() - 0.5) * 1;
      particle.maxLife = 1.0;
      break;
  }
  
  particle.life = particle.maxLife;
  trailParticles.push(particle);
}

function updateTrailParticles() {
  for (let i = trailParticles.length - 1; i >= 0; i--) {
    const particle = trailParticles[i];
    
    // Update particle position
    particle.x += particle.velocityX || 0;
    particle.y += particle.velocityY || 0;
    
    // Update particle life (faster decay)
    particle.life -= 0.025; // Increased from 0.016 for quicker disappearance
    
    // Remove dead particles
    if (particle.life <= 0) {
      trailParticles.splice(i, 1);
      continue;
    }
    
    // Draw particle
    const alpha = particle.life / particle.maxLife;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = particle.color;
    ctx.beginPath();
    ctx.arc(particle.x, particle.y, particle.size * alpha, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

function playButtonHover() {
  try {
    buttonHoverSound.currentTime = 0;
    buttonHoverSound.play().catch(e => console.log('Button hover sound failed:', e));
  } catch (e) {
    console.log('Could not play button hover sound:', e);
  }
}

function playButtonClick() {
  try {
    buttonClickSound.currentTime = 0;
    buttonClickSound.play().catch(e => console.log('Button click sound failed:', e));
  } catch (e) {
    console.log('Could not play button click sound:', e);
  }
}

function playMenuSelect() {
  try {
    menuSelectSound.currentTime = 0;
    menuSelectSound.play().catch(e => console.log('Menu select sound failed:', e));
  } catch (e) {
    console.log('Could not play menu select sound:', e);
  }
}

// Function to add sound effects to any button or interactive element
function addSoundEffectsToElement(element) {
  if (!element) return;
  
  // Add hover sound
  element.addEventListener('mouseenter', playButtonHover);
  
  // Add click sound to existing click handler
  const originalClick = element.onclick;
  element.onclick = function(event) {
    playButtonClick();
    if (originalClick) {
      return originalClick.call(this, event);
    }
  };
}

// Function to add sound effects to all interactive elements site-wide
function addSoundEffectsToSite() {
  // Add sounds to all buttons
  const buttons = document.querySelectorAll('button');
  buttons.forEach(addSoundEffectsToElement);
  
  // Add sounds to all selects
  const selects = document.querySelectorAll('select');
  selects.forEach(select => {
    select.addEventListener('mouseenter', playButtonHover);
    select.addEventListener('change', playButtonClick);
  });
  
  // Add sounds to all input sliders
  const sliders = document.querySelectorAll('input[type="range"]');
  sliders.forEach(slider => {
    slider.addEventListener('mouseenter', playButtonHover);
    slider.addEventListener('input', () => {
      // Play a quieter click for slider movement
      try {
        const clickCopy = buttonClickSound.cloneNode();
        clickCopy.volume = buttonClickSound.volume * 0.3; // Much quieter for sliders
        clickCopy.play().catch(e => console.log('Slider sound failed:', e));
      } catch (e) {
        console.log('Could not play slider sound:', e);
      }
    });
  });
  
  // Add sounds to clickable elements with onclick
  const clickableElements = document.querySelectorAll('[onclick]');
  clickableElements.forEach(addSoundEffectsToElement);
}

document.addEventListener('DOMContentLoaded', function() {
  // Initialize volume from localStorage
  const savedVolume = parseInt(localStorage.getItem('pythonixVolume') || '50');
  
  const volumeSlider = document.getElementById('volumeSlider');
  if (volumeSlider) {
    volumeSlider.value = savedVolume;
    updateVolume(savedVolume);
    
    volumeSlider.addEventListener('input', function() {
      updateVolume(this.value);
    });
  }
  
  // Add sound effects to all interactive elements site-wide
  addSoundEffectsToSite();
  
  // Try to start background music immediately (will fail if autoplay blocked)
  setTimeout(() => {
    const introScreen = document.getElementById('introScreen');
    if (introScreen && introScreen.style.display !== 'none') {
      playBackgroundMusic();
      console.log('Attempting to start background music on page load');
    }
  }, 100); // Very short delay to ensure DOM is ready
});

// Initialize canvas and board dimensions
function resizeCanvas() {
  canvas = document.getElementById('gameCanvas');
  if (!canvas) return;
  
  ctx = canvas.getContext('2d');
  
  // Add roundRect polyfill for older browsers
  if (!ctx.roundRect) {
    ctx.roundRect = function(x, y, width, height, radius) {
      this.beginPath();
      this.moveTo(x + radius, y);
      this.lineTo(x + width - radius, y);
      this.quadraticCurveTo(x + width, y, x + width, y + radius);
      this.lineTo(x + width, y + height - radius);
      this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      this.lineTo(x + radius, y + height);
      this.quadraticCurveTo(x, y + height, x, y + height - radius);
      this.lineTo(x, y + radius);
      this.quadraticCurveTo(x, y, x + radius, y);
      this.closePath();
    };
  }
  
  // Make board square - 600x600 pixels
  canvas.width = 600;
  canvas.height = 600;
  boardWidth = canvas.width / boxSize;
  boardHeight = canvas.height / boxSize;
}

// Generate random food
function randomFood() {
  let pos;
  do {
    pos = {
      x: Math.floor(Math.random() * boardWidth),
      y: Math.floor(Math.random() * boardHeight),
      type: 'normal'
    };
  } while (snake && snake.some(s => s.x === pos.x && s.y === pos.y));
  
  // Attract food if magnet is active
  if (activePowerups.magnet > 0 && snake.length > 0) {
    const head = snake[0];
    const dx = pos.x - head.x;
    const dy = pos.y - head.y;
    if (Math.abs(dx) < 8 && Math.abs(dy) < 8) { // Food within 8 blocks (increased from 5)
      if (Math.abs(dx) > Math.abs(dy)) {
        pos.x = head.x + Math.sign(dx);
      } else {
        pos.y = head.y + Math.sign(dy);
      }
    }
  }

  // Random food types - increased powerup spawn rates
  const rand = Math.random();
  if (rand < 0.08) pos.type = 'power_double';  // 8% chance (was 5%)
  else if (rand < 0.16) pos.type = 'power_speed';  // 8% chance (was 5%)
  
  // Create portal effect for food spawn
  setTimeout(() => {
    createPortalFoodEffect(pos.x * boxSize + boxSize/2, pos.y * boxSize + boxSize/2);
  }, 50);
  
  return pos;
}

// Check if direction change is valid (no 180 degree turns)
function isValidDirection(newDirection, currentDirection) {
  const opposites = {
    'UP': 'DOWN',
    'DOWN': 'UP', 
    'LEFT': 'RIGHT',
    'RIGHT': 'LEFT'
  };
  return opposites[currentDirection] !== newDirection;
}

// Add the actual working functions for achievements and history
function showAchievements() {
  console.log('Loading achievements...');
  const modal = document.getElementById('achievementsModal');
  if (modal) {
    modal.style.display = 'flex';
    loadAchievements();
  } else {
    console.error('Achievements modal not found');
  }
}

function showGameHistory() {
  console.log('Loading game history...');
  const modal = document.getElementById('historyModal');
  if (modal) {
    modal.style.display = 'flex';
    loadGameHistory();
  } else {
    console.error('History modal not found');
  }
}

function clearAllGameData() {
  const confirmed = confirm('âš ï¸ This will permanently delete ALL your game data including:\\n\\nâ€¢ High Score\\nâ€¢ Game History\\nâ€¢ Statistics\\nâ€¢ Achievement Progress\\n\\nThis action cannot be undone! Are you sure?');
  
  if (confirmed) {
    const doubleConfirm = confirm('ðŸš¨ FINAL WARNING! ðŸš¨\\n\\nYou will lose EVERYTHING:\\nâ€¢ Your high score of ' + (localStorage.getItem('pythonixHighScore') || '0') + ' points\\nâ€¢ All game statistics\\nâ€¢ All unlocked achievements\\n\\nType YES in the next prompt to confirm deletion.');
    
    if (doubleConfirm) {
      const finalConfirm = prompt('Type "DELETE ALL DATA" to confirm (case sensitive):');
      
      if (finalConfirm === 'DELETE ALL DATA') {
        // Clear all game data
        localStorage.removeItem('pythonixHighScore');
        localStorage.removeItem('pythonixStats');
        localStorage.removeItem('pythonixGameHistory');
        localStorage.removeItem('pythonixAchievements');
        localStorage.removeItem('pythonixRuns');
        
        alert('âœ… All game data has been deleted. The page will refresh.');
        window.location.reload();
      } else {
        alert('âŒ Deletion cancelled - incorrect confirmation text.');
      }
    } else {
      alert('âŒ Deletion cancelled by user.');
    }
  }
}

function loadAchievements() {
  const achievementsContent = document.getElementById('achievementsContent');
  if (!achievementsContent) {
    console.error('Achievements content element not found');
    return;
  }
  
  // Get current stats
  const highScore = parseInt(localStorage.getItem('pythonixHighScore') || '0');
  const stats = JSON.parse(localStorage.getItem('pythonixStats') || '{"gamesPlayed": 0, "totalFoodsEaten": 0}');
  
  console.log('Current stats:', stats, 'High score:', highScore);
  
  const achievements = [
    // Beginner achievements
    { id: 'first_game', name: 'First Steps', description: 'Play your first game', unlocked: stats.gamesPlayed >= 1, icon: 'ðŸ‘¶' },
    { id: 'score_50', name: 'Getting Started', description: 'Score 50 points', unlocked: highScore >= 50, icon: 'ðŸŒ±' },
    { id: 'score_100', name: 'Century Club', description: 'Score 100 points', unlocked: highScore >= 100, icon: 'ðŸ’¯' },
    
    // Intermediate achievements  
    { id: 'score_250', name: 'Quarter Master', description: 'Score 250 points', unlocked: highScore >= 250, icon: 'ðŸŽ¯' },
    { id: 'score_500', name: 'High Roller', description: 'Score 500 points', unlocked: highScore >= 500, icon: 'ðŸŽ°' },
    { id: 'games_5', name: 'Persistent', description: 'Play 5 games', unlocked: stats.gamesPlayed >= 5, icon: 'ðŸ”¥' },
    { id: 'games_10', name: 'Dedicated', description: 'Play 10 games', unlocked: stats.gamesPlayed >= 10, icon: 'ðŸ’ª' },
    { id: 'foods_100', name: 'Hungry Snake', description: 'Eat 100 total foods', unlocked: stats.totalFoodsEaten >= 100, icon: 'ðŸŽ' },
    
    // Hard achievements
    { id: 'score_1000', name: 'Millennium', description: 'Score 1,000 points', unlocked: highScore >= 1000, icon: 'ðŸš€' },
    { id: 'score_2500', name: 'Elite Player', description: 'Score 2,500 points', unlocked: highScore >= 2500, icon: 'ðŸ‘‘' },
    { id: 'score_5000', name: 'Snake Master', description: 'Score 5,000 points', unlocked: highScore >= 5000, icon: 'ðŸ' },
    { id: 'games_25', name: 'Addicted', description: 'Play 25 games', unlocked: stats.gamesPlayed >= 25, icon: 'ðŸŽ®' },
    { id: 'games_50', name: 'No Life', description: 'Play 50 games', unlocked: stats.gamesPlayed >= 50, icon: 'ðŸ˜…' },
    { id: 'foods_500', name: 'Glutton', description: 'Eat 500 total foods', unlocked: stats.totalFoodsEaten >= 500, icon: 'ðŸ´' },
    
    // Expert achievements 
    { id: 'score_10000', name: 'Legend', description: 'Score 10,000 points', unlocked: highScore >= 10000, icon: 'âš¡' },
    { id: 'score_12500', name: 'Snake Virtuoso', description: 'Score 12,500 points', unlocked: highScore >= 12500, icon: 'ðŸŽ¯' },
    { id: 'games_100', name: 'Obsessed', description: 'Play 100 games', unlocked: stats.gamesPlayed >= 100, icon: 'ðŸ¤¯' },
    { id: 'foods_1000', name: 'Food Vacuum', description: 'Eat 1,000 total foods', unlocked: stats.totalFoodsEaten >= 1000, icon: 'ðŸŒªï¸' },
    
    // Ultimate achievements
    { id: 'score_15000', name: 'Snake God', description: 'Score 15,000 points (legendary!)', unlocked: highScore >= 15000, icon: 'ï¿½' },
    { id: 'score_18000', name: 'Untouchable', description: 'Score 16,000 points (ultimate mastery!)', unlocked: highScore >= 16000, icon: 'ï¿½' },
    { id: 'games_250', name: 'Intervention Needed', description: 'Play 250 games', unlocked: stats.gamesPlayed >= 250, icon: 'ðŸ˜±' },
    { id: 'foods_2500', name: 'Bottomless Pit', description: 'Eat 2,500 total foods', unlocked: stats.totalFoodsEaten >= 2500, icon: 'ðŸ•³ï¸' },
    
    // Special achievements
    { id: 'high_scorer', name: 'High Scorer', description: 'Achieve a score higher than 750 points', unlocked: highScore >= 750, icon: 'â­' },
    { id: 'food_chain', name: 'Food Chain', description: 'Eat 50 foods in a single game', unlocked: highScore >= 500, icon: 'ðŸ”—' },
    { id: 'marathon_player', name: 'Marathon Player', description: 'Play 15 games in a row', unlocked: stats.gamesPlayed >= 15, icon: 'ðŸƒ' },
    { id: 'consistent', name: 'Consistent', description: 'Score over 200 points (achievable multiple times)', unlocked: highScore >= 200, icon: 'ðŸŽ¯' },
    { id: 'explorer', name: 'Explorer', description: 'Try different game modes (play any game)', unlocked: stats.gamesPlayed >= 1, icon: 'ðŸ—ºï¸' },
    { id: 'veteran', name: 'Veteran', description: 'Reach a high score of 1500+ points', unlocked: highScore >= 1500, icon: 'ðŸŽ–ï¸' }
  ];
  
  let html = '<div class="achievements-grid">';
  
  achievements.forEach(achievement => {
    html += `
      <div class="achievement ${achievement.unlocked ? 'unlocked' : 'locked'}">
        <div class="achievement-icon">${achievement.unlocked ? (achievement.icon || 'ðŸ†') : 'ðŸ”’'}</div>
        <div class="achievement-info">
          <h4>${achievement.name}</h4>
          <p>${achievement.description}</p>
        </div>
      </div>
    `;
  });
  
  html += '</div>';
  achievementsContent.innerHTML = html;
}

// ===== SHOP FUNCTIONS =====

function showShop() {
  console.log('Opening shop...');
  const modal = document.getElementById('shopModal');
  if (modal) {
    modal.style.display = 'flex';
    updateCoinDisplay();
    showShopTab('skins'); // Show skins tab by default
  } else {
    console.error('Shop modal not found');
  }
}

function closeShop() {
  const modal = document.getElementById('shopModal');
  if (modal) {
    modal.style.display = 'none';
  }
}

function showShopTab(tabName) {
  // Update tab appearance
  document.querySelectorAll('.shop-tab').forEach(tab => {
    tab.classList.remove('active');
    if (tab.textContent.toLowerCase().includes(tabName)) {
      tab.classList.add('active');
    }
  });
  
  // Filter items by type
  let itemsToShow = [];
  
  // Function to check if an item is unlocked
  function isItemUnlocked(item) {
    if (!item.unlockCondition) return true; // No unlock condition means always available
    
    const highScore = parseInt(localStorage.getItem('pythonixHighScore') || '0');
    const stats = JSON.parse(localStorage.getItem('pythonixStats') || '{"gamesPlayed": 0, "totalFoodsEaten": 0}');
    
    // Check specific unlock conditions
    switch(item.unlockCondition) {
      case 'score_16000':
        return highScore >= 16000;
      // Add more unlock conditions here as needed
      default:
        return true;
    }
  }
  
  switch(tabName) {
    case 'skins':
      itemsToShow = Object.entries(SHOP_ITEMS).filter(([id, item]) => {
        if (item.type !== 'skin') return false;
        
        // Check unlock conditions first
        if (!isItemUnlocked(item)) return false;
        
        // Filter out shop skins that have free equivalents
        const duplicateMapping = {
          'skin_classic': 'classic',
          'skin_neon': 'neon',
          'skin_pacman': 'pacman',
          'skin_arcade': 'arcade',
          'skin_rainbow': 'rainbow'
        };
        
        // Don't show shop versions of free skins
        if (duplicateMapping[id]) return false;
        
        return true;
      });
      break;
    case 'trails':
      itemsToShow = Object.entries(SHOP_ITEMS).filter(([id, item]) => item.type === 'trail');
      break;
    case 'powerup':
      itemsToShow = Object.entries(SHOP_ITEMS).filter(([id, item]) => item.type === 'powerup');
      break;
    case 'utility':
      itemsToShow = Object.entries(SHOP_ITEMS).filter(([id, item]) => item.type === 'utility');
      break;
    case 'badges':
      itemsToShow = Object.entries(SHOP_ITEMS).filter(([id, item]) => {
        return item.type === 'badge' && isItemUnlocked(item);
      });
      break;
    case 'special':
      itemsToShow = Object.entries(SHOP_ITEMS).filter(([id, item]) => item.type === 'special');
      break;
  }
  
  // Render items
  renderShopItems(itemsToShow, tabName);
}

function renderShopItems(items, tabName) {
  const container = document.getElementById('shopItems');
  if (!container) return;
  
  const ownedItems = getOwnedItems();
  const equippedItems = getEquippedItems();
  const playerCoins = getCoins();
  const powerupInventory = getPowerupInventory();
  
  // Add inventory header for powerups
  let inventoryHeader = '';
  if (tabName === 'powerup' || tabName === 'utility') {
    const totalPowerups = Object.values(powerupInventory).reduce((sum, count) => sum + count, 0);
    inventoryHeader = `
      <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; margin-bottom: 20px; text-align: center;">
        <h3 style="margin: 0; color: #fff;">ðŸŽ’ Your Inventory</h3>
        <p style="margin: 5px 0; color: rgba(255,255,255,0.8);">Total items: ${totalPowerups}</p>
      </div>
    `;
  }
  
  container.innerHTML = inventoryHeader + items.map(([itemId, item]) => {
    const isOwned = ownedItems.includes(itemId) || item.free;
    const isEquipped = Object.values(equippedItems).includes(itemId);
    const canAfford = playerCoins >= item.price;
    const isFree = item.free || item.price === 0;
    const inventoryCount = powerupInventory[itemId] || 0;
    
    console.log(`Shop item ${itemId}: owned=${isOwned}, equipped=${isEquipped}, equippedItems=`, equippedItems);
    
    // Get type-specific emoji and styling
    let typeIcon = '';
    let typeClass = '';
    switch(item.type) {
      case 'skin': 
        typeIcon = 'ðŸ'; 
        typeClass = 'type-skin';
        break;
      case 'trail': 
        typeIcon = 'âœ¨'; 
        typeClass = 'type-trail';
        break;
      case 'powerup': 
        typeIcon = 'âš¡'; 
        typeClass = 'type-powerup';
        break;
      case 'utility': 
        typeIcon = 'ðŸ› ï¸'; 
        typeClass = 'type-utility';
        break;
      case 'badge': 
        typeIcon = 'ðŸ†'; 
        typeClass = 'type-badge';
        break;
      case 'special': 
        typeIcon = 'ðŸ’«'; 
        typeClass = 'type-special';
        break;
      default: 
        typeIcon = 'ðŸŽ®';
        typeClass = 'type-default';
    }
    
    let buttonText = 'Buy';
    let buttonClass = 'shop-button';
    let buttonDisabled = '';
    let extraButton = '';
    
    if (isEquipped) {
      buttonText = 'Equipped';
      buttonClass += ' equipped';
      buttonDisabled = 'disabled';
      // Add unequip button for cosmetic items
      if (item.type === 'trail' || item.type === 'badge') {
        extraButton = `<button class="shop-button unequip-button" onclick="unequipItem('${item.type}')">Unequip</button>`;
        console.log('Adding unequip button for', itemId, 'type:', item.type);
      } else if (item.type === 'skin' && itemId !== 'classic') {
        // Allow unequipping skins except the default classic skin
        extraButton = `<button class="shop-button unequip-button" onclick="unequipItem('${item.type}')">Use Classic</button>`;
        console.log('Adding unequip button for skin', itemId);
      }
    } else if (isOwned) {
      buttonText = 'Equip';
      buttonClass += ' owned';
    } else if (isFree) {
      buttonText = 'Equip';
      buttonClass += ' owned';
    } else if (!canAfford) {
      buttonText = 'Not enough coins';
      buttonDisabled = 'disabled';
    }
    
    // Special handling for consumable powerups
    const isPowerup = item.type === 'powerup' || item.type === 'utility';
    if (isPowerup) {
      if (inventoryCount > 0) {
        buttonText = `Use (${inventoryCount})`;
        buttonClass = 'shop-button powerup-use';
      } else if (isOwned) {
        buttonText = `Use (0)`;
        buttonClass = 'shop-button powerup-use';
        buttonDisabled = 'disabled';
      }
    } else if (isPowerup && isOwned) {
      buttonText = 'Use';
      buttonClass = 'shop-button powerup-use';
    }
    
    // Add inventory count display for powerups
    let inventoryDisplay = '';
    if (isPowerup && inventoryCount > 0) {
      inventoryDisplay = `<div style="background: rgba(0,255,0,0.2); color: #00ff00; padding: 5px; border-radius: 5px; margin: 5px 0; font-size: 12px; text-align: center;">In Inventory: ${inventoryCount}</div>`;
    }
    
    // Special price display for legendary items
    let priceDisplay;
    if (item.legendary && item.unlockCondition) {
      if (isOwned) {
        priceDisplay = 'ðŸ‘‘ UNLOCKED!';
      } else if (item.unlockCondition === 'score_16000') {
        priceDisplay = 'ðŸ’Ž Requires 16,000 points';
      } else {
        priceDisplay = 'ðŸ”’ Locked';
      }
    } else {
      priceDisplay = isFree ? 'ðŸ†“ Free' : `ðŸª™ ${item.price}`;
    }
    
    return `
      <div class="shop-item ${typeClass} ${isOwned ? 'owned' : ''} ${isEquipped ? 'equipped' : ''} ${item.legendary ? 'legendary' : ''}">
        <div class="item-header">
          <span class="item-type-icon">${typeIcon}</span>
          <div class="item-name">${item.name}</div>
        </div>
        <div class="item-description">${item.description}</div>
        ${inventoryDisplay}
        <div class="item-price">${priceDisplay}</div>
        <button class="${buttonClass}" 
                onclick="handleItemClick('${itemId}')" 
                ${buttonDisabled}>
          ${buttonText}
        </button>
        ${extraButton}
      </div>
    `;
  }).join('');
}

function handleItemClick(itemId) {
  const item = SHOP_ITEMS[itemId];
  if (!item) return;
  
  const ownedItems = getOwnedItems();
  const equippedItems = getEquippedItems();
  const isOwned = ownedItems.includes(itemId) || item.free;
  const isEquipped = Object.values(equippedItems).includes(itemId);
  const isFree = item.free || item.price === 0;
  
  if (isOwned) {
    // Handle different item types
    if (item.type === 'powerup' || item.type === 'utility') {
      // For powerups and utilities, use them from inventory
      if (usePowerup(itemId)) {
        showNotification(`Used: ${item.name}! âš¡`);
        // Refresh current tab to update inventory display
        const activeTab = document.querySelector('.shop-tab.active');
        if (activeTab) {
          const tabType = activeTab.getAttribute('onclick').match(/'([^']+)'/)[1];
          showShopTab(tabType);
        }
      } else {
        showNotification(`No ${item.name} in inventory!`, 'error');
      }
    } else if (isEquipped) {
      // Item is already equipped, show notification
      showNotification(`${item.name} is already equipped! âœ¨`);
      return; // Don't refresh the shop unnecessarily
    } else {
      // For other items, equip them
      equipItem(itemId, item.type);
      showNotification(`Equipped: ${item.name}! âœ¨`);
    }
    updateDropdownAvailability(); // Update dropdown when item is equipped
    applyVisualEffects(); // Apply visual effects immediately
    // Refresh current tab
    const activeTab = document.querySelector('.shop-tab.active');
    if (activeTab) {
      const tabType = activeTab.getAttribute('onclick').match(/'([^']+)'/)[1];
      showShopTab(tabType);
    }
  } else {
    // Try to buy the item (or equip if free)
    if (isFree || spendCoins(item.price)) {
      if (item.type === 'powerup' || item.type === 'utility') {
        // For powerups and utilities, add to inventory instead of equipping
        addPowerupToInventory(itemId);
        showNotification(`${isFree ? 'Obtained' : 'Purchased'}: ${item.name}! Added to inventory ðŸŽ’`);
      } else {
        // For other items, add to owned and equip
        addOwnedItem(itemId);
        equipItem(itemId, item.type);
        showNotification(`${isFree ? 'Equipped' : 'Purchased'}: ${item.name}! ðŸŽ‰`);
      }
      updateDropdownAvailability(); // Update dropdown when item is purchased
      updateLeaderboardOption(); // Update leaderboard access indicator
      applyVisualEffects(); // Apply visual effects immediately
      // Refresh current tab
      const activeTab = document.querySelector('.shop-tab.active');
      if (activeTab) {
        const tabType = activeTab.getAttribute('onclick').match(/'([^']+)'/)[1];
        showShopTab(tabType);
      }
    } else {
      showNotification(`Need ${item.price - getCoins()} more coins! ðŸ’°`);
    }
  }
}

function showDailyChallenges() {
  console.log('Opening daily challenges...');
  const modal = document.getElementById('challengesModal');
  if (modal) {
    modal.style.display = 'flex';
    updateCoinDisplay();
    renderDailyChallenges();
  } else {
    console.error('Challenges modal not found');
  }
}

function closeChallenges() {
  const modal = document.getElementById('challengesModal');
  if (modal) {
    modal.style.display = 'none';
  }
}

// Load and sync equipped items from storage
function initializeEquipment() {
  // Load from old system first for backwards compatibility
  const savedSkin = localStorage.getItem('pythonixSnakeSkin') || 'classic';
  const savedTrail = localStorage.getItem('pythonixTrailEffect') || 'none';
  const savedBadge = localStorage.getItem('pythonixPlayerBadge') || 'none';
  
  // Convert old skin names to new format for equipment system
  const skinMapping = {
    'classic': 'skin_classic',
    'neon': 'skin_neon', 
    'pacman': 'skin_pacman',
    'arcade': 'skin_arcade',
    'rainbow': 'skin_rainbow',
    'forest': 'skin_forest',
    'sunset': 'skin_sunset',
    'ocean': 'skin_ocean',
    'gameboy': 'skin_gameboy'
  };
  
  // Set global variables (keep old format for rendering)
  snakeSkin = savedSkin;
  currentTrail = savedTrail;
  currentBadge = savedBadge;
  
  // Get or create equipment object
  let equipped = getEquippedItems();
  
  // If equipment system is empty, populate from old system
  if (!localStorage.getItem('pythonixEquippedItems')) {
    equipped = {
      skin: skinMapping[savedSkin] || savedSkin,
      trail: savedTrail,
      badge: savedBadge,
      sound: 'default'
    };
    localStorage.setItem('pythonixEquippedItems', JSON.stringify(equipped));
  } else {
    // Equipment system exists, sync variables with it
    const equippedSkin = equipped.skin || 'skin_classic';
    
    // Convert old free skins to their legacy names for rendering compatibility
    // New shop skins use their skin_ IDs directly
    const reverseMapping = {
      'skin_classic': 'classic',
      'skin_neon': 'neon',
      'skin_pacman': 'pacman', 
      'skin_arcade': 'arcade',
      'skin_rainbow': 'rainbow'
    };
    
    // Only convert free skins, shop skins keep their skin_ format
    snakeSkin = reverseMapping[equippedSkin] || equippedSkin;
    currentTrail = equipped.trail || 'none';
    currentBadge = equipped.badge || 'none';
    
    console.log('Equipped skin:', equippedSkin, 'â†’ Rendering as:', snakeSkin);
  }
  
  // Apply the equipped items
  applyVisualEffects();
}

// Restore lost data - compensation for system issues
function restorePlayerData() {
  const currentCoins = getCoins();
  
  // If player has very few coins, give them a generous boost
  if (currentCoins < 100) {
    const bonusCoins = 2000;
    const newTotal = currentCoins + bonusCoins;
    localStorage.setItem('pythonixCoins', newTotal.toString());
    showNotification(`ðŸŽ Data Restoration: +${bonusCoins} coins! Sorry for the trouble!`, 'success');
  }
  
  // Give some free powerups as compensation
  const inventory = getPowerupInventory();
  const bonusPowerups = {
    'powerup_speed_boost': 5,
    'powerup_shield': 3,
    'powerup_double_points': 3,
    'powerup_magnet': 2,
    'powerup_slow_time': 2
  };
  
  let addedAny = false;
  Object.entries(bonusPowerups).forEach(([powerupId, count]) => {
    const currentCount = inventory[powerupId] || 0;
    if (currentCount < count) {
      inventory[powerupId] = count;
      addedAny = true;
    }
  });
  
  if (addedAny) {
    localStorage.setItem('pythonixPowerupInventory', JSON.stringify(inventory));
    showNotification('ðŸŽ Bonus powerups added to your inventory!', 'success');
  }
}

// === CUSTOMIZATION MODAL FUNCTIONS ===
function showCustomization() {
  const modal = document.getElementById('customizeModal');
  modal.style.display = 'flex';
  updateCoinDisplay();
  
  // Sync customization controls with current settings
  syncCustomizationControls();
}

function closeCustomization() {
  document.getElementById('customizeModal').style.display = 'none';
}

function syncCustomizationControls() {
  // Sync all customization controls with current settings
  const customizeSkin = document.getElementById('customizeSkin');
  const customizeTrail = document.getElementById('customizeTrail');
  const customizeBadge = document.getElementById('customizeBadge');
  const customizeTheme = document.getElementById('customizeTheme');
  const customizeEmojiPicker = document.querySelector('#customizeModal #emojiPicker');
  
  // Set current values
  if (customizeSkin) customizeSkin.value = snakeSkin;
  if (customizeTrail) customizeTrail.value = currentTrail || 'none';
  if (customizeBadge) customizeBadge.value = currentBadge || 'none';
  if (customizeTheme) customizeTheme.value = localStorage.getItem('pythonixTheme') || 'auto';
  if (customizeEmojiPicker) customizeEmojiPicker.value = snakeEmoji || 'ðŸ';
  
  // Populate trail and badge options with owned items
  populateCustomizeOptions();
}

function populateCustomizeOptions() {
  const ownedItems = getOwnedItems();
  
  // Populate trail options
  const trailSelect = document.getElementById('customizeTrail');
  if (trailSelect) {
    trailSelect.innerHTML = '<option value="none">No Trail</option>';
    Object.entries(SHOP_ITEMS).forEach(([itemId, item]) => {
      if (item.type === 'trail') {
        const isOwned = ownedItems.includes(itemId);
        const option = document.createElement('option');
        option.value = itemId;
        option.textContent = isOwned ? `${item.name} (Owned)` : `${item.name} (ðŸ”’ ${item.price} coins)`;
        option.disabled = !isOwned;
        trailSelect.appendChild(option);
      }
    });
  }
  
  // Populate badge options
  const badgeSelect = document.getElementById('customizeBadge');
  if (badgeSelect) {
    badgeSelect.innerHTML = '<option value="none">No Badge</option>';
    Object.entries(SHOP_ITEMS).forEach(([itemId, item]) => {
      if (item.type === 'badge') {
        const isOwned = ownedItems.includes(itemId);
        const option = document.createElement('option');
        option.value = itemId;
        option.textContent = isOwned ? `${item.name} (Owned)` : `${item.name} (ðŸ”’ ${item.price} coins)`;
        option.disabled = !isOwned;
        badgeSelect.appendChild(option);
      }
    });
  }
  
  // Add purchased skins to the customize skin dropdown
  const skinSelect = document.getElementById('customizeSkin');
  if (skinSelect) {
    // Clear existing purchased skins (keep default options)
    const defaultOptions = Array.from(skinSelect.options).filter(option => 
      ['classic', 'neon', 'rainbow', 'retro', 'pacman', 'arcade', 'daylight', 'starlight'].includes(option.value)
    );
    skinSelect.innerHTML = '';
    defaultOptions.forEach(option => skinSelect.appendChild(option));
    
    // Add purchased skins (avoid duplicates)
    Object.entries(SHOP_ITEMS).forEach(([itemId, item]) => {
      if (item.type === 'skin' && ownedItems.includes(itemId)) {
        // Check if this skin has a corresponding free version
        const reverseMapping = {
          'skin_classic': 'classic',
          'skin_neon': 'neon',
          'skin_pacman': 'pacman',
          'skin_arcade': 'arcade',
          'skin_rainbow': 'rainbow'
        };
        
        // Don't add if free version already exists
        const freeVersion = reverseMapping[itemId];
        if (freeVersion && defaultOptions.some(opt => opt.value === freeVersion)) {
          return;
        }
        
        const option = document.createElement('option');
        option.value = itemId;
        option.textContent = `${item.name} (Owned)`;
        skinSelect.appendChild(option);
      }
    });
  }
}

// Connect customization modal controls
function connectCustomizationControls() {
  // Connect skin selector
  const customizeSkin = document.getElementById('customizeSkin');
  if (customizeSkin) {
    customizeSkin.addEventListener('change', function() {
      const selectedValue = this.value;
      if (selectedValue === 'classic' || canUseItem(selectedValue)) {
        // Convert old format to new format for equipment system
        const skinMapping = {
          'classic': 'skin_classic',
          'neon': 'skin_neon',
          'pacman': 'skin_pacman',
          'arcade': 'skin_arcade',
          'rainbow': 'skin_rainbow',
          'forest': 'skin_forest',
          'sunset': 'skin_sunset',
          'ocean': 'skin_ocean',
          'gameboy': 'skin_gameboy'
        };
        
        const newFormatSkin = skinMapping[selectedValue] || selectedValue;
        equipItem(newFormatSkin, 'skin');
        showNotification(`Equipped skin: ${selectedValue}! âœ¨`);
      } else {
        this.value = snakeSkin || 'classic';
        showNotification('This skin is locked! Purchase it in the shop.', 'error');
      }
    });
  }
  
  // Connect trail selector
  const customizeTrail = document.getElementById('customizeTrail');
  if (customizeTrail) {
    customizeTrail.addEventListener('change', function() {
      const selectedValue = this.value;
      if (selectedValue === 'none' || canUseItem(selectedValue)) {
        equipItem(selectedValue, 'trail');
        if (selectedValue !== 'none') {
          showNotification(`Equipped trail: ${selectedValue}! âœ¨`);
        }
      } else {
        this.value = currentTrail || 'none';
        showNotification('This trail is locked! Purchase it in the shop.', 'error');
      }
    });
  }
  
  // Connect badge selector
  const customizeBadge = document.getElementById('customizeBadge');
  if (customizeBadge) {
    customizeBadge.addEventListener('change', function() {
      const selectedValue = this.value;
      if (selectedValue === 'none' || canUseItem(selectedValue)) {
        equipItem(selectedValue, 'badge');
        if (selectedValue !== 'none') {
          showNotification(`Equipped badge: ${selectedValue}! âœ¨`);
        }
      } else {
        this.value = currentBadge || 'none';
        showNotification('This badge is locked! Purchase it in the shop.', 'error');
      }
    });
  }
  
  // Connect theme selector
  const customizeTheme = document.getElementById('customizeTheme');
  if (customizeTheme) {
    customizeTheme.addEventListener('change', function() {
      changeTheme(this.value);
      localStorage.setItem('pythonixTheme', this.value);
      
      // Also update hidden control if exists
      const hiddenTheme = document.getElementById('themeSelect');
      if (hiddenTheme) hiddenTheme.value = this.value;
    });
  }
  
  // Connect emoji picker
  const customizeEmoji = document.querySelector('#customizeModal #emojiPicker');
  if (customizeEmoji) {
    customizeEmoji.addEventListener('input', function() {
      const inputValue = this.value.trim();
      if (inputValue.length > 0) {
        snakeEmoji = inputValue;
        localStorage.setItem('pythonixSnakeEmoji', snakeEmoji);
        
        // Also update hidden control
        const hiddenEmoji = document.getElementById('emojiPicker');
        if (hiddenEmoji) hiddenEmoji.value = snakeEmoji;
        
        console.log('Snake emoji changed to:', snakeEmoji);
      }
    });
  }
}

function renderDailyChallenges() {
  const container = document.getElementById('challengesContent');
  if (!container) return;
  
  const dailyData = JSON.parse(localStorage.getItem('pythonixDailyChallenges') || '{}');
  const loginStreak = parseInt(localStorage.getItem('pythonixLoginStreak') || '0');
  
  if (!dailyData.challenges) {
    container.innerHTML = '<p style="text-align: center; color: #ccc;">No challenges available. Try refreshing!</p>';
    return;
  }
  
  let html = `
    <div style="margin-bottom: 30px; text-align: center;">
      <h3 style="color: #66ccff; margin-bottom: 15px;">ðŸ”¥ Login Streak: ${loginStreak} days</h3>
      <p style="color: #ccc; font-size: 14px;">Keep logging in daily for increasing rewards!</p>
    </div>
    
    <div style="margin-bottom: 20px;">
      <h3 style="color: #66ccff; margin-bottom: 15px;">Today's Challenges</h3>
  `;
  
  dailyData.challenges.forEach(challenge => {
    const statusIcon = challenge.completed ? 'âœ…' : 'â³';
    const statusText = challenge.completed ? 'COMPLETED' : 'IN PROGRESS';
    const statusColor = challenge.completed ? '#4CAF50' : '#FFA500';
    
    html += `
      <div style="background: rgba(102, 204, 255, 0.1); border: 2px solid ${statusColor}; border-radius: 10px; padding: 15px; margin-bottom: 15px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <div>
            <div style="font-size: 14px; color: #66ccff; margin-bottom: 5px;">${statusIcon} ${challenge.description}</div>
            <div style="font-size: 12px; color: #ccc;">Reward: ðŸª™ ${challenge.reward} coins</div>
          </div>
          <div style="text-align: right;">
            <div style="font-size: 12px; color: ${statusColor}; font-weight: bold;">${statusText}</div>
          </div>
        </div>
      </div>
    `;
  });
  
  html += `
    </div>
    
    <div style="text-align: center; margin-top: 30px;">
      <h3 style="color: #66ccff; margin-bottom: 15px;">ðŸ’° Ways to Earn Coins</h3>
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; font-size: 12px; color: #ccc;">
        <div>ðŸ“Š Score Points<br>1 coin per 50 points</div>
        <div>ðŸŽ¯ Score Milestones<br>Bonus coins at 100, 250, 500+</div>
        <div>â° Play Time<br>5 coins every 2 minutes</div>
        <div>ðŸ Complete Rounds<br>20 coins per completion</div>
        <div>ðŸ† Unlock Achievements<br>25-500 coins each</div>
        <div>ðŸ—“ï¸ Daily Login<br>50-300 coins (streak bonus)</div>
        <div>ðŸŽ¯ Daily Challenges<br>75-150 coins each</div>
        <div>ðŸ“º Watch Ads<br>100 coins per ad</div>
      </div>
    </div>
  `;
  
  container.innerHTML = html;
}

function loadGameHistory() {
  const historyContent = document.getElementById('historyContent');
  if (!historyContent) {
    console.error('History content element not found');
    return;
  }
  
  const stats = JSON.parse(localStorage.getItem('pythonixStats') || '{"gamesPlayed": 0, "totalFoodsEaten": 0}');
  const gameHistory = JSON.parse(localStorage.getItem('pythonixGameHistory') || '[]');
  const highScore = parseInt(localStorage.getItem('pythonixHighScore') || '0');
  
  console.log('Loading history - Stats:', stats, 'History:', gameHistory, 'High score:', highScore);
  
  let html = '<div class="stats-overview">';
  html += `<div class="stat-item"><strong>Games Played:</strong> ${stats.gamesPlayed}</div>`;
  html += `<div class="stat-item"><strong>High Score:</strong> ${highScore}</div>`;
  html += `<div class="stat-item"><strong>Total Foods:</strong> ${stats.totalFoodsEaten}</div>`;
  html += `<div class="stat-item"><strong>Avg Score:</strong> ${stats.gamesPlayed > 0 ? Math.round((stats.totalScore || 0) / stats.gamesPlayed) : 0}</div>`;
  html += '</div>';
  
  html += '<h3>Recent Games</h3>';
  
  if (gameHistory.length === 0) {
    html += '<p>No games recorded yet. Play some games to see your history!</p>';
    html += '<p><em>Note: Your current high score of ' + highScore + ' shows you have played before, but detailed history wasn\'t being saved.</em></p>';
  } else {
    html += '<div class="history-list">';
    gameHistory.slice(-10).reverse().forEach(game => {
      const date = new Date(game.date).toLocaleDateString() + ' ' + new Date(game.date).toLocaleTimeString();
      html += `
        <div class="history-item">
          <div class="game-info">
            <span class="game-score">Score: ${game.score}</span>
            <span class="game-foods">Foods: ${game.foodsEaten || 0}</span>
            <span class="game-mode">${game.mode || 'Classic'}</span>
          </div>
          <div class="game-date">${date}</div>
        </div>
      `;
    });
    html += '</div>';
  }
  
  historyContent.innerHTML = html;
}

// Core game functions
function gameLoop() {
  if (isGameOver || isPaused) return;

  // Handle power-up timers and effects
  Object.keys(activePowerups).forEach(key => {
    if (activePowerups[key] > 0) {
      activePowerups[key]--;
      if (activePowerups[key] === 0) {
        showNotification(`${key.replace('_', ' ')} wore off!`, 'info');
        
        // Reset speed when speed-affecting powerups expire
        if (key === 'speed_boost' || key === 'slow_time') {
          clearInterval(gameInterval);
          gameInterval = setInterval(gameLoop, speed);
        }
      }
    }
  });
  
  // Handle pending direction change
  if (window.pendingDirection && isValidDirection(window.pendingDirection, direction)) {
    console.log('Changing direction from', direction, 'to', window.pendingDirection);
    direction = window.pendingDirection;
    window.direction = direction; // Keep window.direction in sync
    window.pendingDirection = null;
  }
  
  // Move snake head
  let head = { x: snake[0].x, y: snake[0].y };
  
  switch (direction) {
    case 'LEFT': head.x--; break;
    case 'RIGHT': head.x++; break;
    case 'UP': head.y--; break;
    case 'DOWN': head.y++; break;
  }
  
  // Handle wall wrapping
  if (head.x < 0) head.x = boardWidth - 1;
  if (head.x >= boardWidth) head.x = 0;
  if (head.y < 0) head.y = boardHeight - 1;
  if (head.y >= boardHeight) head.y = 0;
  
  if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
    if (activePowerups.shield > 0) {
      showNotification('Shield blocked a collision! ðŸ›¡ï¸', 'info');
      // The snake will pass through itself for one move (shield stays active)
    } else {
      endGame(); return;
    }
  }
  
  snake.unshift(head);
  
  // Check food collision (with magnet effect)
  let foodCollision = false;
  if (food) {
    if (head.x === food.x && head.y === food.y) {
      foodCollision = true;
    } else if (activePowerups.magnet > 0) {
      // Magnet effect: expand collision area
      const distance = Math.abs(head.x - food.x) + Math.abs(head.y - food.y);
      if (distance <= 2) { // Within 2 tiles
        foodCollision = true;
        showNotification('ðŸ§² Magnet pulled food!', 'info');
      }
    }
  }
  
  if (foodCollision) {
    handleFoodEaten();
  } else {
    snake.pop();
  }
  
  // Update score display continuously with badge
  const scoreBoard = document.getElementById('scoreBoard');
  if (scoreBoard) {
    let badgeText = '';
    if (currentBadge && currentBadge !== 'none') {
      const badgeItem = SHOP_ITEMS[currentBadge];
      if (badgeItem) {
        badgeText = ` | ${badgeItem.name.replace(' Badge', '')}`;
      }
    }
    scoreBoard.textContent = `Score: ${score}${badgeText}`;
    updatePowerupDisplay();
  }
  
  drawBoard();
}

// Update powerup inventory display during gameplay
function updatePowerupDisplay() {
  let powerupDisplay = document.getElementById('powerupDisplay');
  if (!powerupDisplay) {
    // Create powerup display element
    powerupDisplay = document.createElement('div');
    powerupDisplay.id = 'powerupDisplay';
    powerupDisplay.style.cssText = `
      position: absolute;
      top: 80px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      border-radius: 8px;
      font-family: 'Press Start 2P', monospace;
      font-size: 10px;
      min-width: 150px;
      max-width: 200px;
      z-index: 1000;
    `;
    document.body.appendChild(powerupDisplay);
  }
  
  const inventory = getPowerupInventory();
  const powerupKeys = {
    'powerup_speed_boost': '1',
    'powerup_shield': '2', 
    'powerup_double_points': '3',
    'powerup_magnet': '4',
    'powerup_slow_time': '5'
  };
  
  let html = '<div style="margin-bottom: 5px; color: #00ff00;">âš¡ POWERUPS</div>';
  let hasAnyPowerups = false;
  
  Object.entries(powerupKeys).forEach(([powerupId, key]) => {
    const count = inventory[powerupId] || 0;
    const item = SHOP_ITEMS[powerupId];
    const isActive = activePowerups[powerupId.replace('powerup_', '')] > 0;
    
    if (item && count > 0) {
      hasAnyPowerups = true;
      let activeText = '';
      if (isActive) {
        const timeLeft = activePowerups[powerupId.replace('powerup_', '')];
        const minutesLeft = Math.floor(timeLeft / 3600); // 60fps * 60sec = 3600 frames per minute
        const secondsLeft = Math.floor((timeLeft % 3600) / 60);
        if (minutesLeft > 0) {
          activeText = ` ðŸ”¥ACTIVE (${minutesLeft}:${secondsLeft.toString().padStart(2, '0')})`;
        } else {
          activeText = ` ðŸ”¥ACTIVE (${secondsLeft}s)`;
        }
      }
      html += `<div style="margin: 2px 0; ${isActive ? 'color: #ff0; font-weight: bold;' : ''}">[${key}] ${item.name.replace('Powerup', '').trim()}: ${count}${activeText}</div>`;
    }
  });
  
  if (!hasAnyPowerups) {
    html += '<div style="color: #666;">No powerups</div>';
  } else {
    html += '<div style="margin-top: 5px; color: #888; font-size: 8px;">Press 1-5 to use</div>';
  }
  
  powerupDisplay.innerHTML = html;
}

function drawBoard() {
  if (!canvas || !ctx) return;
  if (!boardWidth || !boardHeight) resizeCanvas();

  // Get theme-specific colors
  const currentTheme = document.body.className;
  const rootStyles = getComputedStyle(document.body);
  
  // Background - use theme board background or default
  const bg = rootStyles.getPropertyValue('--board-bg').trim() || "#f7fffe";
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Grid - theme-specific grid colors
  let colorA, colorB, borderColor;
  
  if (currentTheme.includes('theme-classic')) {
    // Classic Snake - simple green grid
    colorA = "#001100";
    colorB = "#002200";
    borderColor = "#00ff00";
  } else if (currentTheme.includes('theme-pacman')) {
    // Pac-Man - blue maze-like grid
    colorA = "#000040";
    colorB = "#000060";
    borderColor = "#0000ff";
  } else if (currentTheme.includes('theme-neon')) {
    // Neon - dark with cyan grid
    colorA = "#001122";
    colorB = "#002233";
    borderColor = "#00ffff";
  } else if (currentTheme.includes('theme-arcade')) {
    // Arcade - dark purple with gold borders
    colorA = "#1a0a2e";
    colorB = "#2d1b4e";
    borderColor = "#ffd700";
  } else if (currentTheme.includes('theme-day')) {
    // Day theme - bright, sunny colors with sky blue accents
    colorA = "#e6f3ff";
    colorB = "#d1e9ff";
    borderColor = "#87ceeb";
  } else if (currentTheme.includes('theme-night')) {
    // Night theme - dark with starry accents
    colorA = "#0a1428";
    colorB = "#142545";
    borderColor = "#4169e1";
  } else {
    // Default theme
    colorA = "#A8DBA8";
    colorB = "#8CCF7E";
    borderColor = "#6c7a89";
  }
  
  for (let y = 0; y < boardHeight; y++) {
    for (let x = 0; x < boardWidth; x++) {
      // Base grid pattern
      ctx.fillStyle = ((x + y) % 2 === 0) ? colorA : colorB;
      ctx.fillRect(x * boxSize, y * boxSize, boxSize, boxSize);
      
      // Theme-specific grid effects
      if (currentTheme.includes('theme-neon')) {
        // Add subtle glow to borders
        ctx.shadowColor = borderColor;
        ctx.shadowBlur = 2;
      } else if (currentTheme.includes('theme-pacman')) {
        // Add maze-like appearance with thicker walls at edges
        if (x === 0 || x === boardWidth - 1 || y === 0 || y === boardHeight - 1) {
          ctx.fillStyle = '#000080';
          ctx.fillRect(x * boxSize, y * boxSize, boxSize, boxSize);
        }
        // Add occasional wall blocks for maze effect
        if ((x + y) % 7 === 0 && x > 1 && x < boardWidth - 2 && y > 1 && y < boardHeight - 2) {
          ctx.fillStyle = '#000080';
          ctx.fillRect(x * boxSize, y * boxSize, boxSize, boxSize);
        }
      } else if (currentTheme.includes('theme-classic')) {
        // Simple clean look - no special effects
      } else if (currentTheme.includes('theme-day')) {
        // Day theme - add subtle sunlight effect
        if ((x + y) % 8 === 0) {
          const sunlight = ctx.createRadialGradient(
            x * boxSize + boxSize/2, y * boxSize + boxSize/2, 0,
            x * boxSize + boxSize/2, y * boxSize + boxSize/2, boxSize
          );
          sunlight.addColorStop(0, 'rgba(255, 215, 0, 0.1)');
          sunlight.addColorStop(1, 'transparent');
          ctx.fillStyle = sunlight;
          ctx.fillRect(x * boxSize, y * boxSize, boxSize, boxSize);
        }
      } else if (currentTheme.includes('theme-night')) {
        // Night theme - add twinkling star effect
        if ((x * 3 + y * 5) % 13 === 0) {
          const twinkle = Math.sin(performance.now() / 1000 + x + y) * 0.5 + 0.5;
          ctx.fillStyle = `rgba(135, 206, 235, ${twinkle * 0.3})`;
          ctx.fillRect(x * boxSize + boxSize/3, y * boxSize + boxSize/3, boxSize/3, boxSize/3);
        }
      }
      
      // Draw border
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = currentTheme.includes('theme-arcade') ? 2 : 1;
      ctx.strokeRect(x * boxSize, y * boxSize, boxSize, boxSize);
      
      // Reset shadow
      ctx.shadowBlur = 0;
    }
  }

  // Draw snake
  if (Array.isArray(snake) && snake.length > 0) {
    if (snakeShape === 'emoji') {
      snake.forEach((segment, i) => {
        if (!segment) return;
        const cx = (segment.x + 0.5) * boxSize;
        const cy = (segment.y + 0.5) * boxSize;
        ctx.font = `${Math.floor(boxSize*0.9)}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#fff';
        ctx.fillText(snakeEmoji, cx, cy);
      });
    } else {
      // Get theme-based colors
      const currentTheme = document.body.className;
      const rootStyles = getComputedStyle(document.body);
      
      // Get snake color/gradient based on theme and skin
      const getSnakeColor = () => {
        const currentTheme = document.body.className;
        const rootStyles = getComputedStyle(document.body);
        
        // DEBUG: Log current skin
        console.log('ðŸ Rendering snake with skin:', snakeSkin);
        
        // Theme-specific skin colors
        if (snakeSkin === 'classic') {
          return currentTheme.includes('theme-classic') ? 
            rootStyles.getPropertyValue('--snake-color').trim() || '#00ff00' : '#4CAF50';
        }
        if (snakeSkin === 'pacman') {
          return currentTheme.includes('theme-pacman') ? 
            rootStyles.getPropertyValue('--snake-color').trim() || '#ffff00' : '#ffff00';
        }
        if (snakeSkin === 'neon') {
          if (currentTheme.includes('theme-neon')) {
            return rootStyles.getPropertyValue('--snake-color').trim() || '#00ffff';
          } else {
            const gradient = ctx.createLinearGradient(0, 0, boxSize, boxSize);
            gradient.addColorStop(0, '#00ffff');
            gradient.addColorStop(0.5, '#ff00ff');
            gradient.addColorStop(1, '#ffff00');
            return gradient;
          }
        }
        if (snakeSkin === 'arcade') {
          if (currentTheme.includes('theme-arcade')) {
            return rootStyles.getPropertyValue('--snake-color').trim() || '#ff0080';
          } else {
            const gradient = ctx.createLinearGradient(0, 0, boxSize, boxSize);
            gradient.addColorStop(0, '#ff0080');
            gradient.addColorStop(0.5, '#8000ff');
            gradient.addColorStop(1, '#ff8000');
            return gradient;
          }
        }
        if (snakeSkin === 'rainbow') return `hsl(${Math.floor((performance.now()/50)%360)}, 90%, 55%)`;
        if (snakeSkin === 'retro') {
          return `hsl(${Math.floor((performance.now()/100)%360)}, 80%, 60%)`;
        }
        if (snakeSkin === 'daylight') {
          // Sunny, warm colors with smooth golden transitions
          const time = performance.now() / 600; // Slower, smoother animation
          const dayPhase = Math.sin(time / 3) * 0.5 + 0.5; // Gentle oscillation 0-1
          
          // Warm color range: golden yellow to warm orange
          const hue = 35 + Math.sin(time / 2) * 20; // 15-55 degrees (yellow to orange)
          const saturation = 75 + Math.sin(time / 1.5) * 15; // 60-90% saturation
          const lightness = 55 + Math.sin(time / 2.5) * 15; // 40-70% lightness
          
          return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
        if (snakeSkin === 'starlight') {
          // Slower, smoother twinkling star-like effect with cool night colors
          const time = performance.now() / 800; // Much slower animation
          const twinkle = Math.sin(time) * 0.2 + 0.8; // Smaller variation, brighter base
          const hue = 220 + Math.sin(time / 2) * 20; // Slower hue shift, blue to purple range
          const lightness = 60 + Math.sin(time * 1.5) * 15; // Gentle lightness variation
          return `hsla(${hue}, 85%, ${lightness}%, ${0.9 + twinkle * 0.1})`;
        }
        
        // === NEW SHOP SKINS ===
        if (snakeSkin === 'skin_neon') {
          const time = performance.now() / 100;
          const gradient = ctx.createLinearGradient(0, 0, boxSize, boxSize);
          gradient.addColorStop(0, `hsl(${180 + Math.sin(time) * 30}, 100%, 70%)`);
          gradient.addColorStop(0.5, '#00ffff');
          gradient.addColorStop(1, `hsl(${220 + Math.cos(time) * 30}, 100%, 70%)`);
          return gradient;
        }
        if (snakeSkin === 'skin_rainbow') {
          // Enhanced rainbow with smoother transitions
          const time = performance.now() / 30;
          const hue = (time + segment.x * 10 + segment.y * 10) % 360;
          return `hsl(${hue}, 90%, 60%)`;
        }
        // Default fallback
        return currentTheme.includes('theme-') ? 
          rootStyles.getPropertyValue('--snake-color').trim() || '#4CAF50' : '#4CAF50';
      };

      const snakeColor = getSnakeColor();
      ctx.fillStyle = snakeColor;
      
      snake.forEach((segment, i) => {
        if (!segment) return;
        const x = segment.x * boxSize;
        const y = segment.y * boxSize;
        
        // Create trail particles only for the tail (last few segments)
        if (i >= snake.length - 3 && currentTrail && currentTrail !== 'none') {
          createTrailParticle(x, y, currentTrail);
        }
        
        // Theme-specific shapes based on skin selection
        if ((currentTheme.includes('theme-pacman') && snakeSkin === 'pacman') || 
            (snakeSkin === 'pacman' && !currentTheme.includes('theme-'))) {
          const cx = x + boxSize/2;
          const cy = y + boxSize/2;
          
          if (i === 0) {
            // Head - Draw Pac-Man with animated mouth opening
            const radius = boxSize * 0.45;
            let mouthAngle = 0; // Default facing right
            
            if (direction === 'UP') mouthAngle = -Math.PI / 2;
            else if (direction === 'DOWN') mouthAngle = Math.PI / 2;
            else if (direction === 'LEFT') mouthAngle = Math.PI;
            else mouthAngle = 0; // RIGHT
            
            // Animate mouth opening and closing
            const time = performance.now();
            const mouthCycle = Math.sin(time / 200); // Controls speed of mouth animation
            const mouthSize = Math.max(0.1, (mouthCycle + 1) / 2) * (Math.PI / 3); // Mouth opens between 10% and 60 degrees
            
            // Draw Pac-Man head with animated mouth
            ctx.beginPath();
            ctx.arc(cx, cy, radius, mouthAngle + mouthSize, mouthAngle + 2 * Math.PI - mouthSize);
            ctx.lineTo(cx, cy);
            ctx.closePath();
            ctx.fill();
          } else {
            // Body segments - Draw smaller solid circles (eaten pellets)
            ctx.beginPath();
            ctx.arc(cx, cy, boxSize * 0.35, 0, 2 * Math.PI);
            ctx.fill();
          }
        } else if ((currentTheme.includes('theme-neon') && snakeSkin === 'neon') || 
                   (snakeSkin === 'neon' && !currentTheme.includes('theme-'))) {
          // Draw with glow effect
          ctx.shadowColor = snakeColor;
          ctx.shadowBlur = 10;
          ctx.fillRect(x, y, boxSize, boxSize);
          ctx.shadowBlur = 0;
        } else if ((currentTheme.includes('theme-arcade') && snakeSkin === 'arcade') || 
                   (snakeSkin === 'arcade' && !currentTheme.includes('theme-'))) {
          // Draw retro arcade style with neon green blocks
          ctx.fillStyle = '#00FF00';
          ctx.shadowColor = '#00FF00';
          ctx.shadowBlur = 8;
          
          // Draw main block
          ctx.fillRect(x + 1, y + 1, boxSize - 2, boxSize - 2);
          
          // Add bright inner highlight
          ctx.fillStyle = '#88FF88';
          ctx.fillRect(x + 2, y + 2, boxSize - 4, boxSize - 4);
          
          // Add core glow
          ctx.fillStyle = '#CCFFCC';
          ctx.fillRect(x + 3, y + 3, boxSize - 6, boxSize - 6);
          
          // Reset shadow and color
          ctx.shadowBlur = 0;
          ctx.fillStyle = '#00FF00';
        } else if ((currentTheme.includes('theme-classic') && snakeSkin === 'classic') || 
                   (snakeSkin === 'classic' && !currentTheme.includes('theme-'))) {
          // Draw classic retro style with subtle 3D effect
          ctx.fillRect(x, y, boxSize, boxSize);
          
          // Add retro 3D highlight effect
          ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
          ctx.fillRect(x, y, boxSize - 1, 1); // Top highlight
          ctx.fillRect(x, y, 1, boxSize - 1); // Left highlight
          
          // Add shadow
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillRect(x + boxSize - 1, y + 1, 1, boxSize - 1); // Right shadow
          ctx.fillRect(x + 1, y + boxSize - 1, boxSize - 1, 1); // Bottom shadow
          
          // Reset color for next segment
          ctx.fillStyle = snakeColor;
        } else if (snakeSkin === 'skin_pixel') {
          // Enhanced pixel art style with dithering and details
          const isEven = Math.floor((x + y) / boxSize) % 2;
          
          // Base pixel with dithering pattern
          ctx.fillStyle = isEven ? '#4CAF50' : '#2E7D32';
          ctx.fillRect(x, y, boxSize, boxSize);
          
          // Add pixel art details
          ctx.fillStyle = '#81C784';
          ctx.fillRect(x + 2, y + 2, 4, 4);
          ctx.fillStyle = '#1B5E20';
          ctx.fillRect(x + boxSize - 6, y + boxSize - 6, 4, 4);
          
          // Add retro scanline effect
          ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
          for (let line = 0; line < boxSize; line += 2) {
            ctx.fillRect(x, y + line, boxSize, 1);
          }
        } else if (snakeSkin === 'skin_synthwave') {
          // Enhanced synthwave with animated grid and glow
          const time = performance.now() / 100;
          const phase = (x + y + time) * 0.05;
          const intensity = Math.sin(phase) * 0.4 + 0.6;
          
          // Base synthwave gradient
          const gradient = ctx.createLinearGradient(x, y, x + boxSize, y + boxSize);
          gradient.addColorStop(0, `hsl(300, 100%, ${50 + intensity * 30}%)`);
          gradient.addColorStop(0.3, `hsl(180, 100%, ${60 + intensity * 20}%)`);
          gradient.addColorStop(0.7, `hsl(270, 100%, ${55 + intensity * 25}%)`);
          gradient.addColorStop(1, `hsl(320, 100%, ${45 + intensity * 35}%)`);
          
          ctx.fillStyle = gradient;
          ctx.fillRect(x, y, boxSize, boxSize);
          
          // Add animated neon grid
          ctx.strokeStyle = '#FF00FF';
          ctx.lineWidth = 1;
          ctx.setLineDash([2, 2]);
          ctx.strokeRect(x + 1, y + 1, boxSize - 2, boxSize - 2);
          ctx.setLineDash([]);
          
          // Add outer glow effect
          ctx.shadowColor = '#00FFFF';
          ctx.shadowBlur = 8;
          ctx.strokeStyle = '#00FFFF';
          ctx.lineWidth = 0.5;
          ctx.strokeRect(x, y, boxSize, boxSize);
          ctx.shadowBlur = 0;
          
          // Add scanlines
          ctx.fillStyle = 'rgba(255, 0, 255, 0.1)';
          for (let line = 0; line < boxSize; line += 3) {
            ctx.fillRect(x, y + line, boxSize, 1);
          }
        } else if (snakeSkin === 'skin_neon') {
          // Enhanced neon with pulsing glow
          const time = performance.now() / 100;
          const pulse = Math.sin(time) * 0.3 + 0.7;
          
          // Base neon gradient
          const gradient = ctx.createLinearGradient(x, y, x + boxSize, y + boxSize);
          gradient.addColorStop(0, `hsl(${180 + Math.sin(time) * 30}, 100%, 70%)`);
          gradient.addColorStop(0.5, '#00ffff');
          gradient.addColorStop(1, `hsl(${220 + Math.cos(time) * 30}, 100%, 70%)`);
          
          ctx.fillStyle = gradient;
          ctx.fillRect(x, y, boxSize, boxSize);
          
          // Multi-layer glow effect
          ctx.shadowColor = '#00ffff';
          ctx.shadowBlur = 15 * pulse;
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.strokeRect(x, y, boxSize, boxSize);
          
          // Inner bright core
          ctx.shadowBlur = 5;
          ctx.strokeStyle = '#00ffff';
          ctx.lineWidth = 0.5;
          ctx.strokeRect(x + 2, y + 2, boxSize - 4, boxSize - 4);
          ctx.shadowBlur = 0;
        } else if (snakeSkin === 'skin_golden') {
          // Enhanced golden with metallic shine and sparkles
          const time = performance.now() / 150;
          const shimmer = Math.sin(time + x * 0.01 + y * 0.01) * 0.3 + 0.7;
          
          // Base golden gradient
          const gradient = ctx.createLinearGradient(x, y, x + boxSize, y + boxSize);
          gradient.addColorStop(0, `hsl(45, 100%, ${60 + shimmer * 30}%)`);
          gradient.addColorStop(0.5, '#FFD700');
          gradient.addColorStop(1, `hsl(35, 100%, ${50 + shimmer * 20}%)`);
          
          ctx.fillStyle = gradient;
          ctx.fillRect(x, y, boxSize, boxSize);
          
          // Metallic highlights
          ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
          ctx.fillRect(x + 1, y + 1, boxSize - 8, 3);
          ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
          ctx.fillRect(x + 1, y + 1, 3, boxSize - 8);
          
          // Shadow for depth
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillRect(x + 1, y + boxSize - 4, boxSize - 2, 3);
          
          // Add sparkles
          if (Math.random() < 0.3) {
            ctx.fillStyle = 'white';
            const sparkleX = x + Math.random() * boxSize;
            const sparkleY = y + Math.random() * boxSize;
            ctx.fillRect(sparkleX, sparkleY, 1, 1);
            ctx.fillRect(sparkleX - 1, sparkleY, 1, 1);
            ctx.fillRect(sparkleX + 1, sparkleY, 1, 1);
            ctx.fillRect(sparkleX, sparkleY - 1, 1, 1);
            ctx.fillRect(sparkleX, sparkleY + 1, 1, 1);
          }
        } else if (snakeSkin === 'skin_diamond') {
          // Enhanced diamond with crystal facets and prismatic effects
          const time = performance.now() / 120;
          const prism = Math.sin(time + x * 0.01 + y * 0.01) * 0.5 + 0.5;
          
          // Base crystal gradient
          const gradient = ctx.createLinearGradient(x, y, x + boxSize, y + boxSize);
          gradient.addColorStop(0, `hsl(${180 + prism * 60}, 80%, 85%)`);
          gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.9)');
          gradient.addColorStop(1, `hsl(${220 + prism * 80}, 70%, 75%)`);
          
          ctx.fillStyle = gradient;
          ctx.fillRect(x, y, boxSize, boxSize);
          
          // Crystal facets
          ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + boxSize/2, y + boxSize/2);
          ctx.lineTo(x, y + boxSize);
          ctx.fill();
          
          ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
          ctx.beginPath();
          ctx.moveTo(x + boxSize, y);
          ctx.lineTo(x + boxSize/2, y + boxSize/2);
          ctx.lineTo(x + boxSize, y + boxSize);
          ctx.fill();
          
          // Prismatic edge highlights
          ctx.strokeStyle = `hsl(${(time * 50 + x + y) % 360}, 80%, 70%)`;
          ctx.lineWidth = 1;
          ctx.strokeRect(x, y, boxSize, boxSize);
        } else if (snakeSkin === 'skin_galaxy') {
          // Enhanced galaxy with nebula clouds and twinkling stars
          const time = performance.now() / 300;
          const depth = Math.sin(time + x * 0.01 + y * 0.01) * 0.5 + 0.5;
          
          // Base galaxy gradient
          const gradient = ctx.createRadialGradient(x + boxSize/2, y + boxSize/2, 0, x + boxSize/2, y + boxSize/2, boxSize/2);
          gradient.addColorStop(0, `hsl(240, 100%, ${20 + depth * 40}%)`);
          gradient.addColorStop(0.5, `hsl(280, 80%, ${15 + depth * 30}%)`);
          gradient.addColorStop(1, `hsl(220, 90%, ${10 + depth * 20}%)`);
          
          ctx.fillStyle = gradient;
          ctx.fillRect(x, y, boxSize, boxSize);
          
          // Add nebula wisps
          ctx.fillStyle = `hsla(270, 60%, 50%, ${0.2 + depth * 0.3})`;
          const wispSize = boxSize * 0.3;
          ctx.beginPath();
          ctx.arc(x + boxSize * 0.3, y + boxSize * 0.7, wispSize, 0, Math.PI * 2);
          ctx.fill();
          
          // Twinkling stars
          if (Math.random() < 0.4) {
            const starBrightness = Math.random();
            ctx.fillStyle = `rgba(255, 255, 255, ${starBrightness})`;
            const starX = x + Math.random() * boxSize;
            const starY = y + Math.random() * boxSize;
            const starSize = starBrightness > 0.7 ? 2 : 1;
            ctx.fillRect(starX, starY, starSize, starSize);
            
            // Star twinkle cross pattern for bright stars
            if (starBrightness > 0.8) {
              ctx.fillRect(starX - 1, starY, 1, 1);
              ctx.fillRect(starX + 1, starY, 1, 1);
              ctx.fillRect(starX, starY - 1, 1, 1);
              ctx.fillRect(starX, starY + 1, 1, 1);
            }
          }
        } else if (snakeSkin === 'skin_plasma') {
          // Enhanced plasma with energy waves and electrical effects
          const time = performance.now() / 80;
          const plasmaX = x * 0.03;
          const plasmaY = y * 0.03;
          const plasma = Math.sin(plasmaX + time) + Math.sin(plasmaY + time) + Math.sin((plasmaX + plasmaY + time) * 0.5);
          const hue = (plasma * 60 + time * 20) % 360;
          const intensity = (plasma + 3) / 6; // Normalize to 0-1
          
          // Base plasma color
          ctx.fillStyle = `hsl(${hue}, 100%, ${50 + intensity * 30}%)`;
          ctx.fillRect(x, y, boxSize, boxSize);
          
          // Energy glow effect
          ctx.shadowColor = `hsl(${hue}, 100%, 70%)`;
          ctx.shadowBlur = 8 + intensity * 4;
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
          ctx.lineWidth = 1;
          ctx.strokeRect(x, y, boxSize, boxSize);
          
          // Electrical arcs
          if (Math.random() < 0.2) {
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(x + Math.random() * boxSize, y);
            ctx.lineTo(x + Math.random() * boxSize, y + boxSize);
            ctx.stroke();
          }
          
          ctx.shadowBlur = 0;
        } else if (snakeSkin === 'skin_metallic') {
          // Enhanced metallic chrome with realistic reflections
          const gradient = ctx.createLinearGradient(x, y, x + boxSize, y + boxSize);
          gradient.addColorStop(0, '#F0F0F0');
          gradient.addColorStop(0.2, '#FFFFFF');
          gradient.addColorStop(0.4, '#D0D0D0');
          gradient.addColorStop(0.6, '#E8E8E8');
          gradient.addColorStop(0.8, '#C0C0C0');
          gradient.addColorStop(1, '#A0A0A0');
          
          ctx.fillStyle = gradient;
          ctx.fillRect(x, y, boxSize, boxSize);
          
          // Chrome reflection lines
          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
          ctx.fillRect(x + boxSize/3, y + 1, 2, boxSize - 2);
          
          ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
          ctx.fillRect(x + 1, y + boxSize/3, boxSize - 2, 1);
          
          // Shadow for depth
          ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
          ctx.fillRect(x + boxSize - 2, y + 2, 2, boxSize - 2);
          ctx.fillRect(x + 2, y + boxSize - 2, boxSize - 2, 2);
        } else if (snakeSkin === 'daylight') {
          // Daylight skin with golden sunray effects
          const time = performance.now() / 1000;
          
          // Draw base segment with subtle glow
          ctx.shadowColor = snakeColor;
          ctx.shadowBlur = 3;
          ctx.fillRect(x, y, boxSize, boxSize);
          ctx.shadowBlur = 0;
          
          // Add floating golden particles/sunbeams
          const numParticles = 2 + Math.floor(Math.random() * 3); // 2-4 particles per segment
          
          for (let particle = 0; particle < numParticles; particle++) {
            const particleTime = time + (i * 0.3) + (particle * 0.5);
            const glow = Math.sin(particleTime * 1.5 + particle) * 0.3 + 0.7; // 0.4 to 1
            
            if (glow > 0.5) { // Only show when bright enough
              const particleX = x + (boxSize * 0.15) + (particle * boxSize * 0.3) + Math.sin(particleTime + particle) * 4;
              const particleY = y + (boxSize * 0.15) + ((particle % 2) * boxSize * 0.7) + Math.cos(particleTime * 0.8 + particle) * 4;
              const particleSize = 1.5 + glow * 2;
              
              // Create golden sunbeam color
              const goldHue = 45 + Math.sin(particleTime) * 10; // Golden yellow range
              const goldAlpha = glow * 0.6;
              
              ctx.fillStyle = `hsla(${goldHue}, 85%, 70%, ${goldAlpha})`;
              
              // Draw diamond-shaped sunbeam
              ctx.save();
              ctx.translate(particleX, particleY);
              ctx.rotate(particleTime + particle);
              
              ctx.beginPath();
              ctx.moveTo(0, -particleSize);
              ctx.lineTo(particleSize * 0.6, 0);
              ctx.lineTo(0, particleSize);
              ctx.lineTo(-particleSize * 0.6, 0);
              ctx.closePath();
              ctx.fill();
              
              // Add golden glow
              ctx.shadowColor = `hsla(${goldHue}, 90%, 75%, ${goldAlpha * 0.8})`;
              ctx.shadowBlur = particleSize * 1.5;
              ctx.fill();
              
              ctx.restore();
            }
          }
          
          // Add warm highlight on top edge
          ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
          ctx.fillRect(x, y, boxSize, 2);
          
          // Reset for next segment
          ctx.fillStyle = snakeColor;
          ctx.shadowBlur = 0;
        } else if (snakeSkin === 'starlight') {
          // Starlight skin with shimmering star effects
          const time = performance.now() / 1000;
          
          // Draw base segment
          ctx.fillRect(x, y, boxSize, boxSize);
          
          // Add multiple shimmering stars on each segment
          const numStars = 3 + Math.floor(Math.random() * 3); // 3-5 stars per segment
          
          for (let star = 0; star < numStars; star++) {
            const starTime = time + (i * 0.5) + (star * 0.3); // Offset each star's timing
            const shimmer = Math.sin(starTime * 2 + star) * 0.5 + 0.5; // 0 to 1
            
            if (shimmer > 0.3) { // Only show star when bright enough
              const starX = x + (boxSize * 0.2) + (star * boxSize * 0.25) + Math.sin(starTime + star) * 3;
              const starY = y + (boxSize * 0.2) + ((star % 2) * boxSize * 0.6) + Math.cos(starTime + star) * 3;
              const starSize = 1 + shimmer * 2;
              
              // Create shimmering star color
              const starHue = 200 + Math.sin(starTime) * 30;
              const starAlpha = shimmer * 0.8;
              
              ctx.fillStyle = `hsla(${starHue}, 90%, 85%, ${starAlpha})`;
              
              // Draw 4-pointed star
              ctx.save();
              ctx.translate(starX, starY);
              ctx.beginPath();
              
              // Star shape with 4 points
              for (let point = 0; point < 4; point++) {
                const angle = (point * Math.PI) / 2;
                const outerRadius = starSize;
                const innerRadius = starSize * 0.4;
                
                if (point === 0) {
                  ctx.moveTo(0, -outerRadius);
                } else {
                  ctx.lineTo(0, -outerRadius);
                }
                
                ctx.lineTo(innerRadius * Math.sin(angle + Math.PI/4), -innerRadius * Math.cos(angle + Math.PI/4));
                ctx.rotate(Math.PI / 2);
              }
              
              ctx.closePath();
              ctx.fill();
              
              // Add star glow
              ctx.shadowColor = `hsla(${starHue}, 90%, 85%, ${starAlpha * 0.5})`;
              ctx.shadowBlur = starSize * 2;
              ctx.fill();
              
              ctx.restore();
            }
          }
          
          // Reset for next segment
          ctx.fillStyle = snakeColor;
          ctx.shadowBlur = 0;
        } else {
          // Default square for any other combination
          ctx.fillRect(x, y, boxSize, boxSize);
        }
      });
      
      // Add theme-specific eyes to head (except for Pac-Man skin)
      if (snake[0] && snakeSkin !== 'pacman') {
        const head = snake[0];
        const cx = (head.x + 0.5) * boxSize;
        const cy = (head.y + 0.5) * boxSize;
        
        // Theme-specific eye styling
        if (snakeSkin === 'arcade') {
          // Retro arcade style - bright neon green eyes
          ctx.fillStyle = '#FFFF00';  // Yellow eyes for contrast
          ctx.shadowColor = '#FFFF00';
          ctx.shadowBlur = 5;
          const eyeSize = boxSize * 0.12;
          const eyeOffset = boxSize * 0.18;
          
          let eye1X, eye1Y, eye2X, eye2Y;
          if (direction === 'UP') {
            eye1X = cx - eyeOffset; eye1Y = cy - eyeOffset;
            eye2X = cx + eyeOffset; eye2Y = cy - eyeOffset;
          } else if (direction === 'DOWN') {
            eye1X = cx - eyeOffset; eye1Y = cy + eyeOffset;
            eye2X = cx + eyeOffset; eye2Y = cy + eyeOffset;
          } else if (direction === 'LEFT') {
            eye1X = cx - eyeOffset; eye1Y = cy - eyeOffset;
            eye2X = cx - eyeOffset; eye2Y = cy + eyeOffset;
          } else {
            eye1X = cx + eyeOffset; eye1Y = cy - eyeOffset;
            eye2X = cx + eyeOffset; eye2Y = cy + eyeOffset;
          }
          
          // Draw square eyes for retro feel
          ctx.fillRect(eye1X - eyeSize/2, eye1Y - eyeSize/2, eyeSize, eyeSize);
          ctx.fillRect(eye2X - eyeSize/2, eye2Y - eyeSize/2, eyeSize, eyeSize);
          ctx.shadowBlur = 0;
          
        } else {
          // Classic and other styles - standard black eyes
          ctx.fillStyle = '#000';
          const eyeSize = boxSize * 0.12;
          const eyeOffset = boxSize * 0.22;
          
          // Special eye styles for premium skins
          if (snakeSkin === 'skin_neon') {
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 5;
          } else if (snakeSkin === 'skin_synthwave') {
            ctx.fillStyle = '#FF00FF';
            ctx.shadowColor = '#FF00FF';
            ctx.shadowBlur = 4;
          } else if (snakeSkin === 'skin_golden') {
            ctx.fillStyle = '#FFD700';
            ctx.shadowColor = '#FFA500';
            ctx.shadowBlur = 3;
          } else if (snakeSkin === 'skin_diamond') {
            ctx.fillStyle = 'white';
            ctx.shadowColor = '#87CEEB';
            ctx.shadowBlur = 6;
          } else if (snakeSkin === 'skin_galaxy') {
            ctx.fillStyle = '#FFFFFF';
            ctx.shadowColor = '#9370DB';
            ctx.shadowBlur = 4;
          } else if (snakeSkin === 'skin_plasma') {
            const time = performance.now() / 200;
            const hue = (time * 100) % 360;
            ctx.fillStyle = `hsl(${hue}, 100%, 80%)`;
            ctx.shadowColor = `hsl(${hue}, 100%, 60%)`;
            ctx.shadowBlur = 5;
          } else if (snakeSkin === 'skin_metallic') {
            ctx.fillStyle = '#E8E8E8';
            ctx.shadowColor = '#C0C0C0';
            ctx.shadowBlur = 2;
          } else if (snakeSkin === 'skin_pixel') {
            ctx.fillStyle = '#1B5E20';
            ctx.shadowBlur = 0;
          } else {
            ctx.fillStyle = '#000';
            ctx.shadowBlur = 0;
          }
          
          let eye1X, eye1Y, eye2X, eye2Y;
          if (direction === 'UP') {
            eye1X = cx - eyeOffset; eye1Y = cy - eyeOffset;
            eye2X = cx + eyeOffset; eye2Y = cy - eyeOffset;
          } else if (direction === 'DOWN') {
            eye1X = cx - eyeOffset; eye1Y = cy + eyeOffset;
            eye2X = cx + eyeOffset; eye2Y = cy + eyeOffset;
          } else if (direction === 'LEFT') {
            eye1X = cx - eyeOffset; eye1Y = cy - eyeOffset;
            eye2X = cx - eyeOffset; eye2Y = cy + eyeOffset;
          } else {
            eye1X = cx + eyeOffset; eye1Y = cy - eyeOffset;
            eye2X = cx + eyeOffset; eye2Y = cy + eyeOffset;
          }
          
          // Draw eyes based on skin type
          if (snakeSkin === 'skin_pixel') {
            // Pixel art square eyes
            const pixelEyeSize = boxSize * 0.08;
            ctx.fillRect(eye1X - pixelEyeSize/2, eye1Y - pixelEyeSize/2, pixelEyeSize, pixelEyeSize);
            ctx.fillRect(eye2X - pixelEyeSize/2, eye2Y - pixelEyeSize/2, pixelEyeSize, pixelEyeSize);
          } else if (snakeSkin === 'skin_diamond') {
            // Diamond-shaped eyes
            ctx.save();
            ctx.translate(eye1X, eye1Y);
            ctx.rotate(Math.PI / 4);
            ctx.fillRect(-eyeSize/2, -eyeSize/2, eyeSize, eyeSize);
            ctx.restore();
            
            ctx.save();
            ctx.translate(eye2X, eye2Y);
            ctx.rotate(Math.PI / 4);
            ctx.fillRect(-eyeSize/2, -eyeSize/2, eyeSize, eyeSize);
            ctx.restore();
          } else {
            // Round eyes for other skins
            ctx.beginPath();
            ctx.arc(eye1X, eye1Y, eyeSize, 0, Math.PI * 2);
            ctx.arc(eye2X, eye2Y, eyeSize, 0, Math.PI * 2);
            ctx.fill();
          }
          
          ctx.shadowBlur = 0;
        }
      }
    }
  }

  // Draw food
  if (food && typeof food.x === 'number' && typeof food.y === 'number') {
    const fx = (food.x + 0.5) * boxSize;
    const fy = (food.y + 0.5) * boxSize;
    const currentTheme = document.body.className;
    const rootStyles = getComputedStyle(document.body);
    
    // Get theme-specific colors or defaults
    const foodColor = rootStyles.getPropertyValue('--food-color').trim() || '#E32727';
    const powerupColor = rootStyles.getPropertyValue('--powerup-color').trim() || '#FFD24D';
    
    if (food.type === 'normal') {
      ctx.beginPath(); 
      ctx.fillStyle = foodColor;
      
      if (currentTheme.includes('theme-pacman')) {
        // Draw as small dot like Pac-Man pellets
        ctx.arc(fx, fy, boxSize * 0.15, 0, 2 * Math.PI);
        ctx.fill();
      } else if (currentTheme.includes('theme-classic')) {
        // Draw as simple square food
        ctx.fillRect(fx - boxSize * 0.25, fy - boxSize * 0.25, boxSize * 0.5, boxSize * 0.5);
      } else if (currentTheme.includes('theme-neon')) {
        // Draw with glow effect
        ctx.shadowColor = foodColor;
        ctx.shadowBlur = 8;
        ctx.arc(fx, fy, boxSize * 0.3, 0, 2 * Math.PI);
        ctx.fill();
        ctx.shadowBlur = 0;
      } else if (currentTheme.includes('theme-arcade')) {
        // Draw as glowing golden square with border
        ctx.shadowColor = foodColor;
        ctx.shadowBlur = 10;
        
        // Main golden square
        ctx.fillRect(fx - boxSize * 0.25, fy - boxSize * 0.25, boxSize * 0.5, boxSize * 0.5);
        
        // Add bright center
        ctx.fillStyle = '#FFFF88';
        ctx.fillRect(fx - boxSize * 0.15, fy - boxSize * 0.15, boxSize * 0.3, boxSize * 0.3);
        
        // Add core pixel
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(fx - boxSize * 0.05, fy - boxSize * 0.05, boxSize * 0.1, boxSize * 0.1);
        
        ctx.shadowBlur = 0;
        ctx.fillStyle = foodColor; // Reset
      } else {
        // Default apple
        ctx.arc(fx, fy, boxSize * 0.4, 0, 2 * Math.PI);
        ctx.fill();
        // Apple stem
        ctx.fillStyle = '#3B7A14';
        ctx.fillRect(fx + boxSize * 0.1, fy - boxSize * 0.4, boxSize * 0.15, boxSize * 0.2);
      }
    } else if (food.type === 'power_double') {
      ctx.beginPath(); 
      ctx.fillStyle = powerupColor;
      
      if (currentTheme.includes('theme-pacman')) {
        // Draw as large power pellet (flashing)
        const flash = Math.floor(performance.now() / 300) % 2;
        ctx.globalAlpha = flash ? 1.0 : 0.6;
        ctx.arc(fx, fy, boxSize * 0.45, 0, 2 * Math.PI);
        ctx.fill();
        ctx.globalAlpha = 1.0;
      } else if (currentTheme.includes('theme-classic')) {
        // Draw as flashing square
        const flash = Math.floor(performance.now() / 200) % 2;
        ctx.globalAlpha = flash ? 1.0 : 0.5;
        ctx.fillRect(fx - boxSize * 0.4, fy - boxSize * 0.4, boxSize * 0.8, boxSize * 0.8);
        ctx.globalAlpha = 1.0;
      } else if (currentTheme.includes('theme-neon')) {
        // Draw with intense glow
        ctx.shadowColor = powerupColor;
        ctx.shadowBlur = 15;
        ctx.arc(fx, fy, boxSize * 0.38, 0, 2 * Math.PI);
        ctx.fill();
        ctx.shadowBlur = 0;
      } else if (currentTheme.includes('theme-arcade')) {
        // Draw as flashing magenta square
        const flash = Math.floor(performance.now() / 150) % 2;
        ctx.shadowColor = '#FF00FF';
        ctx.shadowBlur = flash ? 15 : 8;
        ctx.globalAlpha = flash ? 1.0 : 0.8;
        
        // Draw outer square
        ctx.fillRect(fx - boxSize * 0.4, fy - boxSize * 0.4, boxSize * 0.8, boxSize * 0.8);
        
        // Draw inner bright square
        ctx.fillStyle = '#FFAAFF';
        ctx.fillRect(fx - boxSize * 0.25, fy - boxSize * 0.25, boxSize * 0.5, boxSize * 0.5);
        
        // Draw center pixel
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(fx - boxSize * 0.1, fy - boxSize * 0.1, boxSize * 0.2, boxSize * 0.2);
        
        ctx.globalAlpha = 1.0;
        ctx.shadowBlur = 0;
        ctx.fillStyle = powerupColor; // Reset
      } else {
        // Default circle with text
        ctx.arc(fx, fy, boxSize * 0.38, 0, 2 * Math.PI); 
        ctx.fill();
        ctx.fillStyle = '#000'; 
        ctx.font = `${Math.max(10, boxSize*0.4)}px sans-serif`; 
        ctx.textAlign='center'; 
        ctx.textBaseline='middle'; 
        ctx.fillText('2x', fx, fy);
      }
    } else if (food.type === 'power_speed') {
      const speedPowerColor = rootStyles.getPropertyValue('--powerup-color').trim() || '#4FD1C5';
      ctx.beginPath(); 
      ctx.fillStyle = speedPowerColor;
      
      if (currentTheme.includes('theme-pacman')) {
        // Draw as large power pellet with different color (flashing)
        const flash = Math.floor(performance.now() / 250) % 2;
        ctx.globalAlpha = flash ? 1.0 : 0.7;
        ctx.arc(fx, fy, boxSize * 0.45, 0, 2 * Math.PI);
        ctx.fill();
        ctx.globalAlpha = 1.0;
      } else if (currentTheme.includes('theme-classic')) {
        // Draw as flashing triangle
        const flash = Math.floor(performance.now() / 150) % 2;
        ctx.globalAlpha = flash ? 1.0 : 0.6;
        ctx.beginPath();
        ctx.moveTo(fx, fy - boxSize * 0.4);
        ctx.lineTo(fx + boxSize * 0.35, fy + boxSize * 0.2);
        ctx.lineTo(fx - boxSize * 0.35, fy + boxSize * 0.2);
        ctx.closePath();
        ctx.fill();
        ctx.globalAlpha = 1.0;
      } else if (currentTheme.includes('theme-neon')) {
        // Draw with pulsing glow
        const pulse = Math.sin(performance.now() / 300) * 5 + 15;
        ctx.shadowColor = speedPowerColor;
        ctx.shadowBlur = pulse;
        ctx.arc(fx, fy, boxSize * 0.38, 0, 2 * Math.PI);
        ctx.fill();
        ctx.shadowBlur = 0;
      } else if (currentTheme.includes('theme-arcade')) {
        // Draw as flashing cyan triangle
        const flash = Math.floor(performance.now() / 120) % 2;
        ctx.shadowColor = '#00FFFF';
        ctx.shadowBlur = flash ? 12 : 6;
        ctx.globalAlpha = flash ? 1.0 : 0.7;
        
        // Draw triangle pointing right (speed direction)
        ctx.beginPath();
        ctx.moveTo(fx + boxSize * 0.3, fy);
        ctx.lineTo(fx - boxSize * 0.2, fy - boxSize * 0.25);
        ctx.lineTo(fx - boxSize * 0.2, fy + boxSize * 0.25);
        ctx.closePath();
        ctx.fill();
        
        // Add inner bright triangle
        ctx.fillStyle = '#AAFFFF';
        ctx.beginPath();
        ctx.moveTo(fx + boxSize * 0.15, fy);
        ctx.lineTo(fx - boxSize * 0.1, fy - boxSize * 0.15);
        ctx.lineTo(fx - boxSize * 0.1, fy + boxSize * 0.15);
        ctx.closePath();
        ctx.fill();
        
        ctx.globalAlpha = 1.0;
        ctx.shadowBlur = 0;
        ctx.fillStyle = speedPowerColor; // Reset
      } else {
        // Default circle with lightning
        ctx.arc(fx, fy, boxSize * 0.38, 0, 2*Math.PI); 
        ctx.fill();
        ctx.fillStyle = '#000'; 
        ctx.font = `${Math.max(10, boxSize*0.45)}px sans-serif`; 
        ctx.textAlign='center'; 
        ctx.textBaseline='middle'; 
        ctx.fillText('âš¡', fx, fy);
      }
    }
  }
  
  // Update and draw trail particles
  updateTrailParticles();
}

function handleFoodEaten() {
  // Store food position for special effects before resetting
  const foodX = food.x * boxSize + boxSize/2;
  const foodY = food.y * boxSize + boxSize/2;
  
  // Play appropriate sound effect
  try {
    if (food.type === 'power_double' || food.type === 'power_speed') {
      powerSound.currentTime = 0; // Reset sound to start
      powerSound.play();
    } else {
      eatSound.currentTime = 0; // Reset sound to start
      eatSound.play();
    }
  } catch (e) {
    console.log('Sound playback failed:', e);
  }
  
  // Add special effects when food is eaten (always enabled now)
  
  // Arena Energy level update (no flicker - toned down)
  updateArenaEnergyLevel();
  
  // Combo visuals
  updateComboChain();
  
  // Score milestone celebration check
  checkScoreMilestone();
  
  let points = 25;  // Increased from 10
  if (food.type === 'power_double') {
    multiplierActive = true;
    points = 50;  // Increased from 20
    multiplierTimeLeft = 10;
    // Set 2x points for 10 seconds with timer display
    clearTimeout(multiplierInterval);
    const startTime = Date.now();
    const updateTimer = () => {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const remaining = Math.max(0, 10 - elapsed);
      updateMultiplierDisplay(remaining);
      if (remaining > 0) {
        setTimeout(updateTimer, 1000);
      }
    };
    updateTimer();
    multiplierInterval = setTimeout(() => {
      multiplierActive = false;
      updateMultiplierDisplay(0);
      console.log('2x points expired');
    }, 10000);
  } else if (food.type === 'power_speed') {
    points = 40;  // Increased from 15
    speedTimeLeft = 8;
    // Set 1.25x speed for 8 seconds with timer display (reduced from 1.5x)
    speed = Math.max(50, Math.floor(speed / 1.25)); // 1.25x speed (more manageable)
    clearInterval(gameInterval);
    gameInterval = setInterval(gameLoop, speed);
    clearTimeout(speedInterval);
    const startTime = Date.now();
    const updateTimer = () => {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const remaining = Math.max(0, 8 - elapsed);
      updateSpeedDisplay(remaining);
      if (remaining > 0) {
        setTimeout(updateTimer, 1000);
      }
    };
    updateTimer();
    speedInterval = setTimeout(() => {
      speed = baseSpeed;
      clearInterval(gameInterval);
      gameInterval = setInterval(gameLoop, speed);
      updateSpeedDisplay(0);
      console.log('1.25x speed expired');
    }, 8000);
  }
  
  if (multiplierActive || activePowerups.double_points > 0) points *= 2;
  score += points;
  foodsEaten++;
  
  // Update current foods eaten in stats
  const stats = JSON.parse(localStorage.getItem('pythonixStats') || '{}');
  stats.totalFoodsEaten = (stats.totalFoodsEaten || 0) + 1;
  localStorage.setItem('pythonixStats', JSON.stringify(stats));
  updateStatsDisplay();
  
  // Time attack mode: add 1 second per food eaten
  if (gameMode === 'time') {
    gameTimeLeft += 1;
    updateTimeDisplay();
    console.log('Time attack: +1 second! New time:', gameTimeLeft);
  }
  
  // Progressive difficulty for hard mode
  if (gameMode === 'hard' && foodsEaten % 5 === 0) {
    // Every 5 foods, increase speed slightly
    speed = Math.max(50, speed - 5);
    clearInterval(gameInterval);
    gameInterval = setInterval(gameLoop, speed);
    console.log('Hard mode speed increased to:', speed);
  }
  
  // Update UI elements - fix selector
  const scoreBoard = document.getElementById('scoreBoard');
  if (scoreBoard) scoreBoard.textContent = 'Score: ' + score;
  updatePowerupDisplay();
  
  food = randomFood();
}

// New Visual Effects System
let comboCount = 0;
let lastFoodTime = 0;
let arenaEnergyLevel = 0;

function initializeComboSystem() {
  comboCount = 0;
  lastFoodTime = 0;
}

function triggerArenaEnergyFlicker() {
  const canvas = document.getElementById('gameCanvas');
  if (canvas && canvas.classList.contains('arena-energy-border')) {
    canvas.classList.add('arena-energy-eating');
    setTimeout(() => {
      canvas.classList.remove('arena-energy-eating');
    }, 300);
  }
}

function updateArenaEnergyLevel() {
  const canvas = document.getElementById('gameCanvas');
  if (!canvas) return;
  
  // Remove existing level classes
  for (let i = 1; i <= 5; i++) {
    canvas.classList.remove(`arena-energy-level-${i}`);
  }
  
  // Calculate level based on score
  let level = 0;
  if (score >= 100) level = 1;
  if (score >= 300) level = 2;
  if (score >= 600) level = 3;
  if (score >= 1000) level = 4;
  if (score >= 2000) level = 5;
  
  if (level > 0) {
    canvas.classList.add(`arena-energy-level-${level}`);
  }
  
  arenaEnergyLevel = level;
}

function updateComboChain() {
  const currentTime = Date.now();
  const timeDiff = currentTime - lastFoodTime;
  
  // Combo visuals only trigger after 500 points or eating very fast (2 seconds)
  const canShowCombo = score >= 500 || timeDiff < 2000;
  
  // If eaten within 1.5 seconds, increase combo
  if (timeDiff < 1500 && lastFoodTime > 0) {
    comboCount++;
    if (comboCount >= 3 && canShowCombo) {
      triggerComboEffect();
    }
  } else {
    comboCount = 1; // Reset combo
  }
  
  lastFoodTime = currentTime;
}

function triggerComboEffect() {
  const canvas = document.getElementById('gameCanvas');
  const rect = canvas.getBoundingClientRect();
  
  // Create combo text
  const comboText = document.createElement('div');
  comboText.textContent = `${comboCount}x COMBO!`;
  comboText.style.cssText = `
    position: fixed;
    left: ${rect.left + rect.width/2}px;
    top: ${rect.top + 50}px;
    transform: translateX(-50%);
    font-family: 'Arial Black', Arial, sans-serif;
    font-size: 2rem;
    font-weight: 900;
    color: #FFD700;
    text-shadow: 
      0 0 10px #FFD700,
      0 0 20px #FFA500,
      2px 2px 0px #FF6B00;
    z-index: 1000;
    pointer-events: none;
    animation: comboTextAnimation 1.5s ease-out forwards;
  `;
  
  document.body.appendChild(comboText);
  
  // Create combo particles
  for (let i = 0; i < 8; i++) {
    const particle = document.createElement('div');
    particle.className = 'combo-particle';
    
    const angle = (i / 8) * Math.PI * 2;
    const distance = 60 + Math.random() * 40;
    const dx = Math.cos(angle) * distance;
    const dy = Math.sin(angle) * distance;
    
    particle.style.cssText = `
      position: fixed;
      left: ${rect.left + rect.width/2}px;
      top: ${rect.top + rect.height/2}px;
      width: 8px;
      height: 8px;
      background: radial-gradient(circle, #FFD700, #FFA500);
      border-radius: 50%;
      z-index: 999;
      pointer-events: none;
      animation: comboParticleAnimation 1s ease-out forwards;
    `;
    
    particle.style.setProperty('--dx', dx + 'px');
    particle.style.setProperty('--dy', dy + 'px');
    
    document.body.appendChild(particle);
    
    setTimeout(() => {
      if (particle.parentNode) {
        particle.parentNode.removeChild(particle);
      }
    }, 1000);
  }
  
  setTimeout(() => {
    if (comboText.parentNode) {
      comboText.parentNode.removeChild(comboText);
    }
  }, 1500);
}

function checkScoreMilestone() {
  const milestones = [100, 250, 500, 750, 1000, 1500, 2000, 3000, 5000];
  
  for (const milestone of milestones) {
    if (score === milestone) {
      triggerMilestoneCelebration(milestone);
      break;
    }
  }
}

function triggerMilestoneCelebration(milestone) {
  const canvas = document.getElementById('gameCanvas');
  const rect = canvas.getBoundingClientRect();
  
  // Create milestone text
  const milestoneText = document.createElement('div');
  milestoneText.textContent = `${milestone} POINTS!`;
  milestoneText.style.cssText = `
    position: fixed;
    left: ${rect.left + rect.width/2}px;
    top: ${rect.top + rect.height/2}px;
    transform: translate(-50%, -50%);
    font-family: 'Arial Black', Arial, sans-serif;
    font-size: 3rem;
    font-weight: 900;
    color: #FF1493;
    text-shadow: 
      0 0 15px #FF1493,
      0 0 30px #FF69B4,
      0 0 45px #FFB6C1,
      3px 3px 0px #8B008B;
    z-index: 1000;
    pointer-events: none;
    animation: milestoneTextAnimation 2s ease-out forwards;
  `;
  
  document.body.appendChild(milestoneText);
  
  // Create celebration particles based on milestone level
  const particleCount = Math.min(milestone / 50, 20);
  for (let i = 0; i < particleCount; i++) {
    const particle = document.createElement('div');
    
    const angle = (i / particleCount) * Math.PI * 2;
    const distance = 80 + Math.random() * 60;
    const dx = Math.cos(angle) * distance;
    const dy = Math.sin(angle) * distance;
    
    const hue = Math.random() * 360;
    const size = 6 + Math.random() * 8;
    
    particle.style.cssText = `
      position: fixed;
      left: ${rect.left + rect.width/2}px;
      top: ${rect.top + rect.height/2}px;
      width: ${size}px;
      height: ${size}px;
      background: radial-gradient(circle, hsl(${hue}, 100%, 70%), hsl(${hue + 60}, 100%, 50%));
      border-radius: 50%;
      z-index: 999;
      pointer-events: none;
      animation: milestoneParticleAnimation 2s ease-out forwards;
    `;
    
    particle.style.setProperty('--dx', dx + 'px');
    particle.style.setProperty('--dy', dy + 'px');
    particle.style.setProperty('--rotation', Math.random() * 360 + 'deg');
    
    document.body.appendChild(particle);
    
    setTimeout(() => {
      if (particle.parentNode) {
        particle.parentNode.removeChild(particle);
      }
    }, 2000);
  }
  
  setTimeout(() => {
    if (milestoneText.parentNode) {
      milestoneText.parentNode.removeChild(milestoneText);
    }
  }, 2000);
}

function createPortalFoodEffect(x, y) {
  // Always enabled now - no need to check owned items
  
  const canvas = document.getElementById('gameCanvas');
  const rect = canvas.getBoundingClientRect();
  const foodX = rect.left + x;
  const foodY = rect.top + y;
  
  // Get theme-based portal color
  const theme = document.body.className || 'theme-arcade';
  let portalColor = 'rgba(0, 255, 255, 0.8)'; // Default cyan
  
  if (theme.includes('theme-arcade')) {
    portalColor = 'rgba(255, 0, 255, 0.8)'; // Magenta for arcade
  } else if (theme.includes('theme-neon')) {
    portalColor = 'rgba(0, 255, 255, 0.8)'; // Cyan for neon
  } else if (theme.includes('theme-sunset')) {
    portalColor = 'rgba(255, 165, 0, 0.8)'; // Orange for sunset
  } else if (theme.includes('theme-ocean')) {
    portalColor = 'rgba(0, 150, 255, 0.8)'; // Ocean blue
  } else if (theme.includes('theme-forest')) {
    portalColor = 'rgba(50, 255, 50, 0.8)'; // Forest green
  } else if (theme.includes('theme-night')) {
    portalColor = 'rgba(138, 43, 226, 0.8)'; // Purple for night
  }
  
  // Create portal ring effect
  const portal = document.createElement('div');
  portal.style.cssText = `
    position: fixed;
    left: ${foodX}px;
    top: ${foodY}px;
    width: 0px;
    height: 0px;
    border: 3px solid ${portalColor};
    border-radius: 50%;
    z-index: 998;
    pointer-events: none;
    animation: portalRingAnimation 0.8s ease-out forwards;
  `;
  
  document.body.appendChild(portal);
  
  // Create sparkle particles
  for (let i = 0; i < 6; i++) {
    setTimeout(() => {
      const sparkle = document.createElement('div');
      sparkle.style.cssText = `
        position: fixed;
        left: ${foodX + (Math.random() - 0.5) * 40}px;
        top: ${foodY + (Math.random() - 0.5) * 40}px;
        width: 4px;
        height: 4px;
        background: radial-gradient(circle, #00FFFF, #FFFFFF);
        border-radius: 50%;
        z-index: 997;
        pointer-events: none;
        animation: sparkleAnimation 0.6s ease-out forwards;
      `;
      
      document.body.appendChild(sparkle);
      
      setTimeout(() => {
        if (sparkle.parentNode) {
          sparkle.parentNode.removeChild(sparkle);
        }
      }, 600);
    }, i * 100);
  }
  
  setTimeout(() => {
    if (portal.parentNode) {
      portal.parentNode.removeChild(portal);
    }
  }, 800);
}

function triggerSpawnAnimation() {
  // Always enabled now - no need to check owned items
  
  const canvas = document.getElementById('gameCanvas');
  canvas.style.filter = 'brightness(0)';
  canvas.style.transition = 'filter 1s ease-out';
  
  setTimeout(() => {
    canvas.style.filter = 'brightness(1)';
    
    // Create materialization effect
    const rect = canvas.getBoundingClientRect();
    for (let i = 0; i < 12; i++) {
      setTimeout(() => {
        const pixel = document.createElement('div');
        pixel.style.cssText = `
          position: fixed;
          left: ${rect.left + Math.random() * rect.width}px;
          top: ${rect.top + Math.random() * rect.height}px;
          width: 8px;
          height: 8px;
          background: radial-gradient(circle, #00FF00, #66FF66);
          z-index: 1000;
          pointer-events: none;
          animation: spawnPixelAnimation 0.8s ease-out forwards;
        `;
        
        document.body.appendChild(pixel);
        
        setTimeout(() => {
          if (pixel.parentNode) {
            pixel.parentNode.removeChild(pixel);
          }
        }, 800);
      }, i * 80);
    }
    
    setTimeout(() => {
      canvas.style.transition = '';
    }, 1000);
  }, 200);
}

function triggerDeathEffect() {
  const canvas = document.getElementById('gameCanvas');
  const rect = canvas.getBoundingClientRect();
  
  // Add death effect class for screen shake
  document.body.classList.add('death-effect-active');
  
  // Create death flash overlay
  const deathFlash = document.createElement('div');
  deathFlash.style.cssText = `
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: radial-gradient(circle, rgba(255,0,0,0.8) 0%, rgba(255,0,0,0.3) 50%, transparent 100%);
    z-index: 999;
    pointer-events: none;
    animation: deathFlash 1s ease-out forwards;
  `;
  document.body.appendChild(deathFlash);
  
  // Create particle explosion from snake head position
  if (snake && snake.length > 0) {
    const head = snake[0];
    const centerX = rect.left + (head.x + 0.5) * boxSize;
    const centerY = rect.top + (head.y + 0.5) * boxSize;
    
    // Create explosion particles
    for (let i = 0; i < 20; i++) {
      const particle = document.createElement('div');
      const angle = (i / 20) * Math.PI * 2;
      const distance = 100 + Math.random() * 150;
      const dx = Math.cos(angle) * distance;
      const dy = Math.sin(angle) * distance;
      const rotation = Math.random() * 720 - 360;
      
      particle.style.cssText = `
        position: fixed;
        left: ${centerX}px;
        top: ${centerY}px;
        width: 8px;
        height: 8px;
        background: radial-gradient(circle, #FF0000, #FF4444);
        border-radius: 50%;
        z-index: 998;
        pointer-events: none;
        animation: deathParticleExplosion 1.5s ease-out forwards;
      `;
      
      particle.style.setProperty('--dx', dx + 'px');
      particle.style.setProperty('--dy', dy + 'px');
      particle.style.setProperty('--rotation', rotation + 'deg');
      
      document.body.appendChild(particle);
      
      setTimeout(() => {
        if (particle.parentNode) {
          particle.parentNode.removeChild(particle);
        }
      }, 1500);
    }
    
    // Create shockwave effect
    const shockwave = document.createElement('div');
    shockwave.style.cssText = `
      position: fixed;
      left: ${centerX}px;
      top: ${centerY}px;
      width: 0px;
      height: 0px;
      border: 3px solid rgba(255, 0, 0, 0.8);
      border-radius: 50%;
      z-index: 997;
      pointer-events: none;
      animation: deathShockwave 1s ease-out forwards;
    `;
    
    document.body.appendChild(shockwave);
    
    setTimeout(() => {
      if (shockwave.parentNode) {
        shockwave.parentNode.removeChild(shockwave);
      }
    }, 1000);
  }
  
  // Cleanup after animation
  setTimeout(() => {
    document.body.classList.remove('death-effect-active');
    if (deathFlash.parentNode) deathFlash.parentNode.removeChild(deathFlash);
  }, 1500); // Reduced cleanup time since no text to wait for
}

async function endGame() {
  isGameOver = true;
  clearInterval(gameInterval);
  
  // Trigger epic death effect (always enabled now)
  triggerDeathEffect();
  
  // ===== CrazyGames SDK: Game ended =====
  if (crazygames) {
    crazygames.game.gameplayStop();
    console.log("CrazyGames: Gameplay stopped");
  }
  
  // Play game over sound
  try {
    gameOverSound.currentTime = 0; // Reset sound to start
    gameOverSound.play();
  } catch (e) {
    console.log('Game over sound playback failed:', e);
  }
  
  // Update high score and leaderboard
  const highScore = parseInt(localStorage.getItem('pythonixHighScore') || '0');
  if (score > highScore) {
    localStorage.setItem('pythonixHighScore', score);
    console.log("ðŸŽ‰ New high score:", score);
  }
  
  // Save to leaderboard using the new function
  await saveScoreWithLeaderboard(score);
  
  // Award coins based on score
  awardCoinsForScore(score);
  
  // Stop playtime tracking and award completion bonus
  stopPlaytimeTracking();
  
  // Update stats and check for achievement rewards
  const currentStats = JSON.parse(localStorage.getItem('pythonixStats') || '{"gamesPlayed": 0, "totalFoodsEaten": 0}');
  currentStats.gamesPlayed++;
  currentStats.totalFoodsEaten += foodsEaten;
  localStorage.setItem('pythonixStats', JSON.stringify(currentStats));
  
  // Update games played counter for arcade display
  localStorage.setItem('pythonixGamesPlayed', currentStats.gamesPlayed.toString());
  
  // Check achievement rewards
  checkAchievementRewards(score, currentStats);
  
  // Check daily challenges
  const session = JSON.parse(localStorage.getItem('pythonixCurrentSession') || '{}');
  const survivalTime = session.startTime ? Math.floor((Date.now() - session.startTime) / 1000) : 0;
  checkDailyChallenges(score, foodsEaten, survivalTime);
  
  // ===== CrazyGames SDK: Show ad before allowing restart =====
  if (crazygames) {
    showAdBeforeRestart();
  }
  
  // Show game over screen
  const gameOverScreen = document.getElementById('gameOverScreen');
  if (gameOverScreen) {
    const gameOverText = gameOverScreen.querySelector('#gameOverText');
    if (gameOverText) gameOverText.textContent = `Final Score: ${score}`;
    gameOverScreen.style.display = 'flex';
  } else {
    // If no game over screen, return to start menu after showing score
    alert(`Game Over! Score: ${score}`);
    returnToStartScreen();
  }
  
  // Hide powerup display
  const powerupDisplay = document.getElementById('powerupDisplay');
  if (powerupDisplay) powerupDisplay.style.display = 'none';
}

function returnToStartScreen() {
  // Stop game over sound immediately when returning to menu
  try {
    gameOverSound.pause();
    gameOverSound.currentTime = 0;
  } catch (e) {
    console.log('Could not stop game over sound:', e);
  }

  // Hide game elements
  document.body.classList.remove('game-active');
  
  // Hide powerup display
  const powerupDisplay = document.getElementById('powerupDisplay');
  if (powerupDisplay) powerupDisplay.style.display = 'none';
  
  // Show intro screen
  const introScreen = document.getElementById('introScreen');
  if (introScreen) {
    introScreen.style.display = 'flex';
  }
  
  // Reset menu selection
  currentMenuIndex = 0;
  updateMenuSelection();
  
  // Reset music started flag and start background music when returning to start menu
  musicStarted = false;
  playBackgroundMusic();
}

// Make sure the navbar buttons work
document.addEventListener('DOMContentLoaded', function() {
  // Find achievements button and add click handler (preserving sound effects)
  const achievementsBtn = document.getElementById('showAchievements');
  if (achievementsBtn) {
    const originalClick = achievementsBtn.onclick;
    achievementsBtn.onclick = function(event) {
      if (originalClick) originalClick.call(this, event);
      showAchievements();
    };
    console.log('Achievements button found and connected');
  }
  
  // Find history button and add click handler (preserving sound effects)
  const historyBtn = document.getElementById('showHistory');
  if (historyBtn) {
    const originalClick = historyBtn.onclick;
    historyBtn.onclick = function(event) {
      if (originalClick) originalClick.call(this, event);
      showGameHistory();
    };
    console.log('History button found and connected');
  }
});

// Update all stats displays
function updateStatsDisplay() {
  // Update high score
  const highScore = parseInt(localStorage.getItem('pythonixHighScore') || '0');
  const highScoreNav = document.getElementById('highScoreNav');
  if (highScoreNav) highScoreNav.textContent = 'High Score: ' + highScore;
  
  // Update total foods eaten from localStorage
  const totalStats = JSON.parse(localStorage.getItem('pythonixStats') || '{}');
  const totalFoodsEaten = totalStats.totalFoodsEaten || 0;
  const foodsEatenNav = document.getElementById('foodsEatenNav');
  if (foodsEatenNav) foodsEatenNav.textContent = 'Foods Eaten: ' + totalFoodsEaten;
}

// Update multiplier timer display
function updateMultiplierDisplay(timeLeft) {
  const multiplierNav = document.getElementById('multiplierNav');
  if (multiplierNav) {
    if (multiplierActive && timeLeft > 0) {
      multiplierNav.textContent = `2x Points (${timeLeft}s)`;
      multiplierNav.style.display = 'inline';
    } else {
      multiplierNav.style.display = 'none';
    }
  }
}

// Update speed timer display
function updateSpeedDisplay(timeLeft) {
  const speedNav = document.getElementById('speedNav');
  if (!speedNav) {
    // Create speed display if it doesn't exist
    const navStats = document.querySelector('.nav-stats');
    if (navStats) {
      const speedSpan = document.createElement('span');
      speedSpan.className = 'stat-item';
      speedSpan.id = 'speedNav';
      speedSpan.style.display = 'none';
      navStats.appendChild(speedSpan);
    }
  }
  const speedDisplay = document.getElementById('speedNav');
  if (speedDisplay) {
    if (speed < baseSpeed && timeLeft > 0) {
      speedDisplay.textContent = `1.5x Speed (${timeLeft}s)`;
      speedDisplay.style.display = 'inline';
    } else {
      speedDisplay.style.display = 'none';
    }
  }
}

// Initialize game mode specific features
function initGameMode() {
  const gameModeSelect = document.getElementById('gameMode');
  const selectedMode = gameModeSelect ? gameModeSelect.value : 'classic';
  gameMode = selectedMode;
  
  // Clear any existing game mode timers
  clearInterval(gameTimeInterval);
  
  // Show/hide mode-specific controls
  const timeAttackDisplay = document.getElementById('timeAttackDisplay');
  
  if (gameMode === 'time') {
    if (timeAttackDisplay) timeAttackDisplay.style.display = 'inline';
    // Initialize time attack (60 seconds, +1 second per food)
    gameTimeLeft = 60;
    updateTimeDisplay();
    gameTimeInterval = setInterval(updateGameTimer, 1000);
  } else {
    if (timeAttackDisplay) timeAttackDisplay.style.display = 'none';
    
    // Set different starting speeds for classic vs hard mode
    if (gameMode === 'hard') {
      // Hard mode: starts faster and gets progressively harder
      baseSpeed = 120; // Faster starting speed
      speed = baseSpeed;
    } else {
      // Classic mode: normal starting speed
      baseSpeed = 150;
      speed = baseSpeed;
    }
  }
}

// Update time attack display
function updateTimeDisplay() {
  const timeLeftSpan = document.getElementById('timeLeft');
  if (timeLeftSpan && gameMode === 'time') {
    timeLeftSpan.textContent = gameTimeLeft;
  }
}

// Game timer for time attack mode
function updateGameTimer() {
  if (gameMode === 'time' && gameTimeLeft > 0) {
    gameTimeLeft--;
    updateTimeDisplay();
    if (gameTimeLeft <= 0) {
      endGame();
    }
  }
}

// Update endGame function to save game data for history/achievements
const originalEndGame = endGame;
endGame = function() {
  // Save game data
  const stats = JSON.parse(localStorage.getItem('pythonixStats') || '{"gamesPlayed": 0, "totalFoodsEaten": 0, "totalScore": 0}');
  const gameHistory = JSON.parse(localStorage.getItem('pythonixGameHistory') || '[]');
  
  // Update stats
  stats.gamesPlayed = (stats.gamesPlayed || 0) + 1;
  stats.totalFoodsEaten = (stats.totalFoodsEaten || 0) + (foodsEaten || 0);
  stats.totalScore = (stats.totalScore || 0) + (score || 0);
  
  // Save game to history
  gameHistory.push({
    score: score || 0,
    foodsEaten: foodsEaten || 0,
    mode: gameMode || 'Classic',
    date: new Date().toISOString()
  });
  
  // Keep only last 50 games
  if (gameHistory.length > 50) {
    gameHistory.splice(0, gameHistory.length - 50);
  }
  
  // Save to localStorage
  localStorage.setItem('pythonixStats', JSON.stringify(stats));
  localStorage.setItem('pythonixGameHistory', JSON.stringify(gameHistory));
  
  console.log('Game saved - Score:', score, 'Foods:', foodsEaten, 'Stats:', stats);
  
  // Call original endGame
  if (originalEndGame) originalEndGame();
};

// Add missing core game functions
function initGame() {
  console.log('Initializing game...');
  
  // Initialize canvas and board
  resizeCanvas();
  
  // Initialize game variables
  snake = [{x: Math.floor(boardWidth/2), y: Math.floor(boardHeight/2)}];
  direction = 'RIGHT';
  window.direction = 'RIGHT';
  window.pendingDirection = null;
  score = 0;
  foodsEaten = 0;
  isGameOver = false;
  isPaused = false;
  multiplierActive = false;
  speed = baseSpeed;
  
  // Clear any existing timers
  clearTimeout(multiplierInterval);
  clearTimeout(speedInterval);
  
  // Initialize food
  food = randomFood();
  
  // Update all displays
  updateStatsDisplay();
  const scoreBoard = document.getElementById('scoreBoard');
  if (scoreBoard) scoreBoard.textContent = 'Score: ' + score;
  updatePowerupDisplay();
  
  // Initialize game mode specific features
  initGameMode();
  
  // Trigger spawn animation
  triggerSpawnAnimation();
  
  // Ensure keyboard handler is connected
  console.log('Game initialized - Snake at:', snake[0], 'Direction:', direction);
  
  // Start game loop
  clearInterval(gameInterval);
  gameInterval = setInterval(gameLoop, speed || 150);
  
  // Draw initial board
  drawBoard();
}

function startGame() {
  console.log('Starting game...');
  
  // ===== CrazyGames SDK: Game started =====
  if (crazygames) {
    crazygames.game.gameplayStart();
    console.log("CrazyGames: Gameplay started");
  }
  
  // Initialize session tracking
  localStorage.setItem('pythonixCurrentSession', JSON.stringify({
    milestonesEarned: [],
    startTime: Date.now()
  }));
  
  // Start playtime tracking
  startPlaytimeTracking();
  
  // Hide intro screen
  const introScreen = document.getElementById('introScreen');
  if (introScreen) {
    introScreen.style.display = 'none';
  }
  
  // Show game elements by adding class to body
  document.body.classList.add('game-active');
  
  // Show powerup display
  const powerupDisplay = document.getElementById('powerupDisplay');
  if (powerupDisplay) powerupDisplay.style.display = 'block';
  
  // Initialize the game
  initGame();
}

function restartGame() {
  console.log('Restarting game directly...');
  
  // Stop game over sound immediately
  try {
    gameOverSound.pause();
    gameOverSound.currentTime = 0;
  } catch (e) {
    console.log('Could not stop game over sound:', e);
  }
  
  // Hide game over screen
  const gameOverScreen = document.getElementById('gameOverScreen');
  if (gameOverScreen) {
    gameOverScreen.style.display = 'none';
  }
  
  // Restart the game directly (don't go back to start screen)
  initGame();
  
  // Make sure game elements stay visible
  document.body.classList.add('game-active');
  
  // Show powerup display
  const powerupDisplay = document.getElementById('powerupDisplay');
  if (powerupDisplay) powerupDisplay.style.display = 'block';
}

// Global function to toggle instructions
function toggleInstructions() {
  const instructionsContent = document.getElementById('instructionsContent');
  if (instructionsContent) {
    if (instructionsContent.style.display === 'none' || instructionsContent.style.display === '') {
      instructionsContent.style.display = 'flex';
      instructionsContent.classList.add('show');
    } else {
      instructionsContent.style.display = 'none';
      instructionsContent.classList.remove('show');
    }
  }
}

// Menu navigation variables
let currentMenuIndex = 0;
const menuItems = ['startOption', 'shopOption', 'customizeOption', 'instructionsOption', 'leaderboardOption'];

// Update menu selection
function updateMenuSelection() {
  menuItems.forEach((id, index) => {
    const item = document.getElementById(id);
    if (item) {
      if (index === currentMenuIndex) {
        item.classList.add('active');
      } else {
        item.classList.remove('active');
      }
    }
  });
}

// Update arcade-style high score display
function updateArcadeHighScore() {
  const highScore = parseInt(localStorage.getItem('pythonixHighScore') || '0');
  const arcadeDisplay = document.getElementById('arcadeHighScore');
  if (arcadeDisplay) {
    // Format as 10-digit number with leading zeros
    const formattedScore = highScore.toString().padStart(10, '0');
    arcadeDisplay.textContent = formattedScore;
  }
  
  // Update snake length display (safely)
  const snakeLengthDisplay = document.getElementById('snakeLength');
  if (snakeLengthDisplay) {
    // Check if snake exists and is initialized, otherwise use default
    let currentLength = 3; // Default starting length
    if (typeof snake !== 'undefined' && snake && snake.length) {
      currentLength = snake.length;
    }
    const formattedLength = currentLength.toString().padStart(4, '0');
    snakeLengthDisplay.textContent = formattedLength;
  }
  
  // Update total games played
  const totalGamesDisplay = document.getElementById('totalGames');
  if (totalGamesDisplay) {
    const gamesPlayed = parseInt(localStorage.getItem('pythonixGamesPlayed') || '0');
    const formattedGames = gamesPlayed.toString().padStart(3, '0');
    totalGamesDisplay.textContent = formattedGames;
  }
}

// Handle menu navigation
function handleMenuNavigation(event) {
  console.log('Key pressed:', event.code);
  if (event.code === 'ArrowUp') {
    event.preventDefault();
    playButtonHover(); // Play hover sound on navigation
    currentMenuIndex = (currentMenuIndex - 1 + menuItems.length) % menuItems.length;
    updateMenuSelection();
  } else if (event.code === 'ArrowDown') {
    event.preventDefault();
    playButtonHover(); // Play hover sound on navigation
    currentMenuIndex = (currentMenuIndex + 1) % menuItems.length;
    updateMenuSelection();
  } else if (event.code === 'Space') {
    event.preventDefault();
    playButtonClick(); // Play click sound on selection
    const selectedItem = document.getElementById(menuItems[currentMenuIndex]);
    console.log('Activating menu item:', menuItems[currentMenuIndex]);
    if (selectedItem && selectedItem.onclick) {
      selectedItem.onclick();
    }
  }
}

// Connect all buttons when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
  console.log('ðŸŽ® DOM loaded, connecting menu...');
  console.log('Menu items array:', menuItems);
  
  // Update leaderboard option appearance on load
  updateLeaderboardOption();
  
  // Initialize coins system
  initializeCoins();
  
  // Update coin display on page load - multiple attempts to ensure visibility
  console.log('ðŸª™ Initial coin display update...');
  updateCoinDisplay();
  
  // Additional updates with delays to handle timing issues
  setTimeout(() => {
    console.log('ðŸª™ Secondary coin display update (100ms)...');
    updateCoinDisplay();
  }, 100);
  
  setTimeout(() => {
    console.log('ðŸª™ Tertiary coin display update (500ms)...');
    updateCoinDisplay();
  }, 500);
  
  setTimeout(() => {
    console.log('ðŸª™ Final coin display update (1000ms)...');
    updateCoinDisplay();
  }, 1000);
  
  // Set up periodic coin display refresh to ensure coins always show
  setInterval(updateCoinDisplay, 5000); // Update every 5 seconds
  
  // Check if all menu elements exist
  menuItems.forEach(id => {
    const element = document.getElementById(id);
    console.log(`Menu element ${id}:`, element ? 'found' : 'NOT FOUND');
  });
  
  // Check if images are loading properly
  setTimeout(() => {
    const images = document.querySelectorAll('img[src="coin.gif"], img[src="book.gif"]');
    console.log(`ðŸ–¼ï¸ Found ${images.length} game images`);
    images.forEach((img, index) => {
      console.log(`Image ${index + 1}: ${img.src}`);
      console.log(`- Complete: ${img.complete}`);
      console.log(`- Natural width: ${img.naturalWidth}`);
      console.log(`- Natural height: ${img.naturalHeight}`);
      
      if (!img.complete || img.naturalWidth === 0) {
        console.warn(`âŒ Image failed to load: ${img.src}`);
        // Try to reload the image
        const newSrc = img.src;
        img.src = '';
        img.src = newSrc + '?' + Date.now(); // Add cache buster
      } else {
        console.log(`âœ… Image loaded successfully: ${img.src}`);
      }
    });
  }, 2000);
  
  // ===== CrazyGames SDK: Start loading =====
  startLoading();
  
  // Get user info from CrazyGames (optional)
  getUserInfo();
  
  // Set up menu navigation
  updateMenuSelection();
  
  // Update arcade high score display
  updateArcadeHighScore();
  
  // Add keyboard event listener for menu navigation
  document.addEventListener('keydown', function(event) {
    const introScreen = document.getElementById('introScreen');
    if (introScreen && introScreen.style.display !== 'none') {
      handleMenuNavigation(event);
    }
  });
  
  // Connect Start Game button (legacy support)
  const startBtn = document.getElementById('startBtn');
  if (startBtn) {
    startBtn.onclick = () => {
      playButtonClick();
      stopBackgroundMusic();
      startGame();
    };
    console.log('Start button connected');
  }
  
  // Connect menu items for mouse clicks
  const startOption = document.getElementById('startOption');
  const instructionsOption = document.getElementById('instructionsOption');
  const shopOption = document.getElementById('shopOption');
  const customizeOption = document.getElementById('customizeOption');
  
  console.log('ðŸ” Connecting menu options...');
  console.log('startOption element:', startOption);
  console.log('shopOption element:', shopOption);
  console.log('customizeOption element:', customizeOption);
  console.log('instructionsOption element:', instructionsOption);
  const leaderboardOption = document.getElementById('leaderboardOption');
  
  if (startOption) {
    startOption.onclick = () => {
      console.log('ðŸŽ® Start option clicked');
      playButtonClick();
      stopBackgroundMusic();
      startGame();
    };
    
    // Add hover effects
    startOption.addEventListener('mouseenter', playButtonHover);
    console.log('âœ… Start option connected');
  } else {
    console.error('âŒ Start option not found!');
  }
  
  if (instructionsOption) {
    instructionsOption.onclick = () => {
      console.log('ðŸ“– Instructions option clicked');
      playButtonClick();
      toggleInstructions();
    };
    
    // Add hover effects
    instructionsOption.addEventListener('mouseenter', playButtonHover);
    console.log('âœ… Instructions option connected');
  } else {
    console.error('âŒ Instructions option not found!');
  }
  
  if (shopOption) {
    shopOption.onclick = () => {
      console.log('ðŸ›’ Shop option clicked');
      playButtonClick();
      showShop();
    };
    
    // Add hover effects
    shopOption.addEventListener('mouseenter', playButtonHover);
    console.log('âœ… Shop option connected');
  } else {
    console.error('âŒ Shop option not found!');
  }
  
  if (leaderboardOption) {
    leaderboardOption.onclick = () => {
      console.log('ðŸ† Leaderboard option clicked');
      playButtonClick();
      showLeaderboard(); // Always show leaderboard - no access check needed
    };
    
    // Add hover effects
    leaderboardOption.addEventListener('mouseenter', playButtonHover);
    console.log('âœ… Leaderboard option connected');
  } else {
    console.error('âŒ Leaderboard option not found!');
  }
  
  if (customizeOption) {
    customizeOption.onclick = () => {
      console.log('ðŸŽ¨ Customize option clicked');
      playButtonClick();
      showCustomization();
    };
    
    // Add hover effects
    customizeOption.addEventListener('mouseenter', playButtonHover);
    console.log('âœ… Customize option connected');
  } else {
    console.error('âŒ Customize option not found!');
  }
  
  // Connect Instructions toggle button (legacy support)
  const toggleInstructionsBtn = document.getElementById('toggleInstructions');
  if (toggleInstructionsBtn) {
    toggleInstructionsBtn.onclick = toggleInstructions;
    console.log('Instructions toggle connected');
  }
  
  // Connect Clear Games button
  const clearBtn = document.getElementById('clearGames');
  if (clearBtn) {
    clearBtn.onclick = clearAllGameData;
    console.log('Clear Games button connected');
  }
  
  // Connect Snake Skin selector
  const snakeSkinSelect = document.getElementById('snakeSkin');
  if (snakeSkinSelect) {
    snakeSkinSelect.addEventListener('change', function() {
      const selectedValue = this.value;
      if (canUseItem(selectedValue)) {
        snakeSkin = selectedValue;
        localStorage.setItem('pythonixSnakeSkin', snakeSkin);
        console.log('Snake skin changed to:', snakeSkin);
      } else {
        // Reset to previous valid selection
        this.value = snakeSkin;
        showNotification('This skin is locked! Purchase it in the shop.', 'error');
      }
    });
    
    // Set initial skin
    const savedSkin = localStorage.getItem('pythonixSnakeSkin') || 'classic';
    snakeSkinSelect.value = savedSkin;
    snakeSkin = savedSkin;
    updateDropdownAvailability();
    console.log('Snake skin selector connected');
  }

  // Connect Trail Effect selector
  const trailSelect = document.getElementById('trailEffect');
  if (trailSelect) {
    trailSelect.addEventListener('change', function() {
      const selectedValue = this.value;
      if (selectedValue === 'none' || canUseItem(selectedValue)) {
        currentTrail = selectedValue;
        localStorage.setItem('pythonixTrailEffect', currentTrail);
        console.log('Trail effect changed to:', currentTrail);
      } else {
        this.value = currentTrail || 'none';
        showNotification('This trail is locked! Purchase it in the shop.', 'error');
      }
    });
    
    const savedTrail = localStorage.getItem('pythonixTrailEffect') || 'none';
    trailSelect.value = savedTrail;
    currentTrail = savedTrail;
    console.log('Trail effect selector connected');
  }

  // Connect Badge selector
  const badgeSelect = document.getElementById('playerBadge');
  if (badgeSelect) {
    badgeSelect.addEventListener('change', function() {
      const selectedValue = this.value;
      if (selectedValue === 'none' || canUseItem(selectedValue)) {
        currentBadge = selectedValue;
        localStorage.setItem('pythonixPlayerBadge', currentBadge);
        console.log('Badge changed to:', currentBadge);
      } else {
        this.value = currentBadge || 'none';
        showNotification('This badge is locked! Purchase it in the shop.', 'error');
      }
    });
    
    const savedBadge = localStorage.getItem('pythonixPlayerBadge') || 'none';
    badgeSelect.value = savedBadge;
    currentBadge = savedBadge;
    console.log('Badge selector connected');
  }
  
  // Connect Snake Shape selector
  const snakeShapeSelect = document.getElementById('snakeShape');
  const emojiPickerContainer = document.getElementById('emojiPickerContainer');
  if (snakeShapeSelect) {
    snakeShapeSelect.addEventListener('change', function() {
      snakeShape = this.value;
      localStorage.setItem('pythonixSnakeShape', snakeShape);
      
      // Show/hide emoji picker based on selection
      if (snakeShape === 'emoji') {
        emojiPickerContainer.style.display = 'inline';
      } else {
        emojiPickerContainer.style.display = 'none';
      }
      
      console.log('Snake shape changed to:', snakeShape);
    });
    
    // Set initial shape
    const savedShape = localStorage.getItem('pythonixSnakeShape') || 'square';
    snakeShapeSelect.value = savedShape;
    snakeShape = savedShape;
    
    // Show emoji picker if needed
    if (snakeShape === 'emoji') {
      emojiPickerContainer.style.display = 'inline';
    }
    
    console.log('Snake shape selector connected');
  }
  
  // Connect Emoji Picker
  const emojiPicker = document.getElementById('emojiPicker');
  if (emojiPicker) {
    // Handle input changes
    emojiPicker.addEventListener('input', function() {
      const inputValue = this.value.trim();
      
      // Basic validation - allow any text but prefer emojis
      if (inputValue.length > 0) {
        snakeEmoji = inputValue;
        localStorage.setItem('pythonixSnakeEmoji', snakeEmoji);
        console.log('Snake emoji changed to:', snakeEmoji);
      }
    });
    
    // Handle paste events for better emoji support
    emojiPicker.addEventListener('paste', function(e) {
      setTimeout(() => {
        const inputValue = this.value.trim();
        if (inputValue.length > 0) {
          snakeEmoji = inputValue;
          localStorage.setItem('pythonixSnakeEmoji', snakeEmoji);
          console.log('Snake emoji pasted:', snakeEmoji);
        }
      }, 10);
    });
    
    // Set initial emoji
    const savedEmoji = localStorage.getItem('pythonixSnakeEmoji') || 'ðŸ';
    snakeEmoji = savedEmoji;
    emojiPicker.value = snakeEmoji;
    
    console.log('Emoji picker connected');
  }
  
  // Connect Game Mode selector
  const gameModeSelect = document.getElementById('gameMode');
  if (gameModeSelect) {
    gameModeSelect.addEventListener('change', function() {
      gameMode = this.value;
      initGameMode();
      console.log('Game mode changed to:', gameMode);
    });
  }
  
  // Connect Level controls
  const prevLevelBtn = document.getElementById('prevLevel');
  const nextLevelBtn = document.getElementById('nextLevel');
  const levelDisplay = document.getElementById('levelDisplay');
  let currentLevel = 1;
  
  if (prevLevelBtn) {
    prevLevelBtn.addEventListener('click', function() {
      if (currentLevel > 1) {
        currentLevel--;
        levelDisplay.textContent = currentLevel;
      }
    });
  }
  
  if (nextLevelBtn) {
    nextLevelBtn.addEventListener('click', function() {
      if (currentLevel < 10) {  // Max 10 levels
        currentLevel++;
        levelDisplay.textContent = currentLevel;
      }
    });
  }
  
  // Initialize stats display
  updateStatsDisplay();
  
  // ===== INITIALIZE COIN SYSTEM =====
  // Check for daily login bonus
  checkDailyBonus();
  
  // Check for daily free continue token
  checkFreeDailyContinue();
  
  // Initialize daily challenges
  initializeDailyChallenges();
  
  // Update coin display
  updateCoinDisplay();
  
  // Initialize equipment system and sync with old storage
  initializeEquipment();
  
  // Restore any lost player data
  restorePlayerData();
  
  // Update dropdown availability based on owned items
  updateDropdownAvailability();
  
  // Connect customization modal controls
  connectCustomizationControls();
  
  // ===== CrazyGames SDK: Finish loading =====
  // Small delay to ensure everything is ready
  setTimeout(() => {
    finishLoading();
    console.log('Game initialization complete');
  }, 100);
  
  console.log('All buttons connected successfully');
});

// Theme changing function
function changeTheme(themeName) {
  console.log('Changing theme to:', themeName);
  
  // Remove all existing theme classes
  document.body.className = document.body.className.replace(/theme-\w+/g, '');
  
  // Handle auto theme (day/night based on time)
  if (themeName === 'auto') {
    const hour = new Date().getHours();
    themeName = (hour >= 6 && hour < 18) ? 'day' : 'night';
  }
  
  // Add new theme class
  document.body.classList.add('theme-' + themeName);
  
  // Save theme preference
  localStorage.setItem('pythonixTheme', themeName);
  
  console.log('Applied theme class: theme-' + themeName);
}

// Make sure keyboard handler is working
window.addEventListener('load', function() {
  console.log('Window loaded, setting up keyboard handler...');
  window.pendingDirection = null;
  window.direction = 'RIGHT';
  
  // Test keyboard handler
  console.log('Keyboard handler should be active. Try pressing arrow keys.');
  
  // Add extra key listener as backup
  document.addEventListener('keydown', function(e) {
    const key = e.key.toLowerCase();
    console.log('Key pressed:', key);
    
    // Handle powerup hotkeys during gameplay
    if (!isGameOver && !isPaused) {
      // Powerup hotkeys (1, 2, 3, etc.)
      if (key >= '1' && key <= '9') {
        const powerupKeys = {
          '1': 'powerup_speed_boost',
          '2': 'powerup_shield', 
          '3': 'powerup_double_points',
          '4': 'powerup_magnet',
          '5': 'powerup_slow_time'
        };
        
        const powerupId = powerupKeys[key];
        if (powerupId && usePowerup(powerupId)) {
          showNotification(`Used ${SHOP_ITEMS[powerupId]?.name || 'powerup'}! âš¡`);
        } else if (powerupId) {
          showNotification(`No ${SHOP_ITEMS[powerupId]?.name || 'powerup'} in inventory!`, 'error');
        }
        return;
      }
    }
    
    // Handle pause/resume with spacebar
    if (key === ' ' || key === 'space') {
      e.preventDefault();
      const introScreen = document.getElementById('introScreen');
      
      // If on intro screen, handle menu navigation
      if (introScreen && introScreen.style.display !== 'none') {
        handleMenuNavigation(e);
        return;
      }
      
      // If in game, toggle pause
      if (!isGameOver) {
        isPaused = !isPaused;
        if (isPaused) {
          clearInterval(gameInterval);
          console.log('Game paused');
          // Show pause indicator
          const canvas = document.getElementById('gameCanvas');
          if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.font = '24px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
            ctx.font = '12px "Press Start 2P"';
            ctx.fillText('PRESS SPACEBAR TO RESUME', canvas.width/2, canvas.height/2 + 40);
          }
        } else {
          gameInterval = setInterval(gameLoop, speed);
          console.log('Game resumed');
          drawBoard(); // Redraw the board to clear pause overlay
        }
      }
      return;
    }
    
    // Handle escape key to return to menu
    if (key === 'escape') {
      e.preventDefault();
      const introScreen = document.getElementById('introScreen');
      
      // If not on intro screen (i.e., in game), return to menu
      if (!introScreen || introScreen.style.display === 'none') {
        showStartMenu();
        return;
      }
    }
    
    if (isGameOver || isPaused) return;
    
    if (key === 'arrowleft' || key === 'a') {
      window.pendingDirection = 'LEFT';
    } else if (key === 'arrowright' || key === 'd') {
      window.pendingDirection = 'RIGHT';
    } else if (key === 'arrowup' || key === 'w') {
      window.pendingDirection = 'UP';
    } else if (key === 'arrowdown' || key === 's') {
      window.pendingDirection = 'DOWN';
    }
    
    if (['arrowup','arrowdown','arrowleft','arrowright'].includes(key)) {
      e.preventDefault();
    }
  });
});

// ============= DEBUG FUNCTIONS =============
// Call these from browser console (F12)

// Unlock everything and give massive coins for testing
window.debugUnlockAll = function() {
  console.log('ðŸ› DEBUG: Unlocking everything and giving test coins...');
  
  // Give 50,000 coins
  localStorage.setItem('pythonixCoins', '50000');
  
  // Set high score to 20,000 to unlock legendary items
  localStorage.setItem('pythonixHighScore', '20000');
  
  // Set stats to unlock all achievements
  const testStats = {
    gamesPlayed: 300,
    totalFoodsEaten: 3000,
    totalScore: 50000,
    totalTime: 10000
  };
  localStorage.setItem('pythonixStats', JSON.stringify(testStats));
  
  // Add only free items and other item types to owned items (no shop skins)
  const nonShopItems = Object.keys(SHOP_ITEMS).filter(itemId => {
    const item = SHOP_ITEMS[itemId];
    return item.type !== 'skin' || item.free; // Keep free skins, exclude shop skins
  });
  localStorage.setItem('pythonixOwnedItems', JSON.stringify(nonShopItems));
  
  // Add all achievement rewards as earned
  const allAchievements = [
    'survive_60s', 'survive_120s', 'first_50', 'first_100', 'first_500', 
    'untouchable_master', 'eat_25', 'eat_50', 'eat_100', 'play_5', 'play_10', 'play_25'
  ];
  localStorage.setItem('pythonixEarnedAchievements', JSON.stringify(allAchievements));
  
  // Add powerups to inventory
  const powerupInventory = {
    'powerup_speed_boost': 10,
    'powerup_shield': 10,
    'powerup_double_points': 10,
    'powerup_magnet': 10,
    'powerup_slow_time': 10
  };
  localStorage.setItem('pythonixPowerupInventory', JSON.stringify(powerupInventory));
  
  alert('ðŸŽ® DEBUG MODE: Everything unlocked! You have 50,000 coins and all items. Refresh the page to see changes.');
  console.log('âœ… Debug unlock complete! Refresh page to see changes.');
};

// Reset everything back to fresh account
window.debugResetAll = function() {
  console.log('ðŸ› DEBUG: Resetting account to fresh state...');
  
  // Clear all game data
  const keysToRemove = [
    'pythonixCoins',
    'pythonixHighScore', 
    'pythonixStats',
    'pythonixOwnedItems',
    'pythonixEquippedItems',
    'pythonixSnakeSkin',
    'pythonixSnakeBadge',
    'pythonixSnakeTrail',
    'pythonixEarnedAchievements',
    'pythonixPowerupInventory',
    'pythonixLastLogin',
    'pythonixLoginStreak'
  ];
  
  keysToRemove.forEach(key => localStorage.removeItem(key));
  
  // Set default starting values
  localStorage.setItem('pythonixCoins', '0');
  localStorage.setItem('pythonixHighScore', '0');
  localStorage.setItem('pythonixStats', '{"gamesPlayed": 0, "totalFoodsEaten": 0}');
  
  // Set default owned items (free skins only)
  const defaultItems = [
    'skin_classic', 'skin_neon', 'skin_rainbow', 'skin_retro', 'skin_pacman', 'skin_arcade',
    'none', 'badge_none'
  ];
  localStorage.setItem('pythonixOwnedItems', JSON.stringify(defaultItems));
  
  alert('ðŸ”„ DEBUG MODE: Account reset to fresh state! Refresh the page to start over.');
  console.log('âœ… Debug reset complete! Refresh page to see clean slate.');
};

// Quick test for legendary items specifically
window.debugTestLegendary = function() {
  console.log('ðŸ› DEBUG: Testing legendary unlock...');
  
  // Set exactly 16,000 points to trigger legendary unlock
  localStorage.setItem('pythonixHighScore', '16000');
  localStorage.setItem('pythonixCoins', '10000');
  
  // Simulate the achievement being earned
  const earnedAchievements = JSON.parse(localStorage.getItem('pythonixEarnedAchievements') || '[]');
  if (!earnedAchievements.includes('untouchable_master')) {
    earnedAchievements.push('untouchable_master');
    localStorage.setItem('pythonixEarnedAchievements', JSON.stringify(earnedAchievements));
    
    // Auto-unlock legendary items
    const ownedItems = JSON.parse(localStorage.getItem('pythonixOwnedItems') || '[]');
    localStorage.setItem('pythonixOwnedItems', JSON.stringify(ownedItems));
  }
  
  alert('ðŸ‘‘ DEBUG: Legendary items unlocked! Check the shop to see them. Refresh to see changes.');
  console.log('âœ… Legendary test complete! Check shop for legendary items.');
};

// Test specific skin rendering
window.debugTestSkin = function(skinId) {
  console.log('ðŸ› DEBUG: Testing skin:', skinId);
  
  // Force equip the skin using the proper equipment system
  equipItem(skinId, 'skin');
  
  // Check what happened
  const equipped = getEquippedItems();
  console.log('After equipping - Equipment object:', equipped);
  console.log('After equipping - snakeSkin variable:', snakeSkin);
  
  alert(`ðŸŽ¨ DEBUG: Equipped ${skinId}! Check console and start a game to see it.`);
};

// Debug the entire equip flow
window.debugEquipFlow = function(skinId) {
  console.log('ðŸ› DEBUG: Full equip flow for:', skinId);
  
  // Check if item exists
  const item = SHOP_ITEMS[skinId];
  console.log('1. Item exists:', !!item, item);
  
  // Check if owned
  const ownedItems = getOwnedItems();
  const isOwned = ownedItems.includes(skinId) || (item && item.free);
  console.log('2. Is owned:', isOwned, 'Owned items:', ownedItems);
  
  // Try to equip
  console.log('3. Calling equipItem...');
  equipItem(skinId, 'skin');
  
  // Check results
  const equipped = getEquippedItems();
  console.log('4. Equipment result:', equipped);
  console.log('5. snakeSkin variable:', snakeSkin);
  
  // Apply effects
  console.log('6. Applying visual effects...');
  applyVisualEffects();
  console.log('7. Final snakeSkin variable:', snakeSkin);
  
  alert(`ðŸŽ¨ DEBUG: Complete flow for ${skinId} finished! Check console.`);
};

// Test unequip functionality
window.debugTestUnequip = function(itemType) {
  console.log('ðŸ› DEBUG: Testing unequip for type:', itemType);
  
  // Check current equipment
  const equipped = getEquippedItems();
  console.log('1. Current equipment:', equipped);
  
  // Call unequip
  console.log('2. Calling unequipItem...');
  unequipItem(itemType);
  
  // Check results
  const newEquipped = getEquippedItems();
  console.log('3. New equipment:', newEquipped);
  
  alert(`ðŸ”„ DEBUG: Unequip test for ${itemType} complete! Check console.`);
};

// ============= LEADERBOARD SYSTEM =============

// ============= GLOBAL LEADERBOARD SYSTEM =============

// LootLocker Global Leaderboard Integration
const LOOTLOCKER_CONFIG = {
  gameApiKey: "dev_4ee5502534d5420f920ea3c675c1a5f8", // Replace with your actual LootLocker API key
  leaderboardId: "31940", // Replace with your actual leaderboard ID
  baseUrl: "https://api.lootlocker.io",
  fallbackToLocal: true
};

// Global session token for LootLocker
let lootlockerSessionToken = null;

// --- Step 1: Start a guest session ---
async function startLootLockerSession(playerName = "Guest") {
  try {
    const url = `${LOOTLOCKER_CONFIG.baseUrl}/game/v2/session/guest`;
    const headers = {
      "x-api-key": LOOTLOCKER_CONFIG.gameApiKey,
      "Content-Type": "application/json"
    };
    const data = { "player_identifier": playerName };
    
    console.log('ðŸ” Starting LootLocker session for:', playerName);
    
    const response = await fetch(url, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify(data)
    });
    
    if (!response.ok) {
      throw new Error(`Session failed: ${response.status}`);
    }
    
    const session = await response.json();
    lootlockerSessionToken = session.session_token;
    console.log('âœ… LootLocker session started successfully');
    return session.session_token;
    
  } catch (error) {
    console.error('âŒ LootLocker session failed:', error);
    return null;
  }
}

// --- Step 2: Submit a score ---
async function submitScoreToLootLocker(score, playerName = null) {
  try {
    // Ensure we have a session
    if (!lootlockerSessionToken) {
      const finalName = playerName || localStorage.getItem('pythonixPlayerName') || 'Anonymous Snake';
      await startLootLockerSession(finalName);
    }
    
    if (!lootlockerSessionToken) {
      throw new Error('No valid session token');
    }
    
    const url = `${LOOTLOCKER_CONFIG.baseUrl}/game/leaderboards/${LOOTLOCKER_CONFIG.leaderboardId}/submit`;
    const headers = {
      "x-api-key": LOOTLOCKER_CONFIG.gameApiKey,
      "x-session-token": lootlockerSessionToken,
      "Content-Type": "application/json"
    };
    const data = { "score": score };
    
    console.log('ðŸ“¤ Submitting score to LootLocker:', score);
    
    const response = await fetch(url, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify(data)
    });
    
    if (!response.ok) {
      throw new Error(`Score submission failed: ${response.status}`);
    }
    
    const result = await response.json();
    console.log('âœ… Score submitted to LootLocker:', result);
    
    // Get the player's rank from the response
    const rank = result.rank || 0;
    return { rank: rank, total: 0, global: true };
    
  } catch (error) {
    console.error('âŒ LootLocker score submission failed:', error);
    return { rank: 0, total: 0, global: false };
  }
}

// --- Step 3: Get top scores ---
async function getLootLockerLeaderboard() {
  try {
    const url = `${LOOTLOCKER_CONFIG.baseUrl}/game/leaderboards/${LOOTLOCKER_CONFIG.leaderboardId}/list`;
    const headers = { "x-api-key": LOOTLOCKER_CONFIG.gameApiKey };
    
    console.log('ðŸ“¥ Fetching LootLocker leaderboard...');
    
    const response = await fetch(url, {
      method: 'GET',
      headers: headers
    });
    
    if (!response.ok) {
      throw new Error(`Leaderboard fetch failed: ${response.status}`);
    }
    
    const data = await response.json();
    console.log('âœ… LootLocker leaderboard loaded:', data);
    
    // Convert LootLocker format to our game format
    const scores = data.items ? data.items.map(entry => ({
      name: entry.player.name || 'Anonymous',
      score: entry.score,
      date: new Date().toISOString(), // LootLocker doesn't provide date in this endpoint
      id: entry.player.id || Math.random()
    })) : [];
    
    console.log('ðŸ“Š Converted', scores.length, 'LootLocker scores');
    return scores;
    
  } catch (error) {
    console.error('âŒ LootLocker leaderboard fetch failed:', error);
    return [];
  }
}

async function saveScoreToGlobalLeaderboard(playerScore, playerName = null) {
  try {
    const finalName = playerName || localStorage.getItem('pythonixPlayerName') || 'Anonymous Snake';
    console.log('ðŸŒ Saving score to LootLocker global leaderboard:', playerScore, 'by', finalName);
    
    // Try LootLocker first
    const result = await submitScoreToLootLocker(playerScore, finalName);
    
    if (result.global) {
      console.log('âœ… Score saved to LootLocker! Rank:', result.rank);
      return result;
    } else {
      throw new Error('LootLocker submission failed');
    }
    
  } catch (error) {
    console.error('âŒ LootLocker save failed, using localStorage fallback:', error);
    
    if (LOOTLOCKER_CONFIG.fallbackToLocal) {
      // Fallback to shared localStorage
      const GLOBAL_STORAGE_KEY = 'pythonix_global_leaderboard_shared';
      
      let leaderboard = [];
      try {
        const stored = localStorage.getItem(GLOBAL_STORAGE_KEY);
        if (stored) {
          leaderboard = JSON.parse(stored);
        }
      } catch (e) {
        leaderboard = [];
      }
      
      const newEntry = {
        name: finalName,
        score: playerScore,
        date: new Date().toISOString(),
        id: Date.now() + Math.random()
      };
      
      leaderboard.push(newEntry);
      leaderboard.sort((a, b) => b.score - a.score);
      leaderboard = leaderboard.slice(0, 50);
      localStorage.setItem(GLOBAL_STORAGE_KEY, JSON.stringify(leaderboard));
      
      const playerRank = leaderboard.findIndex(entry => entry.id === newEntry.id) + 1;
      return { rank: playerRank, total: leaderboard.length, global: false };
    }
    
    return { rank: 0, total: 0, global: false };
  }
}

function saveScoreToLocalLeaderboard(playerScore, playerName = null) {
  const leaderboard = getLocalLeaderboard();
  const timestamp = new Date().toISOString();
  const finalName = playerName || localStorage.getItem('pythonixPlayerName') || 'Anonymous Snake';
  
  const newEntry = {
    name: finalName,
    score: playerScore,
    date: timestamp,
    id: Date.now() // Unique identifier
  };
  
  leaderboard.push(newEntry);
  
  // Sort by score (highest first) and keep top 20
  leaderboard.sort((a, b) => b.score - a.score);
  const topScores = leaderboard.slice(0, 20);
  
  localStorage.setItem('pythonixLeaderboard', JSON.stringify(topScores));
  
  // Return the player's ranking
  const playerRank = topScores.findIndex(entry => entry.id === newEntry.id) + 1;
  return { rank: playerRank, total: topScores.length, global: false };
}

async function getGlobalLeaderboard() {
  try {
    console.log('ðŸŒ Fetching global leaderboard from LootLocker...');
    
    // Try LootLocker first
    const scores = await getLootLockerLeaderboard();
    
    if (scores.length > 0) {
      console.log('âœ… Using LootLocker global leaderboard with', scores.length, 'scores');
      return scores;
    } else {
      throw new Error('No LootLocker scores available');
    }
    
  } catch (error) {
    console.warn('âŒ LootLocker fetch failed, using localStorage fallback:', error);
    
    if (LOOTLOCKER_CONFIG.fallbackToLocal) {
      // Fallback to shared localStorage
      const GLOBAL_STORAGE_KEY = 'pythonix_global_leaderboard_shared';
      
      let scores = [];
      try {
        const stored = localStorage.getItem(GLOBAL_STORAGE_KEY);
        if (stored) {
          scores = JSON.parse(stored);
        }
      } catch (e) {
        scores = [];
      }
      
      console.log('ðŸ“± Using localStorage fallback with', scores.length, 'scores');
      return scores;
    }
    
    return [];
  }
}

function getLocalLeaderboard() {
  try {
    return JSON.parse(localStorage.getItem('pythonixLeaderboard') || '[]');
  } catch (e) {
    console.error('Error loading local leaderboard:', e);
    return [];
  }
}

async function showLeaderboard() {
  const playerName = localStorage.getItem('pythonixPlayerName') || 'Anonymous Snake';
  
  // Show loading state
  let leaderboardHTML = `
    <div style="background: rgba(0,0,0,0.95); color: #FFD700; padding: 30px; border-radius: 15px; max-width: 500px; margin: 20px auto; font-family: 'Press Start 2P', monospace;">
      <h2 style="text-align: center; margin-bottom: 25px; color: #FFD700; text-shadow: 0 0 10px #FFD700;">ðŸ† GLOBAL LEADERBOARD ðŸ†</h2>
      <div style="text-align: center; color: #00FFFF; font-size: 10px; padding: 20px;">
        ðŸŒ Loading global scores...
      </div>
    </div>`;
  
  // Create overlay immediately with loading state
  const overlay = document.createElement('div');
  overlay.id = 'leaderboardOverlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(5px);
  `;
  
  overlay.innerHTML = leaderboardHTML;
  document.body.appendChild(overlay);
  
  // Close on click outside
  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) {
      closeLeaderboard();
    }
  });
  
  try {
    // Load global leaderboard
    console.log('ðŸ” Loading leaderboard for display...');
    const leaderboard = await getGlobalLeaderboard();
    console.log('ðŸ“Š Leaderboard data:', leaderboard);
    const isGlobal = leaderboard.length > 0;
    
    leaderboardHTML = `
      <div style="background: rgba(0,0,0,0.95); color: #FFD700; padding: 30px; border-radius: 15px; max-width: 500px; margin: 20px auto; font-family: 'Press Start 2P', monospace;">
        <h2 style="text-align: center; margin-bottom: 25px; color: #FFD700; text-shadow: 0 0 10px #FFD700;">ðŸ† ${isGlobal ? 'GLOBAL' : 'LOCAL'} LEADERBOARD ðŸ†</h2>
        <div style="background: rgba(255,0,255,0.1); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
          <div style="color: #00FF00; font-size: 10px; margin-bottom: 10px;">YOUR STATS:</div>
          <div style="color: #FFD700; font-size: 8px;">Name: ${playerName}</div>
          <div style="color: #FFD700; font-size: 8px;">High Score: ${localStorage.getItem('pythonixHighScore') || 0}</div>
          ${isGlobal ? '<div style="color: #00FFFF; font-size: 7px;">ðŸŒ Competing globally!</div>' : '<div style="color: #FF6B6B; font-size: 7px;">âš ï¸ Local scores only</div>'}
        </div>`;
    
    if (leaderboard.length === 0) {
      leaderboardHTML += `
        <div style="text-align: center; color: #00FFFF; font-size: 10px; padding: 20px;">
          No scores yet! Play some games to fill the leaderboard.
        </div>`;
    } else {
      leaderboardHTML += '<div style="max-height: 300px; overflow-y: auto;">';
      
      leaderboard.forEach((entry, index) => {
        const isPlayer = entry.name === playerName;
        const rankColor = index === 0 ? '#FFD700' : index === 1 ? '#C0C0C0' : index === 2 ? '#CD7F32' : '#00FFFF';
        const bgColor = isPlayer ? 'rgba(255,215,0,0.2)' : 'rgba(255,0,255,0.1)';
        
        leaderboardHTML += `
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; margin: 5px 0; background: ${bgColor}; border-radius: 5px; border: ${isPlayer ? '1px solid #FFD700' : '1px solid rgba(255,0,255,0.3)'};">
            <div style="display: flex; align-items: center;">
              <span style="color: ${rankColor}; font-size: 10px; width: 30px;">#${index + 1}</span>
              <span style="color: #00FF00; font-size: 8px; max-width: 120px; overflow: hidden; text-overflow: ellipsis;">${entry.name}${isPlayer ? ' (YOU)' : ''}</span>
            </div>
            <div style="text-align: right;">
              <div style="color: #FFD700; font-size: 9px;">${entry.score.toLocaleString()}</div>
              <div style="color: #00FFFF; font-size: 6px;">${new Date(entry.date).toLocaleDateString()}</div>
            </div>
          </div>`;
      });
      
      leaderboardHTML += '</div>';
    }
    
    leaderboardHTML += `
        <div style="text-align: center; margin-top: 20px;">
          <button onclick="closeLeaderboard()" style="background: linear-gradient(45deg, #FF00FF, #00FFFF); color: #000; border: none; padding: 10px 20px; border-radius: 5px; font-family: 'Press Start 2P', monospace; font-size: 8px; cursor: pointer; text-shadow: none;">CLOSE</button>
          <button onclick="changePlayerName()" style="background: linear-gradient(45deg, #FFD700, #FFA500); color: #000; border: none; padding: 10px 20px; border-radius: 5px; font-family: 'Press Start 2P', monospace; font-size: 8px; cursor: pointer; text-shadow: none; margin-left: 10px;">CHANGE NAME</button>
        </div>
      </div>`;
    
    // Update the overlay content
    overlay.innerHTML = leaderboardHTML;
    
  } catch (error) {
    console.error('Error loading leaderboard:', error);
    
    // Show error state
    leaderboardHTML = `
      <div style="background: rgba(0,0,0,0.95); color: #FFD700; padding: 30px; border-radius: 15px; max-width: 500px; margin: 20px auto; font-family: 'Press Start 2P', monospace;">
        <h2 style="text-align: center; margin-bottom: 25px; color: #FFD700; text-shadow: 0 0 10px #FFD700;">ðŸ† LEADERBOARD ðŸ†</h2>
        <div style="text-align: center; color: #FF6B6B; font-size: 10px; padding: 20px;">
          âŒ Failed to load global leaderboard<br>
          Check your internet connection
        </div>
        <div style="text-align: center; margin-top: 20px;">
          <button onclick="closeLeaderboard()" style="background: linear-gradient(45deg, #FF00FF, #00FFFF); color: #000; border: none; padding: 10px 20px; border-radius: 5px; font-family: 'Press Start 2P', monospace; font-size: 8px; cursor: pointer; text-shadow: none;">CLOSE</button>
        </div>
      </div>`;
    
    overlay.innerHTML = leaderboardHTML;
  }
}

function closeLeaderboard() {
  const overlay = document.getElementById('leaderboardOverlay');
  if (overlay) {
    overlay.remove();
  }
}

function changePlayerName() {
  const currentName = localStorage.getItem('pythonixPlayerName') || 'Anonymous Snake';
  const newName = prompt('Enter your leaderboard name:', currentName);
  
  if (newName && newName.trim() && newName.trim() !== currentName) {
    const finalName = newName.trim().substring(0, 20); // Limit length
    localStorage.setItem('pythonixPlayerName', finalName);
    showNotification(`Name changed to: ${finalName}`, 'success');
    closeLeaderboard();
    showLeaderboard(); // Refresh the display
  }
}

// Check if player has access to leaderboard
function hasLeaderboardAccess() {
  return true; // Leaderboard is now always accessible to everyone
}

// Update leaderboard option appearance
function updateLeaderboardOption() {
  const leaderboardOption = document.getElementById('leaderboardOption');
  if (leaderboardOption) {
    const spanElement = leaderboardOption.querySelector('span:last-child');
    
    // Leaderboard is always accessible now
    spanElement.textContent = 'LEADERBOARD';
    leaderboardOption.style.opacity = '1';
  }
}

// Modified score saving to include leaderboard
async function saveScoreWithLeaderboard(finalScore) {
  // Save high score
  const currentHighScore = parseInt(localStorage.getItem('pythonixHighScore') || '0');
  if (finalScore > currentHighScore) {
    localStorage.setItem('pythonixHighScore', finalScore.toString());
  }
  
  // Get player name
  const playerName = localStorage.getItem('pythonixPlayerName') || 'Anonymous Snake';
  console.log('ðŸ’¾ Saving score:', finalScore, 'for player:', playerName);
  
  // Always save to global leaderboard - it's now a free feature
  try {
    const ranking = await saveScoreToGlobalLeaderboard(finalScore, playerName);
    console.log('ðŸ† Score saved with ranking:', ranking);
    if (ranking && ranking.rank <= 10) {
      showNotification(`ðŸ† Global Rank #${ranking.rank}!`, 'success');
    }
  } catch (error) {
    console.error('Failed to save to global leaderboard, using local fallback:', error);
    const ranking = saveScoreToLocalLeaderboard(finalScore, playerName);
    if (ranking.rank <= 10) {
      showNotification(`ðŸ† Local Rank #${ranking.rank}!`, 'success');
    }
  }
}

// Debug function to test coin display
window.debugCoinDisplay = function() {
  console.log('ðŸª™ DEBUG: Testing coin display system...');
  
  const currentCoins = getCoins();
  console.log('ðŸª™ DEBUG: Current coins from localStorage:', currentCoins);
  
  const coinElements = document.querySelectorAll('.coin-display');
  console.log('ðŸª™ DEBUG: Found coin display elements:', coinElements.length);
  
  coinElements.forEach((el, index) => {
    console.log(`ðŸª™ DEBUG: Element ${index}:`, {
      id: el.id,
      textContent: el.textContent,
      style: el.style.display,
      visible: el.offsetParent !== null
    });
  });
  
  console.log('ðŸª™ DEBUG: Manually triggering updateCoinDisplay...');
  updateCoinDisplay();
  
  // Add some test coins
  console.log('ðŸª™ DEBUG: Adding 100 test coins...');
  addCoins(100, 'debug_test');
};

// ============= DEBUG FUNCTIONS =============

// Test audio system
window.debugTestAudio = function() {
  console.log('ðŸ› DEBUG: Testing audio system...');
  
  console.log('1. Background music object:', backgroundMusic);
  console.log('2. Music file source:', backgroundMusic.src);
  console.log('3. Music ready state:', backgroundMusic.readyState);
  console.log('4. Music paused:', backgroundMusic.paused);
  console.log('5. Music volume:', backgroundMusic.volume);
  
  try {
    console.log('6. Attempting to play background music...');
    playBackgroundMusic();
    setTimeout(() => {
      console.log('7. Music state after play attempt:', {
        paused: backgroundMusic.paused,
        currentTime: backgroundMusic.currentTime,
        duration: backgroundMusic.duration
      });
    }, 1000);
  } catch (e) {
    console.log('6. Error playing music:', e);
  }
  
  alert('ðŸŽµ DEBUG: Audio test complete! Check console for details.');
};

console.log('ðŸŽ® DEBUG FUNCTIONS LOADED:');
console.log('â€¢ debugUnlockAll() - Unlock everything with test coins');
console.log('â€¢ debugResetAll() - Reset account to fresh state'); 
console.log('â€¢ debugTestLegendary() - Test legendary 16k unlock specifically');
console.log('â€¢ debugTestSkin("skinId") - Force test a specific skin (e.g. debugTestSkin("skin_pixel"))');
console.log('â€¢ debugEquipFlow("skinId") - Debug the entire equip process step by step');
console.log('â€¢ debugTestUnequip("type") - Test unequip functionality (e.g. debugTestUnequip("trail"))');
console.log('â€¢ debugTestAudio() - Test the background music system');

</script>
</body>
</html>